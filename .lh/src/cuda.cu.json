{
    "sourceFile": "src/cuda.cu",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 751,
            "patches": [
                {
                    "date": 1689671333300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1689671584193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1427,8 +1427,12 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i];\n+        }        \n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1689671623569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1085,9 +1085,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n+            if(tmp_p <= 0.1);// && tmp_p2 <= 0.1)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689727921449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1101,12 +1101,9 @@\n                         break;\n                     }\n                     else\n                     {\n-                        if(j == _JDOF-1)\n-                        {\n-                            find_sol[index] = 1;\n-                        }                        \n+                        find_sol[index] = 1;     \n                         // break;\n                     }\n                 }\n             }\n"
                },
                {
                    "date": 1689728095353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1085,9 +1085,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.1);// && tmp_p2 <= 0.1)\n+            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689728170676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1426,9 +1426,9 @@\n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         for(int i = 0; i<_sampling_num; i++)\n         {\n-            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i];\n+            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;;\n         }        \n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n"
                },
                {
                    "date": 1689728200777,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1085,9 +1085,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n+            if(tmp_p <= 0.1 && tmp_p2 <= 0.5)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n@@ -1426,9 +1426,9 @@\n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         for(int i = 0; i<_sampling_num; i++)\n         {\n-            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;;\n+            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;\n         }        \n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n"
                },
                {
                    "date": 1689728318276,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1071,8 +1071,9 @@\n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n                 rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+                printf(\"rotation_EE_index[%d] : %f\",i,rotation_EE_index[i]);\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689728342364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1071,9 +1071,9 @@\n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n                 rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-                printf(\"rotation_EE_index[%d] : %f\",i,rotation_EE_index[i]);\n+                printf(\"rotation_EE_index[%d] : %f\",i,rotation_EE_index[i])\\n;\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689728354159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1071,9 +1071,9 @@\n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n                 rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-                printf(\"rotation_EE_index[%d] : %f\",i,rotation_EE_index[i])\\n;\n+                printf(\"rotation_EE_index[%d] : %f\\n\",i,rotation_EE_index[i]);\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689728397859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1070,10 +1070,10 @@\n \n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n-                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-                printf(\"rotation_EE_index[%d] : %f\\n\",i,rotation_EE_index[i]);\n+                rotation_EE_index[j] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+                printf(\"rotation_EE_index[%d] : %f\\n\",j,rotation_EE_index[j]);\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689728403580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1071,9 +1071,9 @@\n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n                 rotation_EE_index[j] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-                printf(\"rotation_EE_index[%d] : %f\\n\",j,rotation_EE_index[j]);\n+                // printf(\"rotation_EE_index[%d] : %f\\n\",j,rotation_EE_index[j]);\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689728506593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1425,12 +1425,12 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;\n-        }        \n+        // for(int i = 0; i<_sampling_num; i++)\n+        // {\n+        //     cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;\n+        // }        \n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1689728749598,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1551,12 +1551,12 @@\n                 }\n                 // returnArray[]\n                 _q_des[i] = e[_min_sol*_time_window*_JDOF+9+i*_time_window];\n                 _qdot_des[i] = d[_min_sol*_time_window*_JDOF+9+i*_time_window];\n-                cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n+                // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n             }\n             // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n-            cout<<\"_min_sol : \"<<_min_sol<<endl;\n+            // cout<<\"_min_sol : \"<<_min_sol<<endl;\n             returnArray[0] = 1;\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689728793842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1607,9 +1607,9 @@\n                 returnArray[i+1] = _q_des[i] + (returnArray[_JDOF+i+1] * _dt_cuda);\n \n                 _q_des[i] = returnArray[i+1];\n                 _qdot_des[i] = returnArray[_JDOF+i+1];\n-                cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n+                // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n             }\n             returnArray[0] = 0;\n         }\n     }\n"
                },
                {
                    "date": 1689746828305,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1060,9 +1060,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     if(index < _sampling_num)\n     {\n-        for(int i = 0; i<_time_window; i++)\n+        for(int i = _time_window-_dt2_window; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n@@ -1086,8 +1086,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n+\n             if(tmp_p <= 0.1 && tmp_p2 <= 0.5)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n"
                },
                {
                    "date": 1689746929455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1544,16 +1544,16 @@\n                 // e[i]    // 위치\n                 // returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n                 // returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n                 // returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n-                for(int j = 0; j<10; j++)\n+                for(int j = 0; j<5; j++)\n                 {\n-                    returnArray[i*10+j+1] = e[_min_sol*_time_window*_JDOF+j+i*_time_window]; // 위치\n-                    returnArray[70+i*10+j+1] = d[_min_sol*_time_window*_JDOF+j+i*_time_window]; //속도\n+                    returnArray[i*5+j+1] = e[_min_sol*_time_window*_JDOF+j+i*_time_window]; // 위치\n+                    returnArray[35+i*5+j+1] = d[_min_sol*_time_window*_JDOF+j+i*_time_window]; //속도\n                 }\n                 // returnArray[]\n-                _q_des[i] = e[_min_sol*_time_window*_JDOF+9+i*_time_window];\n-                _qdot_des[i] = d[_min_sol*_time_window*_JDOF+9+i*_time_window];\n+                _q_des[i] = e[_min_sol*_time_window*_JDOF+4+i*_time_window];\n+                _qdot_des[i] = d[_min_sol*_time_window*_JDOF+4+i*_time_window];\n                 // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n             }\n             // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n             // cout<<\"_min_sol : \"<<_min_sol<<endl;\n"
                },
                {
                    "date": 1689747402376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1060,9 +1060,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     if(index < _sampling_num)\n     {\n-        for(int i = _time_window-_dt2_window; i<_time_window; i++)\n+        for(int i = 0; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n@@ -1070,10 +1070,9 @@\n \n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n-                rotation_EE_index[j] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-                // printf(\"rotation_EE_index[%d] : %f\\n\",j,rotation_EE_index[j]);\n+                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n@@ -1086,34 +1085,31 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-\n-            if(tmp_p <= 0.1 && tmp_p2 <= 0.5)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 0.03)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n                     {\n-                        find_sol[index] = 0;\n                         break;\n                     }\n                     else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n                     {\n-                        find_sol[index] = 0;\n                         break;\n                     }\n                     else\n                     {\n-                        find_sol[index] = 1;     \n+                        find_sol[index] = 1;\n                         // break;\n                     }\n                 }\n+                if(find_sol[index] == 1)\n+                {\n+                    break;\n+                }\n             }\n-            if(find_sol[index] == 1)\n-            {\n-                break;\n-            }\n         }\n     }\n }\n \n@@ -1426,12 +1422,8 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_sampling_num; i++)\n-        // {\n-        //     cout<<\"found_goal_list[\"<<i<<\"] : \"<<found_goal_list[i]<<endl;\n-        // }        \n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n@@ -1516,103 +1508,62 @@\n                 found_goal = 1;\n                 // cout<<\"??\"<<endl;\n                 // _return_cost[i] = _return_cost[i];\n             }\n-            // _time_window - _dt2_window\n             // else\n             // {\n             //     _return_cost[i] = _return_cost[i] + 100.0;\n             // }\n         }\n-        if(found_goal == 1)\n+\n+        _min_cost = 1000000000000000.0;\n+        weight_sum = 0.0;\n+\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n-            _min_cost = 1000000000000000.0;\n-            weight_sum = 0.0;\n-            for(int i = 0; i<_sampling_num; i++)\n+            _cost[i] = _return_cost[i];\n+            if(_min_cost > _cost[i])\n             {\n-                if(found_goal_list[i] == 1)\n-                {\n-                    if(_min_cost > _cost[i])\n-                    {\n-                        _min_cost = _cost[i];\n-                        _min_sol = i;\n-                    }\n-                }\n+                _min_cost = _cost[i];\n             }\n-            for(int i = 0; i<_JDOF; i++)\n+        }\n+        memset(_weighted_A, 0, _JDOF * sizeof(double));\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _cost[i] - _min_cost;\n+            if(_cost[i]<100)\n             {\n-                // d[i] = d[i-1] + d[i]; // 속도\n-                // e[i]    // 위치\n-                // returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n-                // returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n-                // returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n-                for(int j = 0; j<5; j++)\n+                _cost[i] = exp(-_cost[i]);\t\t\n+                weight_sum = weight_sum + _cost[i];\n+                for(int j = 0; j<_JDOF; j++)\n                 {\n-                    returnArray[i*5+j+1] = e[_min_sol*_time_window*_JDOF+j+i*_time_window]; // 위치\n-                    returnArray[35+i*5+j+1] = d[_min_sol*_time_window*_JDOF+j+i*_time_window]; //속도\n+                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n                 }\n-                // returnArray[]\n-                _q_des[i] = e[_min_sol*_time_window*_JDOF+4+i*_time_window];\n-                _qdot_des[i] = d[_min_sol*_time_window*_JDOF+4+i*_time_window];\n-                // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n             }\n-            // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n-            // cout<<\"_min_sol : \"<<_min_sol<<endl;\n-            returnArray[0] = 1;\n         }\n-        else\n+        for(int j = 0; j<_JDOF; j++)\n         {\n-            _min_cost = 1000000000000000.0;\n-            weight_sum = 0.0;\n+            _weighted_A[j] /=  weight_sum;\n+            _A[j] = _weighted_A[j];\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n+        }\n+        \n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n+            returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n+            returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n \n-            for(int i = 0; i<_sampling_num; i++)\n-            {\n-                _cost[i] = _return_cost[i];\n-                if(_min_cost > _cost[i])\n-                {\n-                    _min_cost = _cost[i];\n-                }\n-            }\n-            memset(_weighted_A, 0, _JDOF * sizeof(double));\n-\n-            for(int i = 0; i<_sampling_num; i++)\n-            {\n-                _cost[i] = _cost[i] - _min_cost;\n-                if(_cost[i]<100)\n-                {\n-                    _cost[i] = exp(-_cost[i]);\t\t\n-                    weight_sum = weight_sum + _cost[i];\n-                    for(int j = 0; j<_JDOF; j++)\n-                    {\n-                        _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n-                    }\n-                }\n-            }\n-            for(int j = 0; j<_JDOF; j++)\n-            {\n-                _weighted_A[j] /=  weight_sum;\n-                _A[j] = _weighted_A[j];\n-                // if(_A[j] > 10.0)\n-                // {\n-                //     _A[j] = 10.0;\n-                // }\n-                // else if(_A[j] < -10.0)\n-                // {\n-                //     _A[j] = -10.0;\n-                // }\n-            }\n-            \n-            for(int i = 0; i<_JDOF; i++)\n-            {\n-                returnArray[(_JDOF*2)+i+1] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n-                returnArray[_JDOF+i+1] = _qdot_des[i] + (returnArray[(_JDOF*2)+i+1] * _dt_cuda);\n-                returnArray[i+1] = _q_des[i] + (returnArray[_JDOF+i+1] * _dt_cuda);\n-\n-                _q_des[i] = returnArray[i+1];\n-                _qdot_des[i] = returnArray[_JDOF+i+1];\n-                // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n-            }\n-            returnArray[0] = 0;\n+            _q_des[i] = returnArray[i];\n+            _qdot_des[i] = returnArray[_JDOF+i];\n         }\n     }\n }\n \n"
                },
                {
                    "date": 1689747531169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1085,9 +1085,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 0.03)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 0.2)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689747552004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1085,9 +1085,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 0.2)\n+            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689747654661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689749839321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1149,9 +1149,9 @@\n     }\n     found_goal = 0;\n     if(_dt_cuda2[0] != 0.7)\n     {\n-        cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }    \n \n     for(int i = 0; i<_JDOF; i++)\n     {\n"
                },
                {
                    "date": 1689755188427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,16 +426,16 @@\n         if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n         {\n             cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n         }\n-        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n+        if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }\n+        else\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }        \n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1689755228795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689834697245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1158,8 +1158,9 @@\n         if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n         {            \n             _q_des[i] = _init_pos[i];\n             _qdot_des[i] = _init_vel[i];\n+            _A[i] = 0.0;\n         }\n     }\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n"
                },
                {
                    "date": 1689836029976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1908,12 +1908,12 @@\n \n \n     for(int i = 0; i<_JDOF; i++)\n     {\n-        _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n     }\n \n     FK_a[0] = 0.0;\n"
                },
                {
                    "date": 1689836114825,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689836233091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n     }    \n \n     for(int i = 0; i<_JDOF; i++)\n     {\n-        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.05)\n         {            \n             _q_des[i] = _init_pos[i];\n             _qdot_des[i] = _init_vel[i];\n             _A[i] = 0.0;\n"
                },
                {
                    "date": 1689836361803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1150,19 +1150,31 @@\n     found_goal = 0;\n     if(_dt_cuda2[0] != 0.7)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    }    \n+    }\n \n+    reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n         if( abs(_q_des[i]-_init_pos[i]) >= 0.05)\n         {            \n-            _q_des[i] = _init_pos[i];\n-            _qdot_des[i] = _init_vel[i];\n-            _A[i] = 0.0;\n+            reset_check = 1;\n+            break;\n         }\n     }\n+    if(reset_check == 1)\n+    {\n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            if( abs(_q_des[i]-_init_pos[i]) >= 0.05)\n+            {            \n+                _q_des[i] = _init_pos[i];\n+                _qdot_des[i] = _init_vel[i];\n+                _A[i] = 0.0;\n+            }\n+        }\n+    }\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n     dim3 blockDim(N/_time_window, 1, 1);\n     dim3 gridDim(_time_window, 1, 1);\n"
                },
                {
                    "date": 1689836369865,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1164,15 +1164,12 @@\n     }\n     if(reset_check == 1)\n     {\n         for(int i = 0; i<_JDOF; i++)\n-        {\n-            if( abs(_q_des[i]-_init_pos[i]) >= 0.05)\n-            {            \n-                _q_des[i] = _init_pos[i];\n-                _qdot_des[i] = _init_vel[i];\n-                _A[i] = 0.0;\n-            }\n+        {        \n+            _q_des[i] = _init_pos[i];\n+            _qdot_des[i] = _init_vel[i];\n+            _A[i] = 0.0;\n         }\n     }\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n"
                },
                {
                    "date": 1689836861858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 10000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689837301461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 10000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689837441480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 450.0;//pow(10,6)\n     if(now_gap[0] > 1 )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1689838787118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -504,8 +504,17 @@\n     double weight1 = 30000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n+    if(now_gap[0] > 1 )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(1-now_gap[0]) * vel_gain;\n+    }\n+\n     if(index < _sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n"
                },
                {
                    "date": 1689838800350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -506,13 +506,13 @@\n     // double weight_manipul = 100.0;\n \n     if(now_gap[0] > 1 )\n     {\n-        vel_gain =  0.0;\n+        weight1 =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(1-now_gap[0]) * vel_gain;\n+        weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n     }\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689838874365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -510,9 +510,9 @@\n         weight1 =  0.0;\n     }\n     else\n     {\n-        weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n+        weight1 =  abs_cuda1(1-now_gap[0]) + weight1;\n     }\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689838902832,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -510,9 +510,9 @@\n         weight1 =  0.0;\n     }\n     else\n     {\n-        weight1 =  abs_cuda1(1-now_gap[0]) + weight1;\n+        weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n     }\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689838925917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(now_gap[0] > 1 )\n"
                },
                {
                    "date": 1689839036081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(now_gap[0] > 1 )\n"
                },
                {
                    "date": 1689839415989,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(now_gap[0] > 1 )\n"
                },
                {
                    "date": 1689840330198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > 1 )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1689840427240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -500,9 +500,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(now_gap[0] > 1 )\n"
                },
                {
                    "date": 1689840526881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1164,9 +1164,9 @@\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n-        if( abs(_q_des[i]-_init_pos[i]) >= 0.05)\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n         {            \n             reset_check = 1;\n             break;\n         }\n"
                },
                {
                    "date": 1689840763089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -432,9 +432,10 @@\n             cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689841065973,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -505,17 +505,8 @@\n     double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n-    if(now_gap[0] > 1 )\n-    {\n-        weight1 =  0.0;\n-    }\n-    else\n-    {\n-        weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n-    }\n-\n     if(index < _sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n@@ -560,8 +551,18 @@\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n             cost2_2 = cost2_2 + pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n+\n+        if(now_gap[0] > 1 )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n+        }\n+\n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n         // }\n"
                },
                {
                    "date": 1689841084256,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,8 +526,9 @@\n \n         // double RotGoalT_x_PosEE[3];\n         // double RotGoalT_x_PosGoal[3];\n         double PosGap[3];\n+        double PosGap_2 = 0.0;\n \n         matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n@@ -549,9 +550,9 @@\n             // else\n             // {\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n-            cost2_2 = cost2_2 + pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n         if(now_gap[0] > 1 )\n         {\n"
                },
                {
                    "date": 1689841103398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,8 +541,9 @@\n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n             cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n+            PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n             //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n@@ -553,15 +554,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(now_gap[0] > 1 )\n+        if(PosGap_2 > 1 )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(1-now_gap[0]) * weight1;\n+            weight1 =  abs_cuda1(1-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689841785240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -428,14 +428,14 @@\n             cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n         }\n         if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689841908448,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -428,14 +428,14 @@\n             cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n         }\n         if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689841990535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -554,15 +554,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > 1 )\n+        if(PosGap_2 > 0.5 )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(1-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(0.5-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689842039119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,15 +364,15 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 300.0;//pow(10,6)\n-    if(now_gap[0] > 1 )\n+    if(now_gap[0] > 0.5 )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(1-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(0.5-now_gap[0]) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689842058655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,15 +364,15 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 300.0;//pow(10,6)\n-    if(now_gap[0] > 0.5 )\n+    if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(0.5-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689842073233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -554,15 +554,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > 0.5 )\n+        if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(0.5-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689842206941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,16 +426,26 @@\n         if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n         {\n             cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n         }\n-        if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n+        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }  \n+\n+        if(joint_num < 5)\n         {\n             cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689842257527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -438,14 +438,14 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(cen_joint_position[joint_num] , position[index]);\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(cen_joint_position[joint_num] , position[index]);\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689842284217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -438,14 +438,14 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(cen_joint_position[joint_num] , position[index]);\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(cen_joint_position[joint_num] , position[index]);\n+            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689842369062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -443,9 +443,9 @@\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689901530811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,9 +511,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689901572907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -520,9 +520,9 @@\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n-            rotation_EE_index[i] = rotation_EE[index*9+i];    \n+            rotation_EE_index[i] = rotation_EE[index*9+i];  \n         }\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n@@ -546,8 +546,9 @@\n         double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n+        RotGap[2] = RotGap[2] * 2.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n"
                },
                {
                    "date": 1689901923038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1146,8 +1146,13 @@\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n+    for(int i = 0; i<6; i++)\n+    {\n+        now_pos_gap[1] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n+        // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+    }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n"
                },
                {
                    "date": 1689901928506,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1148,9 +1148,9 @@\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n     for(int i = 0; i<6; i++)\n     {\n-        now_pos_gap[1] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n+        now_pos_gap[1] = now_pos_gap[1] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n"
                },
                {
                    "date": 1689901977361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1461,9 +1461,9 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n"
                },
                {
                    "date": 1689902015155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1461,18 +1461,18 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);        \n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);    \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n \n \n \n-\n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap[0], sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1689902065763,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1461,18 +1461,18 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);    \n+        cudaMemcpy(dev_now_pos_gap, &now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);    \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n \n \n \n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap[0], sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_now_pos_gap, &now_pos_gap[0], sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1689902118216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 450.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1689902153793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,15 +364,15 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n+    if(now_gap[0] > gap_limit*2 )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit*2-now_gap[0]) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689902169677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1461,18 +1461,13 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, &now_pos_gap[1], sizeof(double), cudaMemcpyHostToDevice);    \n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);    \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n-\n-\n-\n-\n-        cudaMemcpy(dev_now_pos_gap, &now_pos_gap[0], sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1689902174911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1789,9 +1789,9 @@\n     cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n+    cudaMalloc((void**)&dev_now_pos_gap, 2 * sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     \n"
                },
                {
                    "date": 1689902222644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,15 +364,15 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit*2 )\n+    if(now_gap[1] > gap_limit*2 )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit*2-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit*2-now_gap[1]) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689902312295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,8 +364,9 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;//pow(10,6)\n+    printf(\"now_gap[1] : %f\\n\",now_gap[1])\n     if(now_gap[1] > gap_limit*2 )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1689902347765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,13 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;//pow(10,6)\n-    printf(\"now_gap[1] : %f\\n\",now_gap[1])\n+    if(index == 0)\n+    {\n+        printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n+    }\n+    \n     if(now_gap[1] > gap_limit*2 )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1689902381932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1146,8 +1146,9 @@\n { \n     // _dt_cuda2[0] = 0.5;\n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n+    now_pos_gap[1] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n"
                },
                {
                    "date": 1689902422032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,15 +369,15 @@\n     {\n         printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     }\n     \n-    if(now_gap[1] > gap_limit*2 )\n+    if(now_gap[1] > gap_limit*4 )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit*2-now_gap[1]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit*4-now_gap[1]) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689902562315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1152,12 +1152,12 @@\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n-    for(int i = 0; i<6; i++)\n+    for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[1] = now_pos_gap[1] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n-        // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+        now_pos_gap[1] = now_pos_gap[1] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]);\n     }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n"
                },
                {
                    "date": 1689902681885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,20 +364,28 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;//pow(10,6)\n-    if(index == 0)\n-    {\n-        printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n-    }\n+    // if(index == 0)\n+    // {\n+    //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n+    // }\n     \n-    if(now_gap[1] > gap_limit*4 )\n+    if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit*4-now_gap[1]) * vel_gain;\n+        if(now_gap[1]>gap_limit)\n+        {\n+            vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain / 3.0;\n+        }\n+        else\n+        {\n+            vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        }\n+        \n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689902781432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,10 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;//pow(10,6)\n+    double vel_gain1 = 450.0;//pow(10,6)\n+    double vel_gain2 = 450.0;//pow(10,6)\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -375,18 +376,20 @@\n         vel_gain =  0.0;\n     }\n     else\n     {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n         if(now_gap[1]>gap_limit)\n         {\n-            vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain / 3.0;\n+            vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n         }\n         else\n         {\n-            vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+            vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n         }\n-        \n+\n     }\n+\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1689902787034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -372,13 +372,13 @@\n     // }\n     \n     if(now_gap[0] > gap_limit )\n     {\n-        vel_gain =  0.0;\n+        vel_gain1 =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain1 =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain1;\n         if(now_gap[1]>gap_limit)\n         {\n             vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n         }\n"
                },
                {
                    "date": 1689902793797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain1 = 450.0;//pow(10,6)\n+    double vel_gain1 = 250.0;//pow(10,6)\n     double vel_gain2 = 450.0;//pow(10,6)\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n"
                },
                {
                    "date": 1689902888255,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain1 = 250.0;//pow(10,6)\n-    double vel_gain2 = 450.0;//pow(10,6)\n+    double vel_gain450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -374,20 +373,22 @@\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain1 =  0.0;\n     }\n+    else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    {\n+        vel_gain1 =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain1;\n+    }\n     else\n     {\n-        vel_gain1 =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain1;\n         if(now_gap[1]>gap_limit)\n         {\n             vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n         }\n         else\n         {\n             vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n         }\n-\n     }\n \n     \n \n"
                },
                {
                    "date": 1689902895546,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,21 +363,21 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain450.0;\n+    double vel_gain = 450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n     if(now_gap[0] > gap_limit )\n     {\n-        vel_gain1 =  0.0;\n+        vel_gain =  0.0;\n     }\n     else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n     {\n-        vel_gain1 =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain1;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n     else\n     {\n         if(now_gap[1]>gap_limit)\n"
                },
                {
                    "date": 1689902918232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -381,9 +381,9 @@\n     else\n     {\n         if(now_gap[1]>gap_limit)\n         {\n-            vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n+            vel_gain =  vel_gain / 2.0;\n         }\n         else\n         {\n             vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n"
                },
                {
                    "date": 1689902968377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1166,9 +1166,9 @@\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n     for(int i = 0; i<3; i++)\n     {\n-        now_pos_gap[1] = now_pos_gap[1] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n+        // now_pos_gap[1] = now_pos_gap[1] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         now_pos_gap[1] = now_pos_gap[1] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]);\n     }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n"
                },
                {
                    "date": 1689903035836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;\n+    double vel_gain = 200.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -373,22 +373,24 @@\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n-    else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n+    else\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n+\n+    if(now_gap[1]>gap_limit)\n+    {\n+        vel_gain =  vel_gain / 2.0;\n+    }\n     else\n     {\n-        if(now_gap[1]>gap_limit)\n-        {\n-            vel_gain =  vel_gain / 2.0;\n-        }\n-        else\n-        {\n-            vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n-        }\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n     }\n \n     \n \n"
                },
                {
                    "date": 1689903067077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,16 +382,12 @@\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n \n-    if(now_gap[1]>gap_limit)\n+    if(now_gap[1]<gap_limit)\n     {\n-        vel_gain =  vel_gain / 2.0;\n+        vel_gain =  vel_gain * 2.0;\n     }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n-    }\n \n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689903094289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 200.0;\n+    double vel_gain = 150.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689903176162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 150.0;\n+    double vel_gain = 100.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -384,9 +384,9 @@\n     }\n \n     if(now_gap[1]<gap_limit)\n     {\n-        vel_gain =  vel_gain * 2.0;\n+        vel_gain =  vel_gain * 5.0;\n     }\n \n     \n \n"
                },
                {
                    "date": 1689903198314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,12 +382,12 @@\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n \n-    if(now_gap[1]<gap_limit)\n-    {\n-        vel_gain =  vel_gain * 5.0;\n-    }\n+    // if(now_gap[1]<gap_limit)\n+    // {\n+    //     vel_gain =  vel_gain * 5.0;\n+    // }\n \n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689903248718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 100.0;\n+    double vel_gain = 450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -453,9 +453,9 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1689903279282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;\n+    double vel_gain = 300.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689903451750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,12 +382,12 @@\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n \n-    // if(now_gap[1]<gap_limit)\n-    // {\n-    //     vel_gain =  vel_gain * 5.0;\n-    // }\n+    if(now_gap[1]<gap_limit)\n+    {\n+        vel_gain =  vel_gain * 5.0;\n+    }\n \n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689903458381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;\n+    double vel_gain = 200.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -384,9 +384,9 @@\n     }\n \n     if(now_gap[1]<gap_limit)\n     {\n-        vel_gain =  vel_gain * 5.0;\n+        vel_gain =  vel_gain * 3.0;\n     }\n \n     \n \n"
                },
                {
                    "date": 1689903489816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -561,9 +561,9 @@\n         double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n-        RotGap[2] = RotGap[2] * 2.0;\n+        // RotGap[2] = RotGap[2] * 2.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n"
                },
                {
                    "date": 1689903634201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n+            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689903764049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]);\n+            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689904011084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,16 +580,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -610,15 +610,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 +  abs_cuda1(position_sec1[0]-PosGap_2) * weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689904045879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,16 +580,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -610,15 +610,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 +  abs_cuda1(position_sec1[0]-PosGap_2) * weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689904718104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,12 +382,12 @@\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n \n-    if(now_gap[1]<gap_limit)\n-    {\n-        vel_gain =  vel_gain * 3.0;\n-    }\n+    // if(now_gap[1]<gap_limit)\n+    // {\n+    //     vel_gain =  vel_gain * 3.0;\n+    // }\n \n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1689904962494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 200.0;\n+    double vel_gain = 450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689905095361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1477,10 +1477,10 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);    \n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);\n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap, dev_position_EE, dev_x_goal);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n"
                },
                {
                    "date": 1689905126754,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,9 +354,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *x_pos, double *x_goal;)\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n"
                },
                {
                    "date": 1689905146786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,9 +354,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *x_pos, double *x_goal;)\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *x_pos, double *x_goal)\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n@@ -364,8 +364,13 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;\n+    double PosEE_index[3];\n+    for(int i = 0; i<3; i++)\n+    {\n+        PosEE_index[i] = position[index*3+i];    \n+    }\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689905180607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,9 +354,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *x_pos, double *x_goal)\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n@@ -364,13 +364,8 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 450.0;\n-    double PosEE_index[3];\n-    for(int i = 0; i<3; i++)\n-    {\n-        PosEE_index[i] = position[index*3+i];    \n-    }\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -531,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 40000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -1482,10 +1477,10 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);\n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap, dev_position_EE, dev_x_goal);\n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);    \n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n"
                },
                {
                    "date": 1689905434854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 40000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689905633650,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,16 +580,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1689905640698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,9 +610,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n"
                },
                {
                    "date": 1689905650977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -622,9 +622,9 @@\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1689905701761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,15 +610,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*2 + weight2 * cost2_2;// + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689905727249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,15 +610,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*2 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689905771927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,15 +610,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1;// * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 + weight1;// * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689905817948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,21 +610,21 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1;// * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1;// * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n-            cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1689905835539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -580,16 +580,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1689905900864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n+            cost1_2 = cost1_2 + abs(RotGap[i]); // pow2_cuda(RotGap[i]) +\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689905927901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs(RotGap[i]); // pow2_cuda(RotGap[i]) +\n+            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689906046640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -423,16 +423,16 @@\n \n     // }\n     // else\n     // {\n-        if(position[index] < min_joint_limit[joint_num])\n+        if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n-        else if(position[index] > max_joint_limit[joint_num])\n+        else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689906201118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,14 +425,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689906208834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] > gap_limit )\n+    if(now_gap[0] >= gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n"
                },
                {
                    "date": 1689906220241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n+            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]);// + abs(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689906284811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -583,8 +583,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n+            weight2 = weight2 * 2.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1689906290329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -527,9 +527,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 50000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 200000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689906336419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -527,9 +527,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 50000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 200000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689906362745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -583,13 +583,13 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            weight2 = weight2 * 2.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight2 =  abs_cuda1(gap_limit-PosGap_2) * weight2;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689906374748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  abs_cuda1(gap_limit-PosGap_2) * weight2;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689906392400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2.0;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689906414420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2.0;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689906433058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]);// + abs(RotGap[i]);\n+            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1689906516677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689906721381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;\n+    double vel_gain = 300.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689907044295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;\n+    double vel_gain = 500.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689907157236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] >= gap_limit )\n+    if(now_gap[0] >= gap_limit/2)\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n@@ -379,9 +379,9 @@\n     //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     // }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689907236018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -368,21 +368,30 @@\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n-    \n-    if(now_gap[0] >= gap_limit/2)\n+\n+    if(now_gap[0] <= gap_limit/2)\n     {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n+    else\n+    {\n         vel_gain =  0.0;\n     }\n-    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    \n+    // if(now_gap[0] >= gap_limit/2)\n     // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    //     vel_gain =  0.0;\n     // }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n-    }\n+    // // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // // {\n+    // //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n+    // }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n     //     vel_gain =  vel_gain * 3.0;\n"
                },
                {
                    "date": 1689907244055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n \n-    if(now_gap[0] <= gap_limit/2)\n+    if(now_gap[1] <= gap_limit/2)\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n     else\n"
                },
                {
                    "date": 1689907499329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,11 +369,11 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n \n-    if(now_gap[1] <= gap_limit/2)\n+    if(now_gap[1] <= gap_limit)\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n     }\n     else\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1689911160207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -589,9 +589,9 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(PosGap_2 > gap_limit)\n         {\n             weight1 =  0.0;\n         }\n         else\n"
                },
                {
                    "date": 1689911183363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -567,8 +567,9 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n+        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n         // RotGap[2] = RotGap[2] * 2.0;\n"
                },
                {
                    "date": 1689911197815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -592,8 +592,9 @@\n         }\n \n         if(PosGap_2 > gap_limit)\n         {\n+            cost3 = weight1;\n             weight1 =  0.0;\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689911203392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -643,9 +643,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689911211613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -597,8 +597,9 @@\n             weight1 =  0.0;\n         }\n         else\n         {\n+            cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n             weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n"
                },
                {
                    "date": 1689911327927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -601,8 +601,9 @@\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n             weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n+         cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -621,31 +622,31 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(cost2_2 >  position_sec1[0])\n-        {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n-        {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        else\n-        {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n-            // cost2 = (1-_manipulability[index]);\n-        }\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        if(sqrt(_manipulability[index])<= 0.1)\n-        {\n-            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n-        }\n+        // if(cost2_2 >  position_sec1[0])\n+        // {\n+        //     cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        // else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        // {\n+        //     cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        // else\n+        // {\n+        //     cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+        //     // cost2 = (1-_manipulability[index]);\n+        // }\n+        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // if(sqrt(_manipulability[index])<= 0.1)\n+        // {\n+        //     cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        // }\n         f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n"
                },
                {
                    "date": 1689911364590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -643,11 +643,11 @@\n         // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // if(sqrt(_manipulability[index])<= 0.1)\n         // {\n-        //     cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+            // cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         // }\n-        f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689911405831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -599,9 +599,9 @@\n         else\n         {\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n         }\n          cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1689911442811,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -535,10 +535,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 20000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 100000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689911483836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -535,10 +535,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 20000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 100000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 200000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689911514613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -599,9 +599,9 @@\n         else\n         {\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n+            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n         }\n          cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1689911563428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -535,10 +535,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 200000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 300000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 1000000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1689911608348,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -535,10 +535,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 300000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 1000000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -599,11 +599,10 @@\n         else\n         {\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n-         cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -622,32 +621,32 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        // if(cost2_2 >  position_sec1[0])\n-        // {\n-        //     cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        // else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n-        // {\n-        //     cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        // else\n-        // {\n-        //     cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n-        //     // cost2 = (1-_manipulability[index]);\n-        // }\n-        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // if(sqrt(_manipulability[index])<= 0.1)\n-        // {\n-            // cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n-        // }\n-        f[index] = cost1 + cost3;\n+        if(cost2_2 >  position_sec1[0])\n+        {\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        {\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        else\n+        {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            // cost2 = (1-_manipulability[index]);\n+        }\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        if(sqrt(_manipulability[index])<= 0.1)\n+        {\n+            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        }\n+        f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689911659064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -621,32 +621,32 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(cost2_2 >  position_sec1[0])\n-        {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n-        {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        else\n-        {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n-            // cost2 = (1-_manipulability[index]);\n-        }\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        if(sqrt(_manipulability[index])<= 0.1)\n-        {\n-            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n-        }\n-        f[index] = cost1 + cost2 + cost3;\n+        // if(cost2_2 >  position_sec1[0])\n+        // {\n+        //     cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        // else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        // {\n+        //     cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        // else\n+        // {\n+        //     cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+        //     // cost2 = (1-_manipulability[index]);\n+        // }\n+        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // if(sqrt(_manipulability[index])<= 0.1)\n+        // {\n+        //     cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        // }\n+        // f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689911668944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -602,8 +602,10 @@\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n             weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n+                // f[index] = cost1 + cost2 + cost3;\n+\n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n         // }\n"
                },
                {
                    "date": 1689911676104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -599,12 +599,12 @@\n         else\n         {\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n-                // f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost2 + cost3;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1689911706369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -601,9 +601,10 @@\n             cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n             // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n-\n+        cost1 = weight1 * cost1_2;\n+        cost2 = weight2 * cost2_2;\n         f[index] = cost1 + cost2 + cost3;\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689911739897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -592,9 +592,9 @@\n         }\n \n         if(PosGap_2 > gap_limit)\n         {\n-            cost3 = weight1;\n+            cost3 = weight2;\n             weight1 =  0.0;\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689911766132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -592,9 +592,9 @@\n         }\n \n         if(PosGap_2 > gap_limit)\n         {\n-            cost3 = weight2;\n+            cost3 = weight1;\n             weight1 =  0.0;\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689911774281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;\n+    double vel_gain = 0.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689911805189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 0.0;\n+    double vel_gain = 100.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689911847198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 100.0;\n+    double vel_gain = 500.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689911918100,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -590,22 +590,22 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit)\n-        {\n-            cost3 = weight1;\n-            weight1 =  0.0;\n-        }\n-        else\n-        {\n-            cost3 = 0.0;\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // if(PosGap_2 > gap_limit)\n+        // {\n+        //     cost3 = weight1;\n+        //     weight1 =  0.0;\n+        // }\n+        // else\n+        // {\n+        //     cost3 = 0.0;\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        //     // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n         cost1 = weight1 * cost1_2;\n         cost2 = weight2 * cost2_2;\n-        f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost2;// + cost3;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1689911992798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,35 +363,26 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;\n+    double vel_gain = 450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n-\n-    if(now_gap[1] <= gap_limit)\n+    \n+    if(now_gap[0] >= gap_limit )\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n+        vel_gain =  0.0;\n     }\n+    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     else\n     {\n-        vel_gain =  0.0;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n-    \n-    // if(now_gap[0] >= gap_limit/2)\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n-    // // {\n-    // //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n-    // }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n     //     vel_gain =  vel_gain * 3.0;\n@@ -567,9 +558,8 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n         // RotGap[2] = RotGap[2] * 2.0;\n@@ -590,22 +580,17 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit)\n-        // {\n-        //     cost3 = weight1;\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     cost3 = 0.0;\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        //     // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n-        cost1 = weight1 * cost1_2;\n-        cost2 = weight2 * cost2_2;\n-        f[index] = cost1 + cost2;// + cost3;\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -624,32 +609,32 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        // if(cost2_2 >  position_sec1[0])\n-        // {\n-        //     cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        // else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n-        // {\n-        //     cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        // else\n-        // {\n-        //     cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n-        //     // cost2 = (1-_manipulability[index]);\n-        // }\n-        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // if(sqrt(_manipulability[index])<= 0.1)\n-        // {\n-        //     cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n-        // }\n-        // f[index] = cost1 + cost2 + cost3;\n+        if(cost2_2 >  position_sec1[0])\n+        {\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        {\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        else\n+        {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            // cost2 = (1-_manipulability[index]);\n+        }\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        if(sqrt(_manipulability[index])<= 0.1)\n+        {\n+            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        }\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689912212279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] >= gap_limit )\n+    if(now_gap[0] >= gap_limit)\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n@@ -1581,9 +1581,9 @@\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n-            if(_cost[i]<100)\n+            if(_cost[i]<10)\n             {\n                 _cost[i] = exp(-_cost[i]);\t\t\n                 weight_sum = weight_sum + _cost[i];\n                 for(int j = 0; j<_JDOF; j++)\n"
                },
                {
                    "date": 1689912279058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1581,9 +1581,9 @@\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n-            if(_cost[i]<10)\n+            if(_cost[i]<700)\n             {\n                 _cost[i] = exp(-_cost[i]);\t\t\n                 weight_sum = weight_sum + _cost[i];\n                 for(int j = 0; j<_JDOF; j++)\n"
                },
                {
                    "date": 1689916531953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1581,9 +1581,9 @@\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n-            if(_cost[i]<700)\n+            if(_cost[i]<100)\n             {\n                 _cost[i] = exp(-_cost[i]);\t\t\n                 weight_sum = weight_sum + _cost[i];\n                 for(int j = 0; j<_JDOF; j++)\n"
                },
                {
                    "date": 1689916550066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1527,9 +1527,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.95,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1538,9 +1538,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.95,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1689916630581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689916914356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689917102408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1527,9 +1527,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.95,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1538,9 +1538,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.95,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1689917200819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -611,15 +611,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*2 + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689917371074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1882,15 +1882,15 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n-    position_sec1[0] = 0.03125;\n-    position_sec2[0] = 0.005;\n-    velocity_lim[0] = 0.8;\n+    // position_sec1[0] = 0.03125;\n+    // position_sec2[0] = 0.005;\n+    // velocity_lim[0] = 0.8;\n \n-    // position_sec1[0] = 0.03125;\n-    // position_sec2[0] = 0.00625;\n-    // velocity_lim[0] = 1.0;\n+    position_sec1[0] = 0.1125;\n+    position_sec2[0] = 0.0125;\n+    velocity_lim[0] = 1.0;\n \t\n     // numBlocks = N / THREADS_PER_BLOCK;\n     // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n \n"
                },
                {
                    "date": 1689917458126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1177,25 +1177,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.7;\n+            _dt_cuda2[0] = 0.5;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 0.5;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n+    if(_dt_cuda2[0] != 0.5)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689917634216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1172,34 +1172,34 @@\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n-    if(found_goal == 1)\n-    {\n-        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-        {\n-            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n-        }\n-        else if(now_pos_gap[0] <= position_sec2[0])\n-        {\n-            _dt_cuda2[0] = _dt_cuda;\n-        }\n-        else if(now_pos_gap[0] >= 1.0)\n-        {\n-            _dt_cuda2[0] = 0.5;\n-        }\n-    }\n-    else\n-    {\n-        _dt_cuda2[0] = 0.5;\n-    }\n-    found_goal = 0;\n-    if(_dt_cuda2[0] != 0.5)\n-    {\n-        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    }\n-\n+    // if(found_goal == 1)\n+    // {\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.5;\n+    //     }\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = 0.5;\n+    // }\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.5)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n+_dt_cuda2[0] = 0.5;\n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n         if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n"
                },
                {
                    "date": 1689917664209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1172,34 +1172,34 @@\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n-    // if(found_goal == 1)\n-    // {\n-    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-    //     {\n-    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-    //         _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n-    //     }\n-    //     else if(now_pos_gap[0] <= position_sec2[0])\n-    //     {\n-    //         _dt_cuda2[0] = _dt_cuda;\n-    //     }\n-    //     else if(now_pos_gap[0] >= 1.0)\n-    //     {\n-    //         _dt_cuda2[0] = 0.5;\n-    //     }\n-    // }\n-    // else\n-    // {\n-    //     _dt_cuda2[0] = 0.5;\n-    // }\n-    // found_goal = 0;\n-    // if(_dt_cuda2[0] != 0.5)\n-    // {\n-    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    // }\n-_dt_cuda2[0] = 0.5;\n+    if(found_goal == 1)\n+    {\n+        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+        {\n+            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+        }\n+        else if(now_pos_gap[0] <= position_sec2[0])\n+        {\n+            _dt_cuda2[0] = _dt_cuda;\n+        }\n+        else if(now_pos_gap[0] >= 1.0)\n+        {\n+            _dt_cuda2[0] = 0.5;\n+        }\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = 0.5;\n+    }\n+    found_goal = 0;\n+    if(_dt_cuda2[0] != 0.5)\n+    {\n+        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    }\n+\n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n         if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n"
                },
                {
                    "date": 1689917681022,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 0.03)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689917716792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 0.03)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 0.1)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689917765874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,9 +1195,9 @@\n     }\n     found_goal = 0;\n     if(_dt_cuda2[0] != 0.5)\n     {\n-        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+        cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n"
                },
                {
                    "date": 1689917827904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1110,9 +1110,9 @@\n \n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n-                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*9+i*9+j];\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689917884891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1110,9 +1110,9 @@\n \n             double rotation_EE_index[9];\n             for(int j = 0; j<9; j++)\n             {\n-                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*9+i*9+j];\n+                rotation_EE_index[j] = rotation_mat_EE[index*_time_window*9+i*9+j];\n             }\n \n             double RotGoalT_x_RotEE[9];\n             double RotGap[3];\n"
                },
                {
                    "date": 1689918088743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 0.1)\n+            if(tmp_p <= 0.05 && tmp_p2 <= 0.05)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918111123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.05 && tmp_p2 <= 0.05)\n+            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918140608,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n+            if(tmp_p <= 0.5 && tmp_p2 <= 0.5)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918158483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.5 && tmp_p2 <= 0.5)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 0.5)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918211775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1125,9 +1125,9 @@\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 0.5)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 1.0)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918325431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1120,12 +1120,17 @@\n             matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n             rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n             double tmp_p2 = 0.0;\n-            tmp_p2 = abs_cuda1(RotGap[0]);\n-            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n-            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n+            for(int j = 0; j<9; j++)\n+            {\n+                tmp_p2[j] = RotGoalT_x_RotEE[index*_time_window*9+i*9+j];\n+            }\n \n+            // tmp_p2 = abs_cuda1(RotGap[0]);\n+            // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n+            // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n+\n             find_sol[index] = 0;\n             if(tmp_p <= 0.03 && tmp_p2 <= 1.0)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n"
                },
                {
                    "date": 1689918340405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1122,9 +1122,9 @@\n \n             double tmp_p2 = 0.0;\n             for(int j = 0; j<9; j++)\n             {\n-                tmp_p2[j] = RotGoalT_x_RotEE[index*_time_window*9+i*9+j];\n+                tmp_p2[j] += RotGoalT_x_RotEE[j];\n             }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n"
                },
                {
                    "date": 1689918346489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1122,9 +1122,9 @@\n \n             double tmp_p2 = 0.0;\n             for(int j = 0; j<9; j++)\n             {\n-                tmp_p2[j] += RotGoalT_x_RotEE[j];\n+                tmp_p2 += RotGoalT_x_RotEE[j];\n             }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n"
                },
                {
                    "date": 1689918391835,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1122,9 +1122,9 @@\n \n             double tmp_p2 = 0.0;\n             for(int j = 0; j<9; j++)\n             {\n-                tmp_p2 += RotGoalT_x_RotEE[j];\n+                tmp_p2 += abs_cuda1(RotGoalT_x_RotEE[j]);\n             }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n"
                },
                {
                    "date": 1689918445888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1124,8 +1124,9 @@\n             for(int j = 0; j<9; j++)\n             {\n                 tmp_p2 += abs_cuda1(RotGoalT_x_RotEE[j]);\n             }\n+            tmp_p2 -= 3.0;\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n"
                },
                {
                    "date": 1689918467760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1120,13 +1120,12 @@\n             matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n             rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n             double tmp_p2 = 0.0;\n-            for(int j = 0; j<9; j++)\n+            for(int j = 0; j<3; j++)\n             {\n                 tmp_p2 += abs_cuda1(RotGoalT_x_RotEE[j]);\n             }\n-            tmp_p2 -= 3.0;\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n"
                },
                {
                    "date": 1689918518460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1122,17 +1122,17 @@\n \n             double tmp_p2 = 0.0;\n             for(int j = 0; j<3; j++)\n             {\n-                tmp_p2 += abs_cuda1(RotGoalT_x_RotEE[j]);\n+                tmp_p2 += abs_cuda1(RotGap[j]);\n             }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 1.0)\n+            if(tmp_p <= 0.03 && tmp_p2 <= 1.5)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918568984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1124,8 +1124,12 @@\n             for(int j = 0; j<3; j++)\n             {\n                 tmp_p2 += abs_cuda1(RotGap[j]);\n             }\n+            if(index == 0)\n+            {\n+                printf(\"tmp_p2 : %f \\n\",tmp_p2);\n+            }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n"
                },
                {
                    "date": 1689918643433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1126,9 +1126,15 @@\n                 tmp_p2 += abs_cuda1(RotGap[j]);\n             }\n             if(index == 0)\n             {\n-                printf(\"tmp_p2 : %f \\n\",tmp_p2);\n+                if(i == 0)\n+                {\n+                    printf(\"tmp_p2 : %f \\n\",tmp_p2);\n+                    printf(\"Roll error : %f \\n\",RotGap[0]);\n+                    printf(\"Pitch error : %f \\n\",RotGap[1]);\n+                    printf(\"Yaw error : %f \\n\",RotGap[2]);\n+                }                \n             }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n"
                },
                {
                    "date": 1689918703489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1124,18 +1124,18 @@\n             for(int j = 0; j<3; j++)\n             {\n                 tmp_p2 += abs_cuda1(RotGap[j]);\n             }\n-            if(index == 0)\n-            {\n-                if(i == 0)\n-                {\n-                    printf(\"tmp_p2 : %f \\n\",tmp_p2);\n-                    printf(\"Roll error : %f \\n\",RotGap[0]);\n-                    printf(\"Pitch error : %f \\n\",RotGap[1]);\n-                    printf(\"Yaw error : %f \\n\",RotGap[2]);\n-                }                \n-            }\n+            // if(index == 0)\n+            // {\n+            //     if(i == 0)\n+            //     {\n+            //         printf(\"tmp_p2 : %f \\n\",tmp_p2);\n+            //         printf(\"Roll error : %f \\n\",RotGap[0]);\n+            //         printf(\"Pitch error : %f \\n\",RotGap[1]);\n+            //         printf(\"Yaw error : %f \\n\",RotGap[2]);\n+            //     }                \n+            // }\n \n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n"
                },
                {
                    "date": 1689918716998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1134,9 +1134,9 @@\n             //         printf(\"Pitch error : %f \\n\",RotGap[1]);\n             //         printf(\"Yaw error : %f \\n\",RotGap[2]);\n             //     }                \n             // }\n-\n+            tmp_p2 = abs_cuda1(RotGap[2]);\n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n"
                },
                {
                    "date": 1689918760333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1134,9 +1134,9 @@\n             //         printf(\"Pitch error : %f \\n\",RotGap[1]);\n             //         printf(\"Yaw error : %f \\n\",RotGap[2]);\n             //     }                \n             // }\n-            tmp_p2 = abs_cuda1(RotGap[2]);\n+            // tmp_p2 = abs_cuda1(RotGap[2]);\n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n"
                },
                {
                    "date": 1689918768037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1107,25 +1107,25 @@\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n             tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n \n-            double rotation_EE_index[9];\n-            for(int j = 0; j<9; j++)\n-            {\n-                rotation_EE_index[j] = rotation_mat_EE[index*_time_window*9+i*9+j];\n-            }\n+            // double rotation_EE_index[9];\n+            // for(int j = 0; j<9; j++)\n+            // {\n+            //     rotation_EE_index[j] = rotation_mat_EE[index*_time_window*9+i*9+j];\n+            // }\n \n-            double RotGoalT_x_RotEE[9];\n-            double RotGap[3];\n+            // double RotGoalT_x_RotEE[9];\n+            // double RotGap[3];\n \n-            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n-            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+            // matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n+            // rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n-            double tmp_p2 = 0.0;\n-            for(int j = 0; j<3; j++)\n-            {\n-                tmp_p2 += abs_cuda1(RotGap[j]);\n-            }\n+            // double tmp_p2 = 0.0;\n+            // for(int j = 0; j<3; j++)\n+            // {\n+            //     tmp_p2 += abs_cuda1(RotGap[j]);\n+            // }\n             // if(index == 0)\n             // {\n             //     if(i == 0)\n             //     {\n"
                },
                {
                    "date": 1689918782391,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1107,8 +1107,10 @@\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n             tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n \n+\n+            /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n             // double rotation_EE_index[9];\n             // for(int j = 0; j<9; j++)\n             // {\n             //     rotation_EE_index[j] = rotation_mat_EE[index*_time_window*9+i*9+j];\n@@ -1138,8 +1140,9 @@\n             // tmp_p2 = abs_cuda1(RotGap[2]);\n             // tmp_p2 = abs_cuda1(RotGap[0]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n+            /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n \n             find_sol[index] = 0;\n             if(tmp_p <= 0.03 && tmp_p2 <= 1.5)\n             {\n"
                },
                {
                    "date": 1689918823807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1143,9 +1143,9 @@\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03 && tmp_p2 <= 1.5)\n+            if(tmp_p <= 0.05)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689918875682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1575,14 +1575,14 @@\n             if(found_goal_list[i] == 1)\n             {\n                 found_goal = 1;\n                 // cout<<\"??\"<<endl;\n-                // _return_cost[i] = _return_cost[i];\n+                _return_cost[i] = _return_cost[i];\n             }\n-            // else\n-            // {\n-            //     _return_cost[i] = _return_cost[i] + 100.0;\n-            // }\n+            else\n+            {\n+                _return_cost[i] = _return_cost[i] + 100.0;\n+            }\n         }\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n"
                },
                {
                    "date": 1689918928365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -632,9 +632,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689919075791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1143,9 +1143,9 @@\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.05)\n+            if(tmp_p <= gap_limit)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689919239569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1105,9 +1105,9 @@\n         {\n             double tmp_p = 0.0;\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n-            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n+            // tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n \n \n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n             // double rotation_EE_index[9];\n"
                },
                {
                    "date": 1689919346557,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1143,9 +1143,9 @@\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n \n             find_sol[index] = 0;\n-            if(tmp_p <= gap_limit)\n+            if(tmp_p <= 0.01)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689919452684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1105,9 +1105,9 @@\n         {\n             double tmp_p = 0.0;\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n-            // tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n+            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n \n \n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n             // double rotation_EE_index[9];\n@@ -1143,9 +1143,9 @@\n             // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n             /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n \n             find_sol[index] = 0;\n-            if(tmp_p <= 0.01)\n+            if(tmp_p <= 0.03)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n"
                },
                {
                    "date": 1689919465587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,25 +1195,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+            _dt_cuda2[0] = -1 * ((0.8-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.8;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.5;\n+            _dt_cuda2[0] = 0.8;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.5;\n+        _dt_cuda2[0] = 0.8;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.5)\n+    if(_dt_cuda2[0] != 0.8)\n     {\n         cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689919500663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,25 +1195,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.8-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.8;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.8;\n+            _dt_cuda2[0] = 0.7;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.8;\n+        _dt_cuda2[0] = 0.7;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.8)\n+    if(_dt_cuda2[0] != 0.7)\n     {\n         cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689920168925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1575,14 +1575,14 @@\n             if(found_goal_list[i] == 1)\n             {\n                 found_goal = 1;\n                 // cout<<\"??\"<<endl;\n-                _return_cost[i] = _return_cost[i];\n+                // _return_cost[i] = _return_cost[i];\n             }\n-            else\n-            {\n-                _return_cost[i] = _return_cost[i] + 100.0;\n-            }\n+            // else\n+            // {\n+            //     _return_cost[i] = _return_cost[i] + 100.0;\n+            // }\n         }\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n"
                },
                {
                    "date": 1689920207112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,25 +1195,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.8-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.8;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.7;\n+            _dt_cuda2[0] = 0.8;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 0.8;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n+    if(_dt_cuda2[0] != 0.8)\n     {\n         cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689920229940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,25 +1195,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.8-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.8;\n+            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.8;\n+            _dt_cuda2[0] = 0.5;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.8;\n+        _dt_cuda2[0] = 0.5;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.8)\n+    if(_dt_cuda2[0] != 0.5)\n     {\n         cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689920418077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1195,25 +1195,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.5;\n+            _dt_cuda2[0] = 0.7;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.5;\n+        _dt_cuda2[0] = 0.7;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.5)\n+    if(_dt_cuda2[0] != 0.7)\n     {\n         cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689920540698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight2/2;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689920623050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -611,15 +611,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*2 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1689920764771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] >= gap_limit)\n+    if(now_gap[0] >= gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -632,9 +632,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2;\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -1107,45 +1107,27 @@\n             tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n             tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n             tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n \n+            double rotation_EE_index[9];\n+            for(int j = 0; j<9; j++)\n+            {\n+                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+            }\n \n-            /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n-            // double rotation_EE_index[9];\n-            // for(int j = 0; j<9; j++)\n-            // {\n-            //     rotation_EE_index[j] = rotation_mat_EE[index*_time_window*9+i*9+j];\n-            // }\n+            double RotGoalT_x_RotEE[9];\n+            double RotGap[3];\n \n-            // double RotGoalT_x_RotEE[9];\n-            // double RotGap[3];\n+            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n+            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n-            // matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n-            // rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+            double tmp_p2 = 0.0;\n+            tmp_p2 = abs_cuda1(RotGap[0]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n \n-            // double tmp_p2 = 0.0;\n-            // for(int j = 0; j<3; j++)\n-            // {\n-            //     tmp_p2 += abs_cuda1(RotGap[j]);\n-            // }\n-            // if(index == 0)\n-            // {\n-            //     if(i == 0)\n-            //     {\n-            //         printf(\"tmp_p2 : %f \\n\",tmp_p2);\n-            //         printf(\"Roll error : %f \\n\",RotGap[0]);\n-            //         printf(\"Pitch error : %f \\n\",RotGap[1]);\n-            //         printf(\"Yaw error : %f \\n\",RotGap[2]);\n-            //     }                \n-            // }\n-            // tmp_p2 = abs_cuda1(RotGap[2]);\n-            // tmp_p2 = abs_cuda1(RotGap[0]);\n-            // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n-            // tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n-            /////////////////////////////////////////////////roatation error ////////////////////////////////////////\n-\n             find_sol[index] = 0;\n-            if(tmp_p <= 0.03)\n+            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n             {\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n@@ -1213,9 +1195,9 @@\n     }\n     found_goal = 0;\n     if(_dt_cuda2[0] != 0.7)\n     {\n-        cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n@@ -1545,9 +1527,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1556,9 +1538,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1900,15 +1882,15 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n+    position_sec1[0] = 0.03125;\n+    position_sec2[0] = 0.005;\n+    velocity_lim[0] = 0.8;\n+\n     // position_sec1[0] = 0.03125;\n-    // position_sec2[0] = 0.005;\n-    // velocity_lim[0] = 0.8;\n-\n-    position_sec1[0] = 0.1125;\n-    position_sec2[0] = 0.0125;\n-    velocity_lim[0] = 1.0;\n+    // position_sec2[0] = 0.00625;\n+    // velocity_lim[0] = 1.0;\n \t\n     // numBlocks = N / THREADS_PER_BLOCK;\n     // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n \n"
                },
                {
                    "date": 1689920967623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -587,9 +587,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689921052369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;\n+    double vel_gain = 300.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689921129691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689921280677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,14 +453,14 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 150.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 300.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1689921369911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -677,9 +677,9 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            if(joint_num>=4)\n+            if(joint_num<=4)\n             {\n                 _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             }\n             else\n"
                },
                {
                    "date": 1689921396991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -677,16 +677,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            if(joint_num<=4)\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            }\n-            else\n-            {\n+            // if(joint_num>=4)\n+            // {\n+            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            // }\n+            // else\n+            // {\n                 _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            }            \n+            // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1689921652963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;\n+    double vel_gain = 10.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689921733735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,26 +363,35 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 10.0;\n+    double vel_gain = 500.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n-    \n-    if(now_gap[0] >= gap_limit )\n+\n+    if(now_gap[1] <= gap_limit)\n     {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n+    }\n+    else\n+    {\n         vel_gain =  0.0;\n     }\n-    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    \n+    // if(now_gap[0] >= gap_limit/2)\n     // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    //     vel_gain =  0.0;\n     // }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    }\n+    // // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // // {\n+    // //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n+    // }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n     //     vel_gain =  vel_gain * 3.0;\n@@ -453,14 +462,14 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 150.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 300.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }        \n     // }\n     __syncthreads();\n }\n@@ -526,9 +535,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -558,8 +567,9 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n+        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n         // RotGap[2] = RotGap[2] * 2.0;\n@@ -580,16 +590,18 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(PosGap_2 > gap_limit)\n         {\n+            cost3 = weight1;\n             weight1 =  0.0;\n         }\n         else\n         {\n+            cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n@@ -632,9 +644,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -677,16 +689,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            // if(joint_num>=4)\n-            // {\n-            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            // }\n-            // else\n-            // {\n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n                 _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            // }            \n+            }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1689921850038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,35 +363,26 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;\n+    double vel_gain = 450.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n-\n-    if(now_gap[1] <= gap_limit)\n+    \n+    if(now_gap[0] >= gap_limit )\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[1]) * vel_gain;\n+        vel_gain =  0.0;\n     }\n+    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     else\n     {\n-        vel_gain =  0.0;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n-    \n-    // if(now_gap[0] >= gap_limit/2)\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n-    // // {\n-    // //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n-    // }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n     //     vel_gain =  vel_gain * 3.0;\n@@ -535,9 +526,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -567,9 +558,8 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n         // RotGap[2] = RotGap[2] * 2.0;\n@@ -590,16 +580,14 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit)\n+        if(PosGap_2 > gap_limit )\n         {\n-            cost3 = weight1;\n             weight1 =  0.0;\n         }\n         else\n         {\n-            cost3 = 0.0;\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n             weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n@@ -644,9 +632,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1689922196023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,14 +425,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689922348949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -423,16 +423,17 @@\n \n     // }\n     // else\n     // {\n+\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1689922405433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -678,16 +678,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            if(joint_num>=4)\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            }\n-            else\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            }            \n+            // if(joint_num>=4)\n+            // {\n+            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            // }\n+            // else\n+            // {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 2.0 + _A[joint_num];\n+            // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1689922530008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -684,9 +684,9 @@\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n             // else\n             // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 2.0 + _A[joint_num];\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n             // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n"
                },
                {
                    "date": 1689922714119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -678,16 +678,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            // if(joint_num>=4)\n-            // {\n-            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            // }\n-            // else\n-            // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            // }            \n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1689922725369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 450.0;\n+    double vel_gain = 300.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n@@ -527,9 +527,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1689922785011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -588,9 +588,9 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1689922859862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1178,25 +1178,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.7;\n+            _dt_cuda2[0] = 0.5;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 0.5;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n+    if(_dt_cuda2[0] != 0.5)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n"
                },
                {
                    "date": 1689923058281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;\n+    double vel_gain = 500.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689923064134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] >= gap_limit )\n+    if(now_gap[0] >= gap_limit/2)\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n@@ -379,9 +379,9 @@\n     //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     // }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689923120734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -369,9 +369,9 @@\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n     \n-    if(now_gap[0] >= gap_limit/2)\n+    if(now_gap[0] >= 0.1)\n     {\n         vel_gain =  0.0;\n     }\n     // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n@@ -379,9 +379,9 @@\n     //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     // }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit/2-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689923155987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;\n+    double vel_gain = 1000.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689923213806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;\n+    double vel_gain = 300.0;\n     // if(index == 0)\n     // {\n     //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n     // }\n"
                },
                {
                    "date": 1689923287893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,12 +373,12 @@\n     if(now_gap[0] >= 0.1)\n     {\n         vel_gain =  0.0;\n     }\n-    // else if(now_gap[0] <= gap_limit && now_gap[0] > gap_limit/2)\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // }\n+    else if(now_gap[0] <= 0.1 && now_gap[0] > 0.01)\n+    {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n     else\n     {\n         vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n     }\n"
                },
                {
                    "date": 1689923299190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -375,9 +375,9 @@\n         vel_gain =  0.0;\n     }\n     else if(now_gap[0] <= 0.1 && now_gap[0] > 0.01)\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain/5;\n     }\n     else\n     {\n         vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n"
                },
                {
                    "date": 1689923326548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,9 +379,9 @@\n         vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain/5;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(0.01-now_gap[0]) * vel_gain + vel_gain/5;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689923450363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,9 +379,9 @@\n         vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain/5;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(0.01-now_gap[0]) * vel_gain + vel_gain/5;\n+        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689923464552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -379,9 +379,9 @@\n         vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain/5;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n+        // vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n     }\n \n     // if(now_gap[1]<gap_limit)\n     // {\n"
                },
                {
                    "date": 1689925474265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,32 +363,17 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;\n-    // if(index == 0)\n-    // {\n-    //     printf(\"now_gap[1] : %f\\n\",now_gap[1]);\n-    // }\n-    \n-    if(now_gap[0] >= 0.1)\n+    double vel_gain = 300.0;//pow(10,6)\n+    if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n-    else if(now_gap[0] <= 0.1 && now_gap[0] > 0.01)\n-    {\n-        vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain/5;\n-    }\n     else\n     {\n-        // vel_gain =  abs_cuda1(0.1-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n-\n-    // if(now_gap[1]<gap_limit)\n-    // {\n-    //     vel_gain =  vel_gain * 3.0;\n-    // }\n-\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -423,15 +408,14 @@\n \n     // }\n     // else\n     // {\n-\n-        if(position[index] <= min_joint_limit[joint_num])\n+        if(position[index] < min_joint_limit[joint_num])\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n-        else if(position[index] >= max_joint_limit[joint_num])\n+        else if(position[index] > max_joint_limit[joint_num])\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n@@ -454,9 +438,9 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n@@ -527,18 +511,18 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n-            rotation_EE_index[i] = rotation_EE[index*9+i];  \n+            rotation_EE_index[i] = rotation_EE[index*9+i];    \n         }\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n@@ -562,14 +546,13 @@\n         double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n-        // RotGap[2] = RotGap[2] * 2.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + pow2_cuda(RotGap[i]) + abs(RotGap[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -588,9 +571,8 @@\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-            // weight2 =  weight2 - abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n@@ -1158,19 +1140,13 @@\n { \n     // _dt_cuda2[0] = 0.5;\n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n-    now_pos_gap[1] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n-    for(int i = 0; i<3; i++)\n-    {\n-        // now_pos_gap[1] = now_pos_gap[1] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n-        now_pos_gap[1] = now_pos_gap[1] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]);\n-    }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n@@ -1178,25 +1154,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.5;\n+            _dt_cuda2[0] = 0.7;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.5;\n+        _dt_cuda2[0] = 0.7;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.5)\n+    if(_dt_cuda2[0] != 0.7)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n \n@@ -1479,13 +1455,18 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap, 2 * sizeof(double), cudaMemcpyHostToDevice);    \n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n+\n+\n+\n+\n+\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n@@ -1807,9 +1788,9 @@\n     cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_now_pos_gap, 2 * sizeof(double)); \n+    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     \n"
                },
                {
                    "date": 1689925659818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -550,9 +550,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n"
                },
                {
                    "date": 1690160293494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -408,16 +408,16 @@\n \n     // }\n     // else\n     // {\n-        if(position[index] < min_joint_limit[joint_num])\n+        if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n-        else if(position[index] > max_joint_limit[joint_num])\n+        else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690160543534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690160551498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690160558153,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index],min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index]-min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index],max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index]-max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690160797221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1940,12 +1940,12 @@\n \n \n     for(int i = 0; i<_JDOF; i++)\n     {\n-        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n     }\n \n     FK_a[0] = 0.0;\n"
                },
                {
                    "date": 1690160824113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -660,16 +660,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            if(joint_num>=4)\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            }\n-            else\n-            {\n+            // if(joint_num>=4)\n+            // {\n+            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            // }\n+            // else\n+            // {\n                 _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            }            \n+            // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1690160862812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -666,9 +666,9 @@\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n             // else\n             // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n             // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n@@ -1866,9 +1866,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 0.8;\n+    velocity_lim[0] = 1.5;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690160997379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1940,12 +1940,12 @@\n \n \n     for(int i = 0; i<_JDOF; i++)\n     {\n-        _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n     }\n \n     FK_a[0] = 0.0;\n"
                },
                {
                    "date": 1690161360291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1577,16 +1577,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n+            if(_A[j] > 10.0)\n+            {\n+                _A[j] = 10.0;\n+            }\n+            else if(_A[j] < -10.0)\n+            {\n+                _A[j] = -10.0;\n+            }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690161435683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,17 +436,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 5)\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }\n-        else\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }        \n+        // if(joint_num < 5)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1690161503875,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690161620006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index]-min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index]-min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * pow2_cuda(position[index]-max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index]-max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690161636245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index]-min_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index]-min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index]-max_joint_limit[joint_num]);\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index]-max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690161647287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,14 +410,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index]-min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index]-max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690161700245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690161968773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,8 +361,9 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n+    int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n@@ -422,12 +423,17 @@\n         else\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n-        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n+\n+        if(time_step_num < 32-5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n+            if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n+            {\n+                cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n+            }    \n         }\n+        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n"
                },
                {
                    "date": 1690161980884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -424,9 +424,9 @@\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n \n-        if(time_step_num < 32-5)\n+        if(time_step_num < _time_window-_dt2_window)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n"
                },
                {
                    "date": 1690162190654,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -411,23 +411,24 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n-        else\n+\n+        if(time_step_num < _time_window-_dt2_window)\n         {\n+                    else\n+        {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n \n-        if(time_step_num < _time_window-_dt2_window)\n-        {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n"
                },
                {
                    "date": 1690162197944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,16 +419,17 @@\n         {\n             cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n-\n-        if(time_step_num < _time_window-_dt2_window)\n+        else\n         {\n-                    else\n-        {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n \n+        if(time_step_num < _time_window-_dt2_window)\n+        {\n+\n+\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n"
                },
                {
                    "date": 1690162216419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,22 +419,21 @@\n         {\n             cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n-        else\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n-        }\n \n+\n         if(time_step_num < _time_window-_dt2_window)\n         {\n-\n-\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n         }\n+                else\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1690162239768,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,8 +419,12 @@\n         {\n             cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n+        else\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n \n \n         if(time_step_num < _time_window-_dt2_window)\n         {\n@@ -428,12 +432,11 @@\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n         }\n-                else\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n-        }\n+\n+\n+\n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1690162274584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,12 +419,8 @@\n         {\n             cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n-        else\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n-        }\n \n \n         if(time_step_num < _time_window-_dt2_window)\n         {\n@@ -432,11 +428,15 @@\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n         }\n+        else\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n+        }\n \n+        \n \n-\n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1690162295683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -427,17 +427,12 @@\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n-        }\n-        else\n-        {\n             cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n-        }\n+        }       \n \n         \n-\n-        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n"
                },
                {
                    "date": 1690162588631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1514,9 +1514,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.8,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1525,9 +1525,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.8,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690162678702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1514,9 +1514,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.8,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1525,9 +1525,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.8,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690162872970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1156,18 +1156,18 @@\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     if(found_goal == 1)\n     {\n-        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+        if(now_pos_gap[0] > position_sec2[0]*2 && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]*2-2,2))*pow(now_pos_gap[0]-2,2)+0.7;\n         }\n-        else if(now_pos_gap[0] <= position_sec2[0])\n+        else if(now_pos_gap[0] <= position_sec2[0]*2)\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n-        else if(now_pos_gap[0] >= 1.0)\n+        else if(now_pos_gap[0] >= 1.0*2)\n         {\n             _dt_cuda2[0] = 0.7;\n         }\n     }\n"
                },
                {
                    "date": 1690162914588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1156,18 +1156,18 @@\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     if(found_goal == 1)\n     {\n-        if(now_pos_gap[0] > position_sec2[0]*2 && now_pos_gap[0] < 1.0)\n+        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]*2-2,2))*pow(now_pos_gap[0]-2,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         }\n-        else if(now_pos_gap[0] <= position_sec2[0]*2)\n+        else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n-        else if(now_pos_gap[0] >= 1.0*2)\n+        else if(now_pos_gap[0] >= 1.0)\n         {\n             _dt_cuda2[0] = 0.7;\n         }\n     }\n"
                },
                {
                    "date": 1690162933633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -516,9 +516,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 45000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690164967587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1871,9 +1871,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 1.5;\n+    velocity_lim[0] = 1.2;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690165110861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -441,17 +441,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        // if(joint_num < 5)\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n+        if(joint_num < 5)\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }\n+        else\n+        {\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }        \n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1690165186987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -441,17 +441,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 5)\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }\n-        else\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }        \n+        // if(joint_num < 5)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1690165241991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 400.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -428,9 +428,13 @@\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n             cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n-        }       \n+        }\n+        else\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * 0.5 * abs_cuda1(velocity[index]);\n+        }    \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n"
                },
                {
                    "date": 1690182008140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -420,21 +420,23 @@\n             cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n+        else\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n+        }    \n \n+\n         if(time_step_num < _time_window-_dt2_window)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n-            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n+            // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n-        else\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * 0.5 * abs_cuda1(velocity[index]);\n-        }    \n+        \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n"
                },
                {
                    "date": 1690182066112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690182122037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -617,9 +617,9 @@\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690182159641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 45000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690182357792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 400.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690182607014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -411,14 +411,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n         else\n"
                },
                {
                    "date": 1690182662758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,15 +605,15 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1690182790243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -618,8 +618,9 @@\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = cost1*0.2;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690182816001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -611,9 +611,10 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = cost1 * 2.0;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n"
                },
                {
                    "date": 1690182829525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,10 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = cost1 * 3.0;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n@@ -619,9 +620,9 @@\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-            cost1 = cost1*0.2;\n+            // cost1 = cost1;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690182844706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -601,8 +601,9 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n+        cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n@@ -612,9 +613,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n             cost1 = cost1 * 2.0;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n"
                },
                {
                    "date": 1690182901239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -601,29 +601,26 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n-        cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            // cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            cost1 = cost1 * 3.0;\n+            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            // cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n-            cost1 = cost1 * 2.0;\n+            cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost1 = cost1;\n+            cost1 = cost1*0.2;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690182908230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n@@ -618,9 +618,9 @@\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-            cost1 = cost1*0.2;\n+            cost1 = cost1*0.5;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690182936354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,22 +605,21 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 =  weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-            cost1 = cost1*0.5;\n             // cost2 = (1-_manipulability[index]);\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690183038504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,22 +605,35 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n-            cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n+            if(cost1_2 >  position_sec1[0])\n+            {\n+                cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            }\n+            else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+            {\n+                cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+                // cost2 = weight_manipul * (1-_manipulability[index]);\n+            }\n+            else\n+            {\n+                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+            }\n+\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n"
                },
                {
                    "date": 1690183047094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -622,9 +622,9 @@\n             if(cost1_2 >  position_sec1[0])\n             {\n                 cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             }\n-            else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+            else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n                 cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n"
                },
                {
                    "date": 1690183054704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -631,9 +631,8 @@\n             else\n             {\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n             }\n-\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n"
                },
                {
                    "date": 1690183084159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 400.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690183224456,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 400.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690183305161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,28 +605,28 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  position_sec1[0])\n             {\n-                cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n             }\n             else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n-                cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n"
                },
                {
                    "date": 1690249685493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,9 +575,9 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(cost2_2 > gap_limit)\n         {\n             weight1 =  0.0;\n         }\n         else\n"
                },
                {
                    "date": 1690249751798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(cost2_2 > gap_limit)\n+        if(PosGap_2 > gap_limit/2)\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1 / (gap_limit/2));\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690249760781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -581,9 +581,9 @@\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1 / (gap_limit/2));\n+            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1 / (gap_limit/2);\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690249799659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -581,9 +581,9 @@\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1 / (gap_limit/2);\n+            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690261616399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690261642421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,9 +523,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 100000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 500000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690261665054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 500000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690261686546,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690261780727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -606,14 +606,22 @@\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n             cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+            }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n             cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+            }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n@@ -621,17 +629,29 @@\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  position_sec1[0])\n             {\n                 cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                }\n             }\n             else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n                 cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+                }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+                }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690261869303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1000000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,17 +628,17 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  position_sec1[0])\n             {\n-                cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n             }\n             else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n-                cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262013583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 1000000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  position_sec1[0])\n             {\n-                cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262135282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -626,17 +626,17 @@\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n-            if(cost1_2 >  position_sec1[0])\n+            if(cost1_2 >  gap_limit)\n             {\n                 cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n             }\n-            else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n+            else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n                 cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n"
                },
                {
                    "date": 1690262195485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,16 +575,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit/2)\n-        {\n-            weight1 =  0.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n-        }\n+        // if(PosGap_2 > gap_limit/2)\n+        // {\n+        //     weight1 =  0.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690262246345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 4000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n"
                },
                {
                    "date": 1690262272314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 11000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n"
                },
                {
                    "date": 1690262341607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 11000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 12000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 11000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262371199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -631,9 +631,9 @@\n             {\n                 cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n-                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 3 // cost1 = %f\\n\",weight1 * cost1_2);\n                 }\n             }\n             else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n"
                },
                {
                    "date": 1690262427885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -631,9 +631,9 @@\n             {\n                 cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n-                    printf(\"// section 3 // cost1 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n             }\n             else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n"
                },
                {
                    "date": 1690262440713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 60.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690262486897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300.0; // 50000.0 (10.0) // pos\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690262505527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,9 +523,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 12000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 1002000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 11000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 1001000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 10000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+                cost1 = 1000000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262573366,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 1002000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 1001000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 1000000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262619051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 6000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690262706810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 6000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690262811127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 4000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 2000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262859173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60.0; // 10000.0 (10.0) // rot\n+    double weight1 = 30.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690262919725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n             }\n@@ -615,9 +615,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n             }\n@@ -628,9 +628,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 2000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                 }\n"
                },
                {
                    "date": 1690262980311,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,8 +609,10 @@\n             cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n@@ -619,8 +621,10 @@\n             cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -632,16 +636,20 @@\n                 cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n             }\n             else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n                 cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n@@ -649,8 +657,10 @@\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690263030702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,10 +609,10 @@\n             cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n@@ -621,10 +621,10 @@\n             cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -636,20 +636,20 @@\n                 cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n                 }\n             }\n             else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n                 cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n@@ -657,10 +657,10 @@\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690263307307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1010000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n@@ -617,9 +617,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1001000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n@@ -632,9 +632,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 1000000 + weight2 * cost2_2;// + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263393131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -632,9 +632,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 1000000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263523541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -617,9 +617,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 1001000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 1001000 + weight2 * cost2_2 + weight1 * cost1_2 * 0.1;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263533279,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 1010000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 110000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263565791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 110000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 150000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263578769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 150000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 1101000 + weight2 * cost2_2;// + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263616449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -617,9 +617,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 1001000 + weight2 * cost2_2 + weight1 * cost1_2 * 0.1;\n+            cost1 =  3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263665515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 1101000 + weight2 * cost2_2;// + weight1 * cost1_2;\n+            cost1 = 501000 + weight2 * cost2_2 + weight1 * cost1_2/2.0;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263804048,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 501000 + weight2 * cost2_2 + weight1 * cost1_2/2.0;\n+            cost1 = 550000 + weight2 * cost2_2 + weight1 * cost1_2/2.0;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690263872189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,8 +373,14 @@\n     else\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n+                if(index == 0)\n+            {\n+                printf(\"vel_gain = %f\\n\",vel_gain);\n+                printf(\"now_gap[0] = %f\\n\",now_gap[0]);\n+                // printf(\"cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+            }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1690263920690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,16 +373,8 @@\n     else\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n-                if(index == 0)\n-            {\n-                printf(\"vel_gain = %f\\n\",vel_gain);\n-                printf(\"now_gap[0] = %f\\n\",now_gap[0]);\n-                // printf(\"cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n-            }\n-    \n-\n     cost_joint_limit[index]=0.0;\n \n     // if(index2 >= _time_window-5)\n     // {   \n@@ -440,10 +432,16 @@\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n-        \n \n+        if(index == 0)\n+        {\n+            printf(\"vel_gain = %f\\n\",vel_gain);\n+            printf(\"now_gap[0] = %f\\n\",now_gap[0]);\n+            printf(\"cost_joint_limit[index] = %f\\n\\n\",cost_joint_limit[index]);\n+        }\n+\n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1690263958897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 5000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690264041038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 10000000.0;//pow(10,6)\n     double vel_gain = 5000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1690264121704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,10 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 10000000.0;//pow(10,6)\n-    double vel_gain = 5000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690264142673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 550000 + weight2 * cost2_2 + weight1 * cost1_2/2.0;\n+            cost1 = 250000 + weight2 * cost2_2 + weight1 * cost1_2/5.0;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690264239719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,14 +409,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain;// * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain;// *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n         else\n"
                },
                {
                    "date": 1690264295091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -409,14 +409,14 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain;// * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain;// *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n         else\n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 250000 + weight2 * cost2_2 + weight1 * cost1_2/5.0;\n+            cost1 = 200000 + weight2 * cost2_2 + weight1 * cost1_2/5.0;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690265867060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 200000 + weight2 * cost2_2 + weight1 * cost1_2/5.0;\n+            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2*1.0;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690265995291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 500000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2*1.0;\n+            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690266020468,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 500000.0;//pow(10,6)\n+    double constraint_gain = 200000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -1634,16 +1634,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            if(_A[j] > 10.0)\n-            {\n-                _A[j] = 10.0;\n-            }\n-            else if(_A[j] < -10.0)\n-            {\n-                _A[j] = -10.0;\n-            }\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690266225495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 100000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n+            cost1 = 200000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690266315655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 200000.0;//pow(10,6)\n+    double constraint_gain = 1000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 200000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n+            cost1 = 1000000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690266400137,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 1000000.0;//pow(10,6)\n+    double constraint_gain = 2000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -527,9 +527,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 600000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690269799879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 2000000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 2000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690269917719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 2000000.0;//pow(10,6)\n-    double vel_gain = 2000.0;//pow(10,6)\n+    double vel_gain = 1500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690269923264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -527,9 +527,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 600000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 1000000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690269973566,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 2000000.0;//pow(10,6)\n-    double vel_gain = 1500.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -527,9 +527,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 1000000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690270029986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1590,9 +1590,9 @@\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n-            _return_cost[i] = _return_cost[i] / _JDOF;\n+            _return_cost[i] = _return_cost[i] / _JDOF*1000;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n             if(found_goal_list[i] == 1)\n             {\n                 found_goal = 1;\n"
                },
                {
                    "date": 1690270068516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1590,9 +1590,9 @@\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n-            _return_cost[i] = _return_cost[i] / _JDOF*1000;\n+            _return_cost[i] = _return_cost[i] / _JDOF*100000.0;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n             if(found_goal_list[i] == 1)\n             {\n                 found_goal = 1;\n"
                },
                {
                    "date": 1690270096633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1590,9 +1590,9 @@\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n-            _return_cost[i] = _return_cost[i] / _JDOF*100000.0;\n+            _return_cost[i] = _return_cost[i] / _JDOF;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n             if(found_goal_list[i] == 1)\n             {\n                 found_goal = 1;\n"
                },
                {
                    "date": 1690270102719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1566,9 +1566,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.95,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1577,9 +1577,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.95,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690270234717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1566,9 +1566,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.95,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1577,9 +1577,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.95,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690270308438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,9 +609,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 1000000 + weight2 * cost2_2 + weight1 * cost1_2*0.1;\n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690270350743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,10 +526,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 10000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 50000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690270383021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 2000000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690270409408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,10 +526,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 10000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 50000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 500000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690270436231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 2000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690270568426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,9 +609,17 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            if(weight1 * cost1_2 > 1000000)\n+            {\n+                cost1 = 1004000 + weight2 * cost2_2;\n+            }\n+            else\n+            {\n+                cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            }\n+            \n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n"
                },
                {
                    "date": 1690270648382,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -609,11 +609,11 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            if(weight1 * cost1_2 > 1000000)\n+            if(weight1 * cost1_2 > 100000)\n             {\n-                cost1 = 1004000 + weight2 * cost2_2;\n+                cost1 = 104000 + weight2 * cost2_2;\n             }\n             else\n             {\n                 cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690270702670,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -611,9 +611,9 @@\n         if(cost2_2 >  position_sec1[0])\n         {\n             if(weight1 * cost1_2 > 100000)\n             {\n-                cost1 = 104000 + weight2 * cost2_2;\n+                cost1 = 114000 + weight2 * cost2_2 + weight1 * cost1_2 * 0.1;\n             }\n             else\n             {\n                 cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690270831161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 2000000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -373,8 +373,10 @@\n     else\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n     }\n+    \n+\n     cost_joint_limit[index]=0.0;\n \n     // if(index2 >= _time_window-5)\n     // {   \n@@ -432,16 +434,10 @@\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n+        \n \n-        if(index == 0)\n-        {\n-            printf(\"vel_gain = %f\\n\",vel_gain);\n-            printf(\"now_gap[0] = %f\\n\",now_gap[0]);\n-            printf(\"cost_joint_limit[index] = %f\\n\\n\",cost_joint_limit[index]);\n-        }\n-\n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n@@ -526,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 500000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -609,34 +605,26 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            if(weight1 * cost1_2 > 100000)\n-            {\n-                cost1 = 114000 + weight2 * cost2_2 + weight1 * cost1_2 * 0.1;\n-            }\n-            else\n-            {\n-                cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n-            }\n-            \n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 =  3000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -648,20 +636,20 @@\n                 cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n             }\n             else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n                 cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n@@ -669,10 +657,10 @@\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n+                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n@@ -1574,9 +1562,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1585,9 +1573,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1642,16 +1630,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n+            if(_A[j] > 10.0)\n+            {\n+                _A[j] = 10.0;\n+            }\n+            else if(_A[j] < -10.0)\n+            {\n+                _A[j] = -10.0;\n+            }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690270962095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -411,34 +411,30 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n-        else\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n-        }    \n \n-\n         if(time_step_num < _time_window-_dt2_window)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n-            // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n+                else\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n         \n-\n-        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n@@ -454,9 +450,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -522,9 +518,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -575,16 +571,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit/2)\n-        // {\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -605,64 +601,22 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n-            }\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n-            }\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n-            if(cost1_2 >  gap_limit)\n-            {\n-                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n-                }\n-            }\n-            else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n-            {\n-                cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n-                }\n-                // cost2 = weight_manipul * (1-_manipulability[index]);\n-            }\n-            else\n-            {\n-                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 1 // cost1_2 = %f\\n\",cost1_2);\n-                    printf(\"// section 1 // cost2_2 = %f\\n\\n\",cost2_2);\n-                }\n-            }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n@@ -1562,9 +1516,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1573,9 +1527,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1919,9 +1873,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 1.2;\n+    velocity_lim[0] = 1.5;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690270983984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -411,30 +411,34 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n \n+        else\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n+        }    \n \n+\n         if(time_step_num < _time_window-_dt2_window)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n+            // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n-                else\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n-        }\n         \n+\n+        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n@@ -450,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -518,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -601,22 +605,34 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n+            if(cost1_2 >  position_sec1[0])\n+            {\n+                cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n+            }\n+            else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n+            {\n+                cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n+                // cost2 = weight_manipul * (1-_manipulability[index]);\n+            }\n+            else\n+            {\n+                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+            }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n@@ -1516,9 +1532,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1527,9 +1543,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1873,9 +1889,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 1.5;\n+    velocity_lim[0] = 1.2;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690271209576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1600,16 +1600,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            if(_A[j] > 10.0)\n-            {\n-                _A[j] = 10.0;\n-            }\n-            else if(_A[j] < -10.0)\n-            {\n-                _A[j] = -10.0;\n-            }\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690271217481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1532,9 +1532,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1543,9 +1543,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690271410778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -606,14 +606,26 @@\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n             cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+            }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n             cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 2 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                printf(\"// section 2 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+            }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n@@ -621,17 +633,35 @@\n             // cost2 = (1-_manipulability[index]);\n             if(cost1_2 >  position_sec1[0])\n             {\n                 cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 3 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 3 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                }\n             }\n             else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n                 cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 4 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 4 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n                 cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 5 // cost1_2 = %f\\n\",weight1 * cost1_2);\n+                    printf(\"// section 5 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n"
                },
                {
                    "date": 1690277258089,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -610,9 +610,9 @@\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                printf(\"// section 1 // cost2_2 = %f\\n\",weight2 * cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n@@ -622,9 +622,9 @@\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 2 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                printf(\"// section 2 // cost2_2 = %f\\n\",weight2 * cost2_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -637,9 +637,9 @@\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 3 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 3 // cost2_2 = %f\\n\",weight2 * cost2_2);\n                 }\n             }\n             else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n             {\n@@ -647,9 +647,9 @@\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 4 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 4 // cost2_2 = %f\\n\",weight2 * cost2_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n@@ -658,9 +658,9 @@\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 5 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 5 // cost2_2 = %f\\n\\n\",weight2 * cost2_2);\n+                    printf(\"// section 5 // cost2_2 = %f\\n\",weight2 * cost2_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n@@ -669,8 +669,9 @@\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         f[index] = cost1 + cost2;\n+        printf(\"// ALL // cost2 = %f\\n\\n\",cost2);\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690277292088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -669,9 +669,12 @@\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         f[index] = cost1 + cost2;\n-        printf(\"// ALL // cost2 = %f\\n\\n\",cost2);\n+        if(index == 0)\n+        {\n+            printf(\"// ALL // cost2 = %f\\n\\n\",cost2);\n+        }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690277330544,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(PosGap_2 > position_sec1[0] )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(position_sec1[0]-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690277391679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 300000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > position_sec1[0] )\n+        if(cost2_2 > position_sec2[0] )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(position_sec1[0]-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(position_sec2[0]-cost2_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690277424128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(cost2_2 > position_sec2[0] )\n+        if(cost2_2 > position_sec1[0] )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(position_sec2[0]-cost2_2) * weight1;\n+            weight1 =  abs_cuda1(position_sec1[0]-cost2_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690277446792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 300000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690277540637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(cost2_2 > position_sec1[0] )\n+        if(cost2_2 > gap_limit )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(position_sec1[0]-cost2_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690277556077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(cost2_2 > gap_limit )\n+        if(cost2_2 > gap_limit/5 )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit/5-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690277569067,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,9 +575,9 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(cost2_2 > gap_limit/5 )\n+        if(PosGap_2 > gap_limit/5 )\n         {\n             weight1 =  0.0;\n         }\n         else\n"
                },
                {
                    "date": 1690335861339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,15 +575,15 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit/5 )\n+        if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit/5-PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690335939881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -554,16 +554,16 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost1_2 = 0.0;        \n-        double cost2_2 = 0.0;\n+        double rot_cost_2 = 0.0;        \n+        double pos_cost_2 = 0.0;\n         // double cost2 = 0.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            rot_cost_2 = rot_cost_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -572,9 +572,9 @@\n             // else\n             // {\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n-            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+            pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n         if(PosGap_2 > gap_limit )\n         {\n"
                },
                {
                    "date": 1690335990398,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -603,69 +603,69 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(cost2_2 >  position_sec1[0])\n+        if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 10000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 1 // cost2_2 = %f\\n\",weight2 * cost2_2);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                printf(\"// section 2 // cost2_2 = %f\\n\",weight2 * cost2_2);\n+                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n-            if(cost1_2 >  position_sec1[0])\n+            if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 100 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 3 // cost2_2 = %f\\n\",weight2 * cost2_2);\n+                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n-            else if(cost1_2 <= position_sec1[0] && cost1_2 > position_sec2[0])\n+            else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 10 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 4 // cost2_2 = %f\\n\",weight2 * cost2_2);\n+                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n-                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // cost1_2 = %f\\n\",weight1 * cost1_2);\n-                    printf(\"// section 5 // cost2_2 = %f\\n\",weight2 * cost2_2);\n+                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n"
                },
                {
                    "date": 1690335998743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -554,8 +554,9 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n+        double cost3 = 0.0;\n         double rot_cost_2 = 0.0;        \n         double pos_cost_2 = 0.0;\n         // double cost2 = 0.0;\n \n"
                },
                {
                    "date": 1690336011647,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,12 +579,14 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n+            cost3 = 1000000.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            cost3 = 0.0;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1690336020308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -671,9 +671,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1 + cost2 + cost3;\n         if(index == 0)\n         {\n             printf(\"// ALL // cost2 = %f\\n\\n\",cost2);\n         }\n"
                },
                {
                    "date": 1690336031006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -674,9 +674,9 @@\n         }\n         f[index] = cost1 + cost2 + cost3;\n         if(index == 0)\n         {\n-            printf(\"// ALL // cost2 = %f\\n\\n\",cost2);\n+            printf(\"// ALL // cost = %f\\n\\n\",f[index]);\n         }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n"
                },
                {
                    "date": 1690336037894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -674,9 +674,9 @@\n         }\n         f[index] = cost1 + cost2 + cost3;\n         if(index == 0)\n         {\n-            printf(\"// ALL // cost = %f\\n\\n\",f[index]);\n+            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n"
                },
                {
                    "date": 1690336102661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,16 +576,16 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(PosGap_2 > gap_limit/5 )\n         {\n             weight1 =  0.0;\n             cost3 = 1000000.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit/5 - PosGap_2) * weight1;\n             cost3 = 0.0;\n         }\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1690419780943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,16 +576,16 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit/5 )\n+        if(PosGap_2 > gap_limit/3 )\n         {\n             weight1 =  0.0;\n             cost3 = 1000000.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit/5 - PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit/3 - PosGap_2) * weight1;\n             cost3 = 0.0;\n         }\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1690419916925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,16 +576,16 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit/3 )\n+        if(PosGap_2 > gap_limit)\n         {\n             weight1 =  0.0;\n             cost3 = 1000000.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit/3 - PosGap_2) * weight1;\n+            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n             cost3 = 0.0;\n         }\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1690438810753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit)\n-        {\n-            weight1 =  0.0;\n-            cost3 = 1000000.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-            cost3 = 0.0;\n-        }\n+        // if(PosGap_2 > gap_limit)\n+        // {\n+        //     weight1 =  0.0;\n+        //     cost3 = 1000000.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        //     cost3 = 0.0;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690438923774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690439077018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 1400.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690439163681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,16 +365,16 @@\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 1400.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    }\n+    // if(now_gap[0] > gap_limit )\n+    // {\n+    //     vel_gain =  0.0;\n+    // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1690439200705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1400.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n@@ -453,9 +453,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n"
                },
                {
                    "date": 1690439358679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,17 +364,17 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n-    // if(now_gap[0] > gap_limit )\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // }\n+    double vel_gain = 1000.0;//pow(10,6)\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -453,9 +453,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n"
                },
                {
                    "date": 1690442238881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit)\n-        // {\n-        //     weight1 =  0.0;\n-        //     cost3 = 1000000.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-        //     cost3 = 0.0;\n-        // }\n+        if(PosGap_2 > gap_limit)\n+        {\n+            weight1 =  0.0;\n+            cost3 = 1000000.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            cost3 = 0.0;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690442370948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 100.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -576,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit)\n-        {\n-            weight1 =  0.0;\n-            cost3 = 1000000.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-            cost3 = 0.0;\n-        }\n+        // if(PosGap_2 > gap_limit)\n+        // {\n+        //     weight1 =  0.0;\n+        //     cost3 = 1000000.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        //     cost3 = 0.0;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690442421213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,16 +365,16 @@\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 100.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    }\n+    // if(now_gap[0] > gap_limit )\n+    // {\n+    //     vel_gain =  0.0;\n+    // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1690442993924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,17 +364,17 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 100.0;//pow(10,6)\n-    // if(now_gap[0] > gap_limit )\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // }\n+    double vel_gain = 1000.0;//pow(10,6)\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -576,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit)\n-        // {\n-        //     weight1 =  0.0;\n-        //     cost3 = 1000000.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-        //     cost3 = 0.0;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+            cost3 = 1000000.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            cost3 = 0.0;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690443028804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,9 +579,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 1000000.0;\n+            // cost3 = 1000000.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690443732555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690444837629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 1000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1690444899625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -633,9 +633,9 @@\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n-            if(rot_cost_2 >  position_sec1[0])\n+            if(rot_cost_2 >  position_sec1[0]*2)\n             {\n                 cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n@@ -643,9 +643,9 @@\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n                     printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n-            else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n+            else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n             {\n                 cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n"
                },
                {
                    "date": 1690444961951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0]*2)\n             {\n-                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n             {\n-                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690445057001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -583,9 +583,9 @@\n             // cost3 = 1000000.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n             cost3 = 0.0;\n         }\n \n         // if(cost1_2 > 1)\n"
                },
                {
                    "date": 1690445090121,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,9 +579,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            // cost3 = 1000000.0;\n+            cost3 = 1000000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690445135346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690445243718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -608,26 +608,26 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + pos_cost_2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                printf(\"// section 2 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n+                printf(\"// section 2 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -635,35 +635,35 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0]*2)\n             {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                    printf(\"// section 3 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n+                    printf(\"// section 3 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n             {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                    printf(\"// section 4 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n+                    printf(\"// section 4 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n-                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                    printf(\"// section 5 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n+                    printf(\"// section 5 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690445309017,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,13 +608,13 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + pos_cost_2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n                 printf(\"// section 1 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n"
                },
                {
                    "date": 1690445355303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 0.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690445407087,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 0.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -608,26 +608,26 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n-                printf(\"// section 2 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n+                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n@@ -635,35 +635,35 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0]*2)\n             {\n-                cost1 = 2000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n-                    printf(\"// section 3 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n+                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n             {\n-                cost1 = 1000 + pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n-                    printf(\"// section 4 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n+                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n-                cost1 = pos_cost_2 * pos_cost_2 + rot_cost_2 * rot_cost_2;\n+                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // rot_cost_2 = %f\\n\",rot_cost_2 * rot_cost_2);\n-                    printf(\"// section 5 // pos_cost_2 = %f\\n\",pos_cost_2 * pos_cost_2);\n+                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690445494522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -665,15 +665,19 @@\n                     printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n+\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         f[index] = cost1 + cost2 + cost3;\n+\n+\n+        f[index] = (pos_cost_2+10) * (pos_cost_2+10) + (rot_cost_2+10) * (rot_cost_2+10);\n         if(index == 0)\n         {\n             printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n"
                },
                {
                    "date": 1690445520215,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690445561956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 0.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690445570411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -675,9 +675,9 @@\n         }\n         f[index] = cost1 + cost2 + cost3;\n \n \n-        f[index] = (pos_cost_2+10) * (pos_cost_2+10) + (rot_cost_2+10) * (rot_cost_2+10);\n+        f[index] = (pos_cost_2+100) * (pos_cost_2+100) + (rot_cost_2+100) * (rot_cost_2+100);\n         if(index == 0)\n         {\n             printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n"
                },
                {
                    "date": 1690445600623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -675,9 +675,9 @@\n         }\n         f[index] = cost1 + cost2 + cost3;\n \n \n-        f[index] = (pos_cost_2+100) * (pos_cost_2+100) + (rot_cost_2+100) * (rot_cost_2+100);\n+        f[index] = (pos_cost_2*100) * (pos_cost_2*100) + (rot_cost_2*100) * (rot_cost_2*100);\n         if(index == 0)\n         {\n             printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n"
                },
                {
                    "date": 1690445646168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 0.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -665,19 +665,16 @@\n                     printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n-\n+        \n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         f[index] = cost1 + cost2 + cost3;\n-\n-\n-        f[index] = (pos_cost_2*100) * (pos_cost_2*100) + (rot_cost_2*100) * (rot_cost_2*100);\n         if(index == 0)\n         {\n             printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n"
                },
                {
                    "date": 1690445738385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 1000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690445744454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,9 +579,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 1000000.0;\n+            cost3 = 10000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690445772990,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,9 +575,12 @@\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n-\n+        if(index == 0)\n+            {\n+                printf(\"rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+            }\n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n             cost3 = 10000.0;\n@@ -604,8 +607,9 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n+        \n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n"
                },
                {
                    "date": 1690445827245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -523,9 +523,9 @@\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 1000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight2 = 3000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690445884727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 1000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 3000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -575,16 +575,13 @@\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n-        if(index == 0)\n-            {\n-                printf(\"rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-            }\n+\n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 10000.0;\n+            cost3 = 1000000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n@@ -607,9 +604,8 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n-        \n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n@@ -669,9 +665,8 @@\n                     printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n-        \n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n"
                },
                {
                    "date": 1690445891272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690445922689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,9 +579,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 1000000.0;\n+            // cost3 = 1000000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690445957755,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -579,9 +579,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            // cost3 = 1000000.0;\n+            cost3 = 30000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690446026733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1569,9 +1569,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1580,9 +1580,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n"
                },
                {
                    "date": 1690507276240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690507333263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,68 +605,71 @@\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n+\n+            cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(pos_cost_2 >  position_sec1[0])\n-        {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n-        {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        else\n-        {\n-            // cost2 = (1-_manipulability[index]);\n-            if(rot_cost_2 >  position_sec1[0]*2)\n-            {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-            }\n-            else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n-            {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-                // cost2 = weight_manipul * (1-_manipulability[index]);\n-            }\n-            else\n-            {\n-                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-            }\n-        }\n+        // if(pos_cost_2 >  position_sec1[0])\n+        // {\n+        //     cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        //     if(index == 0)\n+        //     {\n+        //         printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+        //         printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+        //         printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+        //     }\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        // else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n+        // {\n+        //     cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        //     if(index == 0)\n+        //     {\n+        //         printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+        //         printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+        //         printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+        //     }\n+        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n+        // }\n+        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        // else\n+        // {\n+        //     // cost2 = (1-_manipulability[index]);\n+        //     if(rot_cost_2 >  position_sec1[0]*2)\n+        //     {\n+        //         cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        //         if(index == 0)\n+        //         {\n+        //             printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+        //             printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+        //             printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+        //         }\n+        //     }\n+        //     else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n+        //     {\n+        //         cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        //         if(index == 0)\n+        //         {\n+        //             printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+        //             printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+        //             printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+        //         }\n+        //         // cost2 = weight_manipul * (1-_manipulability[index]);\n+        //     }\n+        //     else\n+        //     {\n+        //         cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        //         if(index == 0)\n+        //         {\n+        //             printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+        //             printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+        //             printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+        //         }\n+        //     }\n+        // }\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n"
                },
                {
                    "date": 1690507350169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -607,9 +607,14 @@\n         // }\n \n \n             cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-\n+            if(index == 0)\n+            {\n+                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         // if(pos_cost_2 >  position_sec1[0])\n         // {\n         //     cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690507452479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-            cost3 = 30000.0;\n-        }\n-        else\n-        {\n-            // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-            cost3 = 0.0;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        //     cost3 = 30000.0;\n+        // }\n+        // else\n+        // {\n+        //     // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        //     cost3 = 0.0;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690507491183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 0.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690507560069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690507615793,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,9 +453,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n"
                },
                {
                    "date": 1690507640458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,9 +453,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690507652016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,8 +454,14 @@\n         // }\n         // else\n         // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            if(index == 0)\n+            {\n+                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n"
                },
                {
                    "date": 1690507684028,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            if(index == 0)\n+            if(index3 == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n                 printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n"
                },
                {
                    "date": 1690507714461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -456,11 +456,11 @@\n         // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             if(index3 == 0)\n             {\n-                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                printf(\"// cost_joint_limit[index]  = %f\\n\",cost_joint_limit[index]);\n+                // printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n"
                },
                {
                    "date": 1690507804308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -359,9 +359,10 @@\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    int index3 = index % (_time_window*7);\n+    int index3 = index % (_time_window*_JDOF);\n+    int sam_num_cuda = index / (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n"
                },
                {
                    "date": 1690507831930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -455,11 +455,11 @@\n         // }\n         // else\n         // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            if(index3 == 0)\n+            if(sam_num_cuda == 0)\n             {\n-                printf(\"// cost_joint_limit[index]  = %f\\n\",cost_joint_limit[index]);\n+                printf(\"// cost_joint_limit[%d]  = %f\\n\",index,cost_joint_limit[index]);\n                 // printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n                 // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1690507875312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -457,11 +457,12 @@\n         // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n             if(sam_num_cuda == 0)\n             {\n-                printf(\"// cost_joint_limit[%d]  = %f\\n\",index,cost_joint_limit[index]);\n-                // printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                if(time_step_num == 0)\n+                {\n+                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index,cost_joint_limit[index]);\n+                }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n"
                },
                {
                    "date": 1690507899607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -459,9 +459,9 @@\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index,cost_joint_limit[index]);\n+                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,cost_joint_limit[index]);\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690507983407,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * abs_cuda2(cen_joint_position[joint_num],position[index]);\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n"
                },
                {
                    "date": 1690508070678,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -459,9 +459,9 @@\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,cost_joint_limit[index]);\n+                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,100.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508111135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,14 +454,14 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 100.0 * abs_cuda2(cen_joint_position[joint_num],position[index]);\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]);\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,100.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n+                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508179721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -435,8 +435,16 @@\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n+\n+        if(sam_num_cuda == 0)\n+            {\n+                if(time_step_num == 0)\n+                {\n+                    printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n+                }\n+            }\n         \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n@@ -459,9 +467,9 @@\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cost_joint_limit[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n+                    printf(\"// cen_joint[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508185125,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -437,14 +437,14 @@\n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n \n         if(sam_num_cuda == 0)\n+        {\n+            if(time_step_num == 0)\n             {\n-                if(time_step_num == 0)\n-                {\n-                    printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n-                }\n+                printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n             }\n+        }\n         \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n"
                },
                {
                    "date": 1690508193790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,17 +365,17 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 0.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    }\n+    double vel_gain = 500.0;//pow(10,6)\n+    // if(now_gap[0] > gap_limit )\n+    // {\n+    //     vel_gain =  0.0;\n+    // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1690508232753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,9 +365,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n"
                },
                {
                    "date": 1690508350152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2029,8 +2029,9 @@\n         // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n+        _joint_min_max_scale[i] = _max_joint_position[i] - _min_joint_position[i];\n     }\n \n     FK_a[0] = 0.0;\n     FK_d[0] = 0.343;\n"
                },
                {
                    "date": 1690508393830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1530,9 +1530,12 @@\n         cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_min_max_scale, _joint_min_max_scale, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n \n+\n+        \n         cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n \n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n"
                },
                {
                    "date": 1690508415061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1920,8 +1920,10 @@\n \n     cudaFree(dev_joint_min_limit_for_cost);\n     cudaFree(dev_joint_max_limit_for_cost);\n     cudaFree(dev_cen_joint_position);\n+    cudaFree(dev_joint_min_max_scale);\n+    \n \n     cudaFree(dev_position_sec1);\n     cudaFree(dev_position_sec2);\n     cudaFree(dev_velocity_lim);\n"
                },
                {
                    "date": 1690508431517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1850,8 +1850,9 @@\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_joint_min_max_scale, _JDOF * sizeof(double));    \n \n     cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n@@ -1920,10 +1921,9 @@\n \n     cudaFree(dev_joint_min_limit_for_cost);\n     cudaFree(dev_joint_max_limit_for_cost);\n     cudaFree(dev_cen_joint_position);\n-    cudaFree(dev_joint_min_max_scale);\n-    \n+    cudaFree(dev_joint_min_max_scale);    \n \n     cudaFree(dev_position_sec1);\n     cudaFree(dev_position_sec2);\n     cudaFree(dev_velocity_lim);\n"
                },
                {
                    "date": 1690508449846,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1543,9 +1543,9 @@\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap, dev_joint_min_max_scale);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n"
                },
                {
                    "date": 1690508482900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,9 +354,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *min_max_scale)\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n"
                },
                {
                    "date": 1690508502115,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,14 +462,14 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]);\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cen_joint[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]));\n+                    printf(\"// cen_joint[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508602099,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -467,9 +467,9 @@\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cen_joint[%d]  = %f\\n\",index/32,1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n+                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508622953,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -538,9 +538,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 3000.0; // 10000.0 (10.0) // rot\n     double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690508742900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -538,10 +538,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 3000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690508773672,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,14 +462,14 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 1000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n+                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508796526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,14 +462,14 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             if(sam_num_cuda == 0)\n             {\n                 if(time_step_num == 0)\n                 {\n-                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n+                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 5000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n                 }\n             }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n"
                },
                {
                    "date": 1690508820822,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,9 +365,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n"
                },
                {
                    "date": 1690509014658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,16 +462,16 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 5000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n-            if(sam_num_cuda == 0)\n-            {\n-                if(time_step_num == 0)\n-                {\n-                    printf(\"// cen_joint[%d]  = %f\\n\",index/32, 5000.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n-                }\n-            }\n+            cost_joint_limit[index] = cost_joint_limit[index] + 500.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            // if(sam_num_cuda == 0)\n+            // {\n+            //     if(time_step_num == 0)\n+            //     {\n+            //         printf(\"// cen_joint[%d]  = %f\\n\",index/32, 500.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n+            //     }\n+            // }\n             // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n"
                },
                {
                    "date": 1690509026641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,15 +436,15 @@\n             }    \n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n \n-        if(sam_num_cuda == 0)\n-        {\n-            if(time_step_num == 0)\n-            {\n-                printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n-            }\n-        }\n+        // if(sam_num_cuda == 0)\n+        // {\n+        //     if(time_step_num == 0)\n+        //     {\n+        //         printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n+        //     }\n+        // }\n         \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n@@ -623,14 +623,14 @@\n         // }\n \n \n             cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n+            // if(index == 0)\n+            // {\n+            //     printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+            //     printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+            //     printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            // }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         // if(pos_cost_2 >  position_sec1[0])\n         // {\n         //     cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690509032418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -696,12 +696,12 @@\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         f[index] = cost1 + cost2 + cost3;\n-        if(index == 0)\n-        {\n-            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n-        }\n+        // if(index == 0)\n+        // {\n+        //     printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n+        // }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690509193021,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -695,9 +695,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1;// + cost2 + cost3;\n         // if(index == 0)\n         // {\n         //     printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         // }\n@@ -1262,9 +1262,9 @@\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n-        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.2)\n         {            \n             reset_check = 1;\n             break;\n         }\n"
                },
                {
                    "date": 1690509238500,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1262,9 +1262,9 @@\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n-        if( abs(_q_des[i]-_init_pos[i]) >= 0.2)\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n         {            \n             reset_check = 1;\n             break;\n         }\n"
                },
                {
                    "date": 1690509265117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,9 +462,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 500.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             // if(sam_num_cuda == 0)\n             // {\n             //     if(time_step_num == 0)\n             //     {\n"
                },
                {
                    "date": 1690509332457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,9 +462,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            cost_joint_limit[index] = cost_joint_limit[index] + 30000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             // if(sam_num_cuda == 0)\n             // {\n             //     if(time_step_num == 0)\n             //     {\n"
                },
                {
                    "date": 1690520728334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -462,9 +462,9 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 30000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 30000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n             // if(sam_num_cuda == 0)\n             // {\n             //     if(time_step_num == 0)\n             //     {\n"
                },
                {
                    "date": 1690520889517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -354,28 +354,27 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap, double *min_max_scale)\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    int index3 = index % (_time_window*_JDOF);\n-    int sam_num_cuda = index / (_time_window*_JDOF);\n+    int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n     double vel_gain = 500.0;//pow(10,6)\n-    // if(now_gap[0] > gap_limit )\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // }\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -435,16 +434,8 @@\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n             // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n-\n-        // if(sam_num_cuda == 0)\n-        // {\n-        //     if(time_step_num == 0)\n-        //     {\n-        //         printf(\"// vel_joint[%d]  = %f\\n\",index/32,vel_gain * abs_cuda1(velocity[index]));\n-        //     }\n-        // }\n         \n \n         \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n@@ -462,17 +453,10 @@\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n         // else\n         // {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 30000.0 * abs_cuda2(cen_joint_position[joint_num],position[index]) / min_max_scale[joint_num];\n-            // if(sam_num_cuda == 0)\n-            // {\n-            //     if(time_step_num == 0)\n-            //     {\n-            //         printf(\"// cen_joint[%d]  = %f\\n\",index/32, 500.0 * abs_cuda2(cen_joint_position[joint_num],position[index])/min_max_scale[joint_num]);\n-            //     }\n-            // }\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -538,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 30000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -592,18 +576,18 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        //     cost3 = 30000.0;\n-        // }\n-        // else\n-        // {\n-        //     // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-        //     cost3 = 0.0;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+            cost3 = 30000.0;\n+        }\n+        else\n+        {\n+            // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            cost3 = 0.0;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -621,87 +605,79 @@\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n-\n-            cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            // if(index == 0)\n-            // {\n-            //     printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-            //     printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-            //     printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            // }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        // if(pos_cost_2 >  position_sec1[0])\n-        // {\n-        //     cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        //     if(index == 0)\n-        //     {\n-        //         printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-        //         printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-        //         printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-        //     }\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        // else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n-        // {\n-        //     cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        //     if(index == 0)\n-        //     {\n-        //         printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-        //         printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-        //         printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-        //     }\n-        //     // cost2 = weight_manipul * (1-_manipulability[index]);\n-        // }\n-        // ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        // else\n-        // {\n-        //     // cost2 = (1-_manipulability[index]);\n-        //     if(rot_cost_2 >  position_sec1[0]*2)\n-        //     {\n-        //         cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        //         if(index == 0)\n-        //         {\n-        //             printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-        //             printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-        //             printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-        //         }\n-        //     }\n-        //     else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n-        //     {\n-        //         cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        //         if(index == 0)\n-        //         {\n-        //             printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-        //             printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-        //             printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-        //         }\n-        //         // cost2 = weight_manipul * (1-_manipulability[index]);\n-        //     }\n-        //     else\n-        //     {\n-        //         cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        //         if(index == 0)\n-        //         {\n-        //             printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-        //             printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-        //             printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-        //         }\n-        //     }\n-        // }\n+        if(pos_cost_2 >  position_sec1[0])\n+        {\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            }\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n+        {\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            if(index == 0)\n+            {\n+                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            }\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        else\n+        {\n+            // cost2 = (1-_manipulability[index]);\n+            if(rot_cost_2 >  position_sec1[0]*2)\n+            {\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                }\n+            }\n+            else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n+            {\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                }\n+                // cost2 = weight_manipul * (1-_manipulability[index]);\n+            }\n+            else\n+            {\n+                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                if(index == 0)\n+                {\n+                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+                }\n+            }\n+        }\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2 + cost3;\n-        // if(index == 0)\n-        // {\n-        //     printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n-        // }\n+        f[index] = cost1 + cost2 + cost3;\n+        if(index == 0)\n+        {\n+            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n+        }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -1530,12 +1506,9 @@\n         cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_joint_min_max_scale, _joint_min_max_scale, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n \n-\n-        \n         cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n \n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n@@ -1543,9 +1516,9 @@\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap, dev_joint_min_max_scale);\n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n@@ -1850,9 +1823,8 @@\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n-    cudaMalloc((void**)&dev_joint_min_max_scale, _JDOF * sizeof(double));    \n \n     cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n@@ -1921,9 +1893,8 @@\n \n     cudaFree(dev_joint_min_limit_for_cost);\n     cudaFree(dev_joint_max_limit_for_cost);\n     cudaFree(dev_cen_joint_position);\n-    cudaFree(dev_joint_min_max_scale);    \n \n     cudaFree(dev_position_sec1);\n     cudaFree(dev_position_sec2);\n     cudaFree(dev_velocity_lim);\n@@ -2034,9 +2005,8 @@\n         // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n         _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n-        _joint_min_max_scale[i] = _max_joint_position[i] - _min_joint_position[i];\n     }\n \n     FK_a[0] = 0.0;\n     FK_d[0] = 0.343;\n"
                },
                {
                    "date": 1690520927792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690521013948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690521088603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,9 +575,14 @@\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n-\n+                    if(index == 0)\n+            {\n+                // printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            }\n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n             cost3 = 30000.0;\n"
                },
                {
                    "date": 1690521138019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -584,9 +584,9 @@\n             }\n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 30000.0;\n+            cost3 = 300000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690521248408,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -522,10 +522,10 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 5000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 30000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1690521253652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -584,9 +584,9 @@\n             }\n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 300000.0;\n+            cost3 = 1000000.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690521457272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -581,18 +581,18 @@\n                 // printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n                 // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-            cost3 = 1000000.0;\n-        }\n-        else\n-        {\n-            // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-            cost3 = 0.0;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        //     cost3 = 1000000.0;\n+        // }\n+        // else\n+        // {\n+        //     // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        //     cost3 = 0.0;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -676,9 +676,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1;// + cost2 + cost3;\n         if(index == 0)\n         {\n             printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n         }\n"
                },
                {
                    "date": 1690521462634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,14 +575,14 @@\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n-                    if(index == 0)\n-            {\n-                // printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n+            //         if(index == 0)\n+            // {\n+            //     // printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+            //     printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+            //     // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n+            // }\n         // if(PosGap_2 > gap_limit )\n         // {\n         //     weight1 =  0.0;\n         //     cost3 = 1000000.0;\n"
                },
                {
                    "date": 1690521900965,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -613,9 +613,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 40000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -625,9 +625,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 30000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -640,9 +640,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0]*2)\n             {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 20000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -650,9 +650,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n             {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690522084358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * (pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index])) + abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690522117954,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * (pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index])) + abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * (pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index])) + abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690522174756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -731,9 +731,9 @@\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n             // else\n             // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n             // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n"
                },
                {
                    "date": 1690522263675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690522471976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 1000000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * (pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index])) + abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -522,9 +522,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -554,17 +554,16 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost3 = 0.0;\n-        double rot_cost_2 = 0.0;        \n-        double pos_cost_2 = 0.0;\n+        double cost1_2 = 0.0;        \n+        double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            rot_cost_2 = rot_cost_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -573,25 +572,18 @@\n             // else\n             // {\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n-            pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n-            //         if(index == 0)\n-            // {\n-            //     // printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-            //     printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-            //     // printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            // }\n-        // if(PosGap_2 > gap_limit )\n+\n+        // if(PosGap_2 > gap_limit/2)\n         // {\n         //     weight1 =  0.0;\n-        //     cost3 = 1000000.0;\n         // }\n         // else\n         // {\n-        //     // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-        //     cost3 = 0.0;\n+        //     weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n         // }\n \n         // if(cost1_2 > 1)\n         // {\n@@ -611,78 +603,64 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(pos_cost_2 >  position_sec1[0])\n+        if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 40000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 30000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n-            if(rot_cost_2 >  position_sec1[0]*2)\n+            if(cost1_2 >  gap_limit)\n             {\n-                cost1 = 20000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n-            else if(rot_cost_2 <= position_sec1[0]*2 && rot_cost_2 > position_sec2[0]*2)\n+            else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n             {\n-                cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n-                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n-        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2 + cost3;\n-        if(index == 0)\n-        {\n-            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n-        }\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -731,9 +709,9 @@\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n             // else\n             // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n             // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n@@ -1642,16 +1620,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n+            if(_A[j] > 10.0)\n+            {\n+                _A[j] = 10.0;\n+            }\n+            else if(_A[j] < -10.0)\n+            {\n+                _A[j] = -10.0;\n+            }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690522688516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 10000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1690530132179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 10000000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -454,9 +454,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -554,16 +554,17 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost1_2 = 0.0;        \n-        double cost2_2 = 0.0;\n+        double cost3 = 0.0;\n+        double rot_cost_2 = 0.0;        \n+        double pos_cost_2 = 0.0;\n         // double cost2 = 0.0;\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            rot_cost_2 = rot_cost_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -572,19 +573,21 @@\n             // else\n             // {\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n-            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+            pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit/2)\n-        // {\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit/2-PosGap_2) * weight1;// / (gap_limit/2);\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+            // cost3 = 1000000.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+            cost3 = 0.0;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -603,64 +606,78 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(cost2_2 >  position_sec1[0])\n+        if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n+                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n             }\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n             // cost2 = (1-_manipulability[index]);\n-            if(cost1_2 >  gap_limit)\n+            if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 2000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n-            else if(cost1_2 <= gap_limit && cost1_2 > gap_limit/5)\n+            else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 1000 + weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n                 // cost2 = weight_manipul * (1-_manipulability[index]);\n             }\n             else\n             {\n-                cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 5 // cost1 = %f\\n\",cost1);\n+                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n+                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n                 }\n             }\n         }\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1 + cost2 + cost3;\n+        if(index == 0)\n+        {\n+            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n+        }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -1552,9 +1569,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(1.0,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1563,9 +1580,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(1.0,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1620,16 +1637,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            if(_A[j] > 10.0)\n-            {\n-                _A[j] = 10.0;\n-            }\n-            else if(_A[j] < -10.0)\n-            {\n-                _A[j] = -10.0;\n-            }\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n"
                },
                {
                    "date": 1690530217740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 100 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 10 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690530282576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 40000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 30000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 20000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690530325916,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n-            cost1 = 40000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 1 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -620,9 +620,9 @@\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n         {\n-            cost1 = 30000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n             if(index == 0)\n             {\n                 printf(\"// section 2 // cost1 = %f\\n\",cost1);\n                 printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -635,9 +635,9 @@\n         {\n             // cost2 = (1-_manipulability[index]);\n             if(rot_cost_2 >  position_sec1[0])\n             {\n-                cost1 = 20000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 3 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n@@ -645,9 +645,9 @@\n                 }\n             }\n             else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n             {\n-                cost1 = 10000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n                 if(index == 0)\n                 {\n                     printf(\"// section 4 // cost1 = %f\\n\",cost1);\n                     printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n"
                },
                {
                    "date": 1690530336572,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -576,18 +576,19 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-            // cost3 = 1000000.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-            cost3 = 0.0;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        //     // cost3 = 1000000.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        //     cost3 = 0.0;\n+        // }\n+        weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690530342759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -586,9 +586,9 @@\n         // {\n         //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n         //     cost3 = 0.0;\n         // }\n-        weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n+        // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690530510724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -605,9 +605,13 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n-\n+                    if(index == 0)\n+            {\n+                printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n+                printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n+            }\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n             cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690530663302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -559,8 +559,9 @@\n         double rot_cost_2 = 0.0;        \n         double pos_cost_2 = 0.0;\n         // double cost2 = 0.0;\n \n+\n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n             rot_cost_2 = rot_cost_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n@@ -576,8 +577,22 @@\n             // }\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n+\n+                            if(index == 0)\n+            {\n+                for(int i = 0 ; i<3; i++)\n+                {\n+                    printf(\"PosEE_index[%d] = %f\\n\",i,PosEE_index[i]);\n+                    printf(\"g[%d] = %f\\n\",i,g[i]);\n+                    printf(\"PosGap[%d] = %f\\n\",i,PosGap[i]);\n+                }\n+                printf(\"PosGap_2 = %f\\n\",PosGap_2);\n+                printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n+                // printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n+            }\n+\n         // if(PosGap_2 > gap_limit )\n         // {\n         //     weight1 =  0.0;\n         //     // cost3 = 1000000.0;\n@@ -605,13 +620,9 @@\n         // else\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n-                    if(index == 0)\n-            {\n-                printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n-                printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n-            }\n+\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(pos_cost_2 >  position_sec1[0])\n         {\n             cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n"
                },
                {
                    "date": 1690534143601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,20 +578,20 @@\n             pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n \n-                            if(index == 0)\n+        if(index == 0)\n+        {\n+            for(int i = 0 ; i<3; i++)\n             {\n-                for(int i = 0 ; i<3; i++)\n-                {\n-                    printf(\"PosEE_index[%d] = %f\\n\",i,PosEE_index[i]);\n-                    printf(\"g[%d] = %f\\n\",i,g[i]);\n-                    printf(\"PosGap[%d] = %f\\n\",i,PosGap[i]);\n-                }\n-                printf(\"PosGap_2 = %f\\n\",PosGap_2);\n-                printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n-                // printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n+                printf(\"PosEE_index[%d] = %f\\n\",i,PosEE_index[i]);\n+                printf(\"g[%d] = %f\\n\",i,g[i]);\n+                printf(\"PosGap[%d] = %f\\n\",i,PosGap[i]);\n             }\n+            printf(\"PosGap_2 = %f\\n\",PosGap_2);\n+            printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n+            // printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n+        }\n \n         // if(PosGap_2 > gap_limit )\n         // {\n         //     weight1 =  0.0;\n"
                },
                {
                    "date": 1690535105750,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -537,9 +537,13 @@\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n         {\n-            PosEE_index[i] = position[index*3+i];    \n+            PosEE_index[i] = position[index*3+i];\n+            if(i == 2)\n+            {\n+                PosEE_index[2] = PosEE_index[i] + 0.01;\n+            } \n         }\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n"
                },
                {
                    "date": 1690535128159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -540,9 +540,9 @@\n         {\n             PosEE_index[i] = position[index*3+i];\n             if(i == 2)\n             {\n-                PosEE_index[2] = PosEE_index[i] + 0.01;\n+                PosEE_index[2] = PosEE_index[i] - 0.01;\n             } \n         }\n \n         double RotGoalT_x_RotEE[9];\n"
                },
                {
                    "date": 1690535174847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,9 +541,10 @@\n             PosEE_index[i] = position[index*3+i];\n             if(i == 2)\n             {\n                 PosEE_index[2] = PosEE_index[i] - 0.01;\n-            } \n+            }\n+            ////////////////////이부분 체크해보기 /////////////////////////////\n         }\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n"
                },
                {
                    "date": 1690766759261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -411,34 +411,29 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain * (abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = constraint_gain *(abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n-\n         else\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n-        }    \n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n \n-\n-        if(time_step_num < _time_window-_dt2_window)\n+        if(time_step_num < 32-5)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n             }    \n-            // cost_joint_limit[index] = cost_joint_limit[index] + vel_gain * abs_cuda1(velocity[index]);\n         }\n         \n-\n-        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n@@ -454,9 +449,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n@@ -522,9 +517,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -537,14 +532,9 @@\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n         {\n-            PosEE_index[i] = position[index*3+i];\n-            if(i == 2)\n-            {\n-                PosEE_index[2] = PosEE_index[i] - 0.01;\n-            }\n-            ////////////////////이부분 체크해보기 /////////////////////////////\n+            PosEE_index[i] = position[index*3+i];    \n         }\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n@@ -559,18 +549,16 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost3 = 0.0;\n-        double rot_cost_2 = 0.0;        \n-        double pos_cost_2 = 0.0;\n+        double cost1_2 = 0.0;        \n+        double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n \n-\n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            rot_cost_2 = rot_cost_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -579,37 +567,20 @@\n             // else\n             // {\n             //     cost2_2 = cost2_2 + PosGap[i];\n             // }\n-            pos_cost_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-\n-        if(index == 0)\n+        if(PosGap_2 > gap_limit )\n         {\n-            for(int i = 0 ; i<3; i++)\n-            {\n-                printf(\"PosEE_index[%d] = %f\\n\",i,PosEE_index[i]);\n-                printf(\"g[%d] = %f\\n\",i,g[i]);\n-                printf(\"PosGap[%d] = %f\\n\",i,PosGap[i]);\n-            }\n-            printf(\"PosGap_2 = %f\\n\",PosGap_2);\n-            printf(\"pos_cost_2 = %f\\n\",pos_cost_2);\n-            // printf(\"rot_cost_2 = %f\\n\",rot_cost_2);\n+            weight1 =  0.0;\n         }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        //     // cost3 = 1000000.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-        //     cost3 = 0.0;\n-        // }\n-        // weight1 =  abs_cuda1(gap_limit - PosGap_2) * weight1;\n-\n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n         // }\n@@ -627,78 +598,32 @@\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(pos_cost_2 >  position_sec1[0])\n+        if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = 4000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 1 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 1 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 1 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(pos_cost_2 <= position_sec1[0] && pos_cost_2 > position_sec2[0])\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = 3000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-            if(index == 0)\n-            {\n-                printf(\"// section 2 // cost1 = %f\\n\",cost1);\n-                printf(\"// section 2 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                printf(\"// section 2 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-            }\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n         {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n             // cost2 = (1-_manipulability[index]);\n-            if(rot_cost_2 >  position_sec1[0])\n-            {\n-                cost1 = 2000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 3 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 3 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 3 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-            }\n-            else if(rot_cost_2 <= position_sec1[0] && rot_cost_2 > position_sec2[0])\n-            {\n-                cost1 = 1000 + weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 4 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 4 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 4 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-                // cost2 = weight_manipul * (1-_manipulability[index]);\n-            }\n-            else\n-            {\n-                cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-                if(index == 0)\n-                {\n-                    printf(\"// section 5 // cost1 = %f\\n\",cost1);\n-                    printf(\"// section 5 // rot_cost_2 = %f\\n\",weight1 * rot_cost_2);\n-                    printf(\"// section 5 // pos_cost_2 = %f\\n\",weight2 * pos_cost_2);\n-                }\n-            }\n         }\n-        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n-        // cost1 = weight2 * pos_cost_2 + weight1 * rot_cost_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2 + cost3;\n-        if(index == 0)\n-        {\n-            printf(\"// ALL // f[0] = %f\\n\\n\",f[0]);\n-        }\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -1658,16 +1583,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n+            if(_A[j] > 10.0)\n+            {\n+                _A[j] = 10.0;\n+            }\n+            else if(_A[j] < -10.0)\n+            {\n+                _A[j] = -10.0;\n+            }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n@@ -1947,9 +1872,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 1.2;\n+    velocity_lim[0] = 1.5;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690766912861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -424,9 +424,9 @@\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n \n-        if(time_step_num < 32-5)\n+        if(time_step_num < _time_window-_dt2_window)\n         {\n             if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n             {\n                 cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n"
                },
                {
                    "date": 1690767031423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690767067626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 800.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690767089809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 800.0;//pow(10,6)\n+    double vel_gain = 700.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690767140711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -532,9 +532,13 @@\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n         {\n-            PosEE_index[i] = position[index*3+i];    \n+            PosEE_index[i] = position[index*3+i];\n+            if(i == 2) \n+            {\n+                PosEE_index[i] = PosEE_index[i] -0.01;\n+            }\n         }\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n"
                },
                {
                    "date": 1690767166263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -535,9 +535,9 @@\n         {\n             PosEE_index[i] = position[index*3+i];\n             if(i == 2) \n             {\n-                PosEE_index[i] = PosEE_index[i] -0.01;\n+                PosEE_index[i] = PosEE_index[i] - 0.01;\n             }\n         }\n \n         double RotGoalT_x_RotEE[9];\n"
                },
                {
                    "date": 1690767263333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 700.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690767354206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -449,9 +449,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690767413427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,9 +517,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690767436567,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,9 +517,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690767470347,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -449,9 +449,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690767618064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -625,9 +625,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690783221736,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,9 +517,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 100000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690783267323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,9 +517,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1690783282095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -574,16 +574,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690783597501,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -449,9 +449,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 500.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690783742045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -574,16 +574,17 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+            cost3 = 1000000.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690783747976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -553,8 +553,9 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n+        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n \n"
                },
                {
                    "date": 1690783753356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -627,9 +627,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2;\n+        f[index] = cost1+cost3;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690783822015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,9 +578,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 1000000.0;\n+            cost3 = 100000.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690783858574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 10000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n@@ -578,9 +578,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 100000.0;\n+            // cost3 = 100000.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1690783875876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,8 +578,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n+            weight2 = weight2 * 10.0;\n             // cost3 = 100000.0;\n         }\n         else\n         {\n@@ -627,9 +628,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1+cost3;// + cost2;\n+        f[index] = cost1;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690783934406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,9 +578,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            weight2 = weight2 * 10.0;\n+            weight2 = weight2 * 5.0;\n             // cost3 = 100000.0;\n         }\n         else\n         {\n"
                },
                {
                    "date": 1690783942265,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,9 +577,9 @@\n         }\n \n         if(PosGap_2 > gap_limit )\n         {\n-            weight1 =  0.0;\n+            weight1 =  weight1 / 5.0;\n             weight2 = weight2 * 5.0;\n             // cost3 = 100000.0;\n         }\n         else\n"
                },
                {
                    "date": 1690783991496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,18 +575,18 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n+        if(PosGap_2 > cost1_2 )\n         {\n             weight1 =  weight1 / 5.0;\n             weight2 = weight2 * 5.0;\n             // cost3 = 100000.0;\n         }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n"
                },
                {
                    "date": 1690784059295,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -577,10 +577,10 @@\n         }\n \n         if(PosGap_2 > cost1_2 )\n         {\n-            weight1 =  weight1 / 5.0;\n-            weight2 = weight2 * 5.0;\n+            weight1 =  weight1 / 2.0;\n+            weight2 = weight2 * 2.0;\n             // cost3 = 100000.0;\n         }\n         // else\n         // {\n"
                },
                {
                    "date": 1690784093269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,18 +575,17 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > cost1_2 )\n+        if(PosGap_2 > gap_limit )\n         {\n-            weight1 =  weight1 / 2.0;\n-            weight2 = weight2 * 2.0;\n-            // cost3 = 100000.0;\n+            weight1 =  0.0;\n+            cost3 = 100000.0;\n         }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -628,9 +627,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2;\n+        f[index] = cost1+cost3;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690784098673,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -578,9 +578,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = 100000.0;\n+            // cost3 = 100000.0;\n         }\n         else\n         {\n             weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n@@ -627,9 +627,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1+cost3;// + cost2;\n+        f[index] = cost;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690784133622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -575,17 +575,17 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            weight1 =  0.0;\n-            // cost3 = 100000.0;\n-        }\n-        else\n-        {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     weight1 =  0.0;\n+        //     // cost3 = 100000.0;\n+        // }\n+        // else\n+        // {\n+        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -627,9 +627,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost;// + cost2;\n+        f[index] = cost1;// + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1690784161219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -449,9 +449,9 @@\n         // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }        \n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1690784252908,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n     int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 10000000.0;//pow(10,6)\n+    double constraint_gain = 1000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1690784350453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,12 +361,11 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n-    int time_step_num = index3 % _time_window;\n \n-    double constraint_gain = 1000000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n@@ -411,29 +410,24 @@\n     // else\n     // {\n         if(position[index] <= min_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (1 + abs_cuda2(position[index],min_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n         }\n \n         else if(position[index] >= max_joint_limit[joint_num])\n         {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain *(1 + abs_cuda2(position[index],max_joint_limit[joint_num]));\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n             // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n         }\n         else\n         {\n             cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n         }\n-\n-        if(time_step_num < _time_window-_dt2_window)\n+        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n         {\n-            if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n-            {\n-                cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n-            }    \n+            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n         }\n-        \n         // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n         // {\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }\n@@ -442,17 +436,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        // if(joint_num < 5)\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n+        if(joint_num < 5)\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }\n+        else\n+        {\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }        \n     // }\n     __syncthreads();\n }\n \n@@ -517,9 +511,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n@@ -532,13 +526,9 @@\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n         {\n-            PosEE_index[i] = position[index*3+i];\n-            if(i == 2) \n-            {\n-                PosEE_index[i] = PosEE_index[i] - 0.01;\n-            }\n+            PosEE_index[i] = position[index*3+i];    \n         }\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n@@ -553,9 +543,8 @@\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n         double cost2 = 0.0;\n-        double cost3 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         // double cost2 = 0.0;\n \n@@ -575,17 +564,16 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     weight1 =  0.0;\n-        //     // cost3 = 100000.0;\n-        // }\n-        // else\n-        // {\n-        //     weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            weight1 =  0.0;\n+        }\n+        else\n+        {\n+            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -627,9 +615,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1;// + cost2;\n+        f[index] = cost1 + cost2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -672,16 +660,16 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            // if(joint_num>=4)\n-            // {\n-            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            // }\n-            // else\n-            // {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            // }            \n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n@@ -1589,16 +1577,16 @@\n         for(int j = 0; j<_JDOF; j++)\n         {\n             _weighted_A[j] /=  weight_sum;\n             _A[j] = _weighted_A[j];\n-            if(_A[j] > 10.0)\n-            {\n-                _A[j] = 10.0;\n-            }\n-            else if(_A[j] < -10.0)\n-            {\n-                _A[j] = -10.0;\n-            }\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n         }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n@@ -1878,9 +1866,9 @@\n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n-    velocity_lim[0] = 1.5;\n+    velocity_lim[0] = 0.8;\n \n     // position_sec1[0] = 0.03125;\n     // position_sec2[0] = 0.00625;\n     // velocity_lim[0] = 1.0;\n"
                },
                {
                    "date": 1690784557798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690784589150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1690784634517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -526,10 +526,11 @@\n \n         double PosEE_index[3];\n         for(int i = 0; i<3; i++)\n         {\n-            PosEE_index[i] = position[index*3+i];    \n+            PosEE_index[i] = position[index*3+i];\n         }\n+        PosEE_index[2] = PosEE_index[i] - 0.01;\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n \n"
                },
                {
                    "date": 1690867622842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -528,9 +528,9 @@\n         for(int i = 0; i<3; i++)\n         {\n             PosEE_index[i] = position[index*3+i];\n         }\n-        PosEE_index[2] = PosEE_index[i] - 0.01;\n+        PosEE_index[2] = PosEE_index[2] - 0.01;\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n \n"
                },
                {
                    "date": 1690867633365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,16 +364,16 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 500.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    }\n+    // if(now_gap[0] > gap_limit )\n+    // {\n+    //     vel_gain =  0.0;\n+    // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    // }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1690867773784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n"
                },
                {
                    "date": 1690867845294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,17 +363,17 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n-    // if(now_gap[0] > gap_limit )\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-    // }\n+    double vel_gain = 500.0;//pow(10,6)\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+    }\n     \n \n     cost_joint_limit[index]=0.0;\n \n"
                },
                {
                    "date": 1691113473365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,9 +511,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1691113584049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -571,9 +571,9 @@\n             weight1 =  0.0;\n         }\n         else\n         {\n-            weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+            // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n         }\n \n         // if(cost1_2 > 1)\n         // {\n"
                },
                {
                    "date": 1691113611240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -546,8 +546,9 @@\n         double cost1 = 0.0;\n         double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n+        double cost3 = 0.0;\n         // double cost2 = 0.0;\n \n         for(int i = 0;i<3; i++)\n         {\n"
                },
                {
                    "date": 1691113620241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -553,8 +553,10 @@\n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n             cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+\n             PosGap_2 += abs(PosGap[i]);\n \n             // if(PosGap[i] > 1)\n             // {\n@@ -569,8 +571,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n+            cost3 = \n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1691113635157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -552,9 +552,9 @@\n \n         for(int i = 0;i<3; i++)\n         {\n             PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n             // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n \n             PosGap_2 += abs(PosGap[i]);\n \n@@ -571,9 +571,9 @@\n \n         if(PosGap_2 > gap_limit )\n         {\n             weight1 =  0.0;\n-            cost3 = \n+            cost3 = weight1 * 10.0;\n         }\n         else\n         {\n             // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1691113645988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -573,12 +573,12 @@\n         {\n             weight1 =  0.0;\n             cost3 = weight1 * 10.0;\n         }\n-        else\n-        {\n-            // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        }\n+        // else\n+        // {\n+        //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n \n         // if(cost1_2 > 1)\n         // {\n         //     cost1_2 = pow2_cuda(cost1_2);\n@@ -620,9 +620,9 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2;\n+        f[index] = cost1 + cost2 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1691113724596,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -570,10 +570,10 @@\n         }\n \n         if(PosGap_2 > gap_limit )\n         {\n-            weight1 =  0.0;\n             cost3 = weight1 * 10.0;\n+            weight1 =  0.0;            \n         }\n         // else\n         // {\n         //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n"
                },
                {
                    "date": 1691113784935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 100000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1691113878900,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -362,9 +362,9 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 1000000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1691113925721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -362,9 +362,9 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 1000000.0;//pow(10,6)\n+    double constraint_gain = 100000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n"
                },
                {
                    "date": 1691113991799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -362,17 +362,18 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 100000.0;//pow(10,6)\n+    double constraint_gain = 500000.0;//pow(10,6)\n     double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n         vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n+        vel_gain =  abs_cuda1(1-now_gap[0]/) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1691114019658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,17 +363,16 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 500000.0;//pow(10,6)\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n     else\n     {\n-        vel_gain =  abs_cuda1(gap_limit-now_gap[0]) * vel_gain;\n-        vel_gain =  abs_cuda1(1-now_gap[0]/) * vel_gain;\n+        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n     }\n     \n \n     cost_joint_limit[index]=0.0;\n"
                },
                {
                    "date": 1691114248217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,9 +511,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1691114319880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -570,9 +570,9 @@\n         }\n \n         if(PosGap_2 > gap_limit )\n         {\n-            cost3 = weight1 * 10.0;\n+            cost3 = weight1 * 3.14*3;\n             weight1 =  0.0;            \n         }\n         // else\n         // {\n"
                },
                {
                    "date": 1691114347704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,9 +511,9 @@\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 50000.0; // 10000.0 (10.0) // rot\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1691114390772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,9 +363,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 500000.0;//pow(10,6)\n-    double vel_gain = 500.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1691114723453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -665,16 +665,17 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            if(joint_num>=4)\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            }\n-            else\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            }            \n+            _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            // if(joint_num>=4)\n+            // {\n+            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            // }\n+            // else\n+            // {\n+            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            // }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1691114963473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,17 +436,18 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 5)\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }\n-        else\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }        \n+        // if(joint_num < 5)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n+        cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1691114976945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -621,9 +621,10 @@\n         if(sqrt(_manipulability[index])<= 0.1)\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n-        f[index] = cost1 + cost2 + cost3;\n+        // f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n"
                },
                {
                    "date": 1691115075787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -571,9 +571,9 @@\n         }\n \n         if(PosGap_2 > gap_limit )\n         {\n-            cost3 = weight1 * 3.14*3;\n+            cost3 = weight1 * 3.14 * 3 * 2;\n             weight1 =  0.0;            \n         }\n         // else\n         // {\n"
                },
                {
                    "date": 1691115283252,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1557,15 +1557,17 @@\n         }\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n+        _sol_cost = 0.0;\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n                 _min_cost = _cost[i];\n+                _sol_cost = i;\n             }\n         }\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n"
                },
                {
                    "date": 1691115321823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1565,11 +1565,11 @@\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n                 _min_cost = _cost[i];\n-                _sol_cost = i;\n             }\n         }\n+        _sol_cost = _min_cost;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n"
                },
                {
                    "date": 1691115353679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1557,9 +1557,9 @@\n         }\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n-        _sol_cost = 0.0;\n+        // _sol_cost = 0.0;\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n@@ -1873,8 +1873,9 @@\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n     // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n+    _sol_cost = 0.0;\n \n     position_sec1[0] = 0.03125;\n     position_sec2[0] = 0.005;\n     velocity_lim[0] = 0.8;\n"
                },
                {
                    "date": 1691115424350,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1157,33 +1157,45 @@\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n-    if(found_goal == 1)\n+    ////////////////////////////////////////////////////////////////\n+    // if(found_goal == 1)\n+    // {\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.7;\n+    //     }\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = 0.7;\n+    // }\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.7)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n+    //////////////////////////////////////////////////////////////\n+\n+    if(_sol_cost > 0.5)\n     {\n-        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-        {\n-            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-        }\n-        else if(now_pos_gap[0] <= position_sec2[0])\n-        {\n-            _dt_cuda2[0] = _dt_cuda;\n-        }\n-        else if(now_pos_gap[0] >= 1.0)\n-        {\n-            _dt_cuda2[0] = 0.7;\n-        }\n+\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        \n     }\n-    found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n-    {\n-        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    }\n+    cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n"
                },
                {
                    "date": 1691115441871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,16 +1185,16 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n \n-    if(_sol_cost > 0.5)\n-    {\n+    // if(_sol_cost > 0.5)\n+    // {\n \n-    }\n-    else\n-    {\n+    // }\n+    // else\n+    // {\n         \n-    }\n+    // }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n"
                },
                {
                    "date": 1691115554313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,16 +1185,16 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n \n-    // if(_sol_cost > 0.5)\n-    // {\n-\n-    // }\n-    // else\n-    // {\n-        \n-    // }\n+    if(_sol_cost > 10000)\n+    {\n+        _dt_cuda2[0] = 0.7;\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n"
                },
                {
                    "date": 1691115605847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,9 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n     }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691115669441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,10 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+        // _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+        _dt_cuda2[0] = 0.003;\n     }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691115689709,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,9 +1185,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n \n-    if(_sol_cost > 10000)\n+    if(_sol_cost > 100000)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n     else\n"
                },
                {
                    "date": 1691115714002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,9 +1185,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n \n-    if(_sol_cost > 100000)\n+    if(_sol_cost > 1000000)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n     else\n"
                },
                {
                    "date": 1691115920097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1189,9 +1189,9 @@\n     if(_sol_cost > 1000000)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n-    else\n+    else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n         // _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n         _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691115927840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,13 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n-        // _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+        _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+        // _dt_cuda2[0] = 0.003;\n+    }\n+    else\n+    {\n         _dt_cuda2[0] = 0.003;\n     }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n"
                },
                {
                    "date": 1691115942273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1196,9 +1196,9 @@\n         // _dt_cuda2[0] = 0.003;\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.003;\n+        _dt_cuda2[0] = _dt_cuda;\n     }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691115957765,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,8 +1192,10 @@\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n         _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+                // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n     else\n     {\n"
                },
                {
                    "date": 1691115979098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,10 +1191,10 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n-        _dt_cuda2[0] = -10000 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n-                // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+                _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n     else\n"
                },
                {
                    "date": 1691116003797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1192,10 +1192,10 @@\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n-                _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n     else\n     {\n"
                },
                {
                    "date": 1691116031582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,9 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(6000,2))*pow(_sol_cost-10000,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000,2))*pow(_sol_cost-10000,2)+0.7;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691116045136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1191,9 +1191,9 @@\n         _dt_cuda2[0] = 0.7;\n     }\n     else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000,2))*pow(_sol_cost-10000,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000-1000000,2))*pow(_sol_cost-1000000,2)+0.7;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691116071968,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1201,8 +1201,9 @@\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n     cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n+    cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n"
                },
                {
                    "date": 1691116137152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,15 +1185,15 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n \n-    if(_sol_cost > 1000000)\n+    if(_sol_cost > 800000)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n-    else if(_sol_cost <= 1000000 && _sol_cost > 5000)\n+    else if(_sol_cost <= 800000 && _sol_cost > 5000)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000-1000000,2))*pow(_sol_cost-1000000,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000-800000,2))*pow(_sol_cost-800000,2)+0.7;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691116193425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1184,8 +1184,9 @@\n     // {\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n+    _sol_cost = _sol_cost / 5000;\n \n     if(_sol_cost > 800000)\n     {\n         _dt_cuda2[0] = 0.7;\n"
                },
                {
                    "date": 1691116217194,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,16 +1185,17 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n     _sol_cost = _sol_cost / 5000;\n+    200/\n \n-    if(_sol_cost > 800000)\n+    if(_sol_cost > 200)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n-    else if(_sol_cost <= 800000 && _sol_cost > 5000)\n+    else if(_sol_cost <= 200 && _sol_cost > 1)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(5000-800000,2))*pow(_sol_cost-800000,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(1-200,2))*pow(_sol_cost-200,2)+0.7;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691116250404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1185,17 +1185,17 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n     _sol_cost = _sol_cost / 5000;\n-    200/\n+    // 200/\n \n-    if(_sol_cost > 200)\n+    if(_sol_cost > 700)\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n-    else if(_sol_cost <= 200 && _sol_cost > 1)\n+    else if(_sol_cost <= 700 && _sol_cost > 1)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(1-200,2))*pow(_sol_cost-200,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.7;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691117162764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1189,13 +1189,13 @@\n     // 200/\n \n     if(_sol_cost > 700)\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 1.0;\n     }\n     else if(_sol_cost <= 700 && _sol_cost > 1)\n     {\n-        _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.7;\n+        _dt_cuda2[0] = -1 * ((1.0-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+1.0;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691117187207,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1189,13 +1189,13 @@\n     // 200/\n \n     if(_sol_cost > 700)\n     {\n-        _dt_cuda2[0] = 1.0;\n+        _dt_cuda2[0] = 0.5;\n     }\n     else if(_sol_cost <= 700 && _sol_cost > 1)\n     {\n-        _dt_cuda2[0] = -1 * ((1.0-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+1.0;\n+        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n             //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n             // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         // _dt_cuda2[0] = 0.003;\n     }\n"
                },
                {
                    "date": 1691117492716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,18 +436,18 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        // if(joint_num < 5)\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n-        cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        if(joint_num < 5)\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }\n+        else\n+        {\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }        \n+        // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n     // }\n     __syncthreads();\n }\n \n"
                },
                {
                    "date": 1691117612263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -438,9 +438,9 @@\n         // }  \n \n         if(joint_num < 5)\n         {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1691117769066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -667,9 +667,9 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691118242718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,9 +436,9 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 5)\n+        if(joint_num < 4)\n         {\n             // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n         else\n"
                },
                {
                    "date": 1691484248496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1146,8 +1146,10 @@\n \n void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n     // _dt_cuda2[0] = 0.5;\n+\n+    cout<<_goal_pos_cuda.transpose()<<endl;\n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n"
                },
                {
                    "date": 1691484277118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1146,10 +1146,13 @@\n \n void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n     // _dt_cuda2[0] = 0.5;\n-\n-    cout<<_goal_pos_cuda.transpose()<<endl;\n+    for(int i = 0; i<6; i++)\n+    {\n+        cout<<_goal_pos_cuda[i]<<endl;    \n+    }\n+    \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n"
                },
                {
                    "date": 1691484304044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1207,10 +1207,10 @@\n     else\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n-    cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n-    cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n+    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n     for(int i = 0; i<_JDOF; i++)\n     {\n"
                },
                {
                    "date": 1691484325587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1146,12 +1146,12 @@\n \n void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n     // _dt_cuda2[0] = 0.5;\n-    for(int i = 0; i<6; i++)\n-    {\n-        cout<<_goal_pos_cuda[i]<<endl;    \n-    }\n+    // for(int i = 0; i<6; i++)\n+    // {\n+    //     cout<<_goal_pos_cuda[i]<<endl;    \n+    // }\n     \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n     for(int i = 0; i<3; i++)\n"
                },
                {
                    "date": 1691484356045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1623,8 +1623,13 @@\n             // {\n             //     _A[j] = -10.0;\n             // }\n         }\n+\n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            cout<<_weighted_A[i]<<endl;    \n+        }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n             returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n"
                },
                {
                    "date": 1691484375406,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1624,12 +1624,12 @@\n             //     _A[j] = -10.0;\n             // }\n         }\n \n-        for(int i = 0; i<_JDOF; i++)\n-        {\n-            cout<<_weighted_A[i]<<endl;    \n-        }\n+        // for(int i = 0; i<_JDOF; i++)\n+        // {\n+        //     cout<<_weighted_A[i]<<endl;    \n+        // }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n             returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n"
                },
                {
                    "date": 1691484393217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1503,12 +1503,12 @@\n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // for(int i = 0; i<_sampling_num * _time_window; i++)\n-        // {\n-        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n-        // }\n+        for(int i = 0; i<_sampling_num * _time_window; i++)\n+        {\n+            cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n+        }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n"
                },
                {
                    "date": 1691484409668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1503,12 +1503,12 @@\n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        for(int i = 0; i<_sampling_num * _time_window; i++)\n-        {\n-            cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n-        }\n+        // for(int i = 0; i<_sampling_num * _time_window; i++)\n+        // {\n+        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n+        // }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n"
                },
                {
                    "date": 1691484418737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1395,9 +1395,9 @@\n                 {\n                     _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                 }                \n             }\n-            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+            cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691484424507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1395,9 +1395,9 @@\n                 {\n                     _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                 }                \n             }\n-            cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691484439058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1395,9 +1395,9 @@\n                 {\n                     _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                 }                \n             }\n-            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+            cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691484455289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1395,9 +1395,9 @@\n                 {\n                     _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                 }                \n             }\n-            cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691484511655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -668,8 +668,9 @@\n         // }\n         // else\n         // {\n             _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            printf(\"_matrix_for_cuda[index] : %d\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691484536429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -668,9 +668,8 @@\n         // }\n         // else\n         // {\n             _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            printf(\"_matrix_for_cuda[index] : %d\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691484572450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -668,8 +668,9 @@\n         // }\n         // else\n         // {\n             _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            printf(\"_matrix_for_cuda[index] : %d\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691486246775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,11 @@\n \n #define THREADS_PER_BLOCK _sampling_num\n #define THREADS_PER_BLOCK2 _sampling_num\n \n+device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n \n+\n CudaTest::CudaTest(void)\n {   \n     cpu_memory_save();\n     cuda_memory_save();\n"
                },
                {
                    "date": 1691486282457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n #define THREADS_PER_BLOCK _sampling_num\n #define THREADS_PER_BLOCK2 _sampling_num\n \n-device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n+device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n CudaTest::CudaTest(void)\n {   \n"
                },
                {
                    "date": 1691486291320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \n #define THREADS_PER_BLOCK _sampling_num\n #define THREADS_PER_BLOCK2 _sampling_num\n \n-device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n+// device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n CudaTest::CudaTest(void)\n {   \n"
                },
                {
                    "date": 1691564821464,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1903,8 +1903,9 @@\n }\n \n void CudaTest::initialize()\n {\n+    cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl;<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n"
                },
                {
                    "date": 1691564833238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1903,8 +1903,9 @@\n }\n \n void CudaTest::initialize()\n {\n+    coud<<endl;\n     cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl;<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n"
                },
                {
                    "date": 1691564845186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1903,9 +1903,9 @@\n }\n \n void CudaTest::initialize()\n {\n-    coud<<endl;\n+    cout<<endl;\n     cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl;<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n"
                },
                {
                    "date": 1691564852901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1904,9 +1904,9 @@\n \n void CudaTest::initialize()\n {\n     cout<<endl;\n-    cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl;<<endl;\n+    cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n"
                },
                {
                    "date": 1691564909200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -670,9 +670,9 @@\n         // }\n         // else\n         // {\n             _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            printf(\"_matrix_for_cuda[index] : %d\\n\",_matrix_for_cuda[index]);\n+            printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691564919619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -546,9 +546,9 @@\n         matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n-        double cost2 = 0.0;\n+        // double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         double cost3 = 0.0;\n         // double cost2 = 0.0;\n"
                },
                {
                    "date": 1691564947061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -546,9 +546,9 @@\n         matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n         rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n \n         double cost1 = 0.0;\n-        // double cost2 = 0.0;\n+        double cost2 = 0.0;\n         double cost1_2 = 0.0;        \n         double cost2_2 = 0.0;\n         double cost3 = 0.0;\n         // double cost2 = 0.0;\n"
                },
                {
                    "date": 1691565080942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1771,8 +1771,9 @@\n }\n \n void CudaTest::cuda_memory_save()\n {\n+    cout<<\":::::::::::::CUDA Memory Save:::::::::::::\"<<endl<<endl;\n     cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n     cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n     // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n@@ -1842,8 +1843,9 @@\n }\n \n void CudaTest::cuda_memory_free()\n {    \n+    cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n     cudaFree(dev__A);\n     cudaFree(dev__mean_matrix);\n     cudaFree(dev__matrix_for_cuda);\n     // cudaFree(dev__prev_matrix_for_cuda);\n@@ -1903,10 +1905,10 @@\n }\n \n void CudaTest::initialize()\n {\n-    cout<<endl;\n-    cout<<\":::::::::::::CUDA INITIALIZE:::::::::::::\"<<endl<<endl;\n+    // cout<<endl;\n+    cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n"
                },
                {
                    "date": 1691565108684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1717,8 +1717,9 @@\n }\n \n void CudaTest::cpu_memory_save()\n {\n+    cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n     memset(cost_jointlimit, 0, N * sizeof(double));\n     memset(_mean_matrix, 0, N * sizeof(double));\n     memset(d, 0, N * sizeof(double));\n     memset(e, 0, N * sizeof(double));\n@@ -1771,9 +1772,9 @@\n }\n \n void CudaTest::cuda_memory_save()\n {\n-    cout<<\":::::::::::::CUDA Memory Save:::::::::::::\"<<endl<<endl;\n+    cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n     cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n     cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n     // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n"
                },
                {
                    "date": 1691565150776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1148,8 +1148,9 @@\n }\n \n void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n+    cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n     // {\n     //     cout<<_goal_pos_cuda[i]<<endl;    \n"
                },
                {
                    "date": 1691565200761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1148,9 +1148,9 @@\n }\n \n void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n-    cout<<\"cuda code start\"<<endl;\n+    // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n     // {\n     //     cout<<_goal_pos_cuda[i]<<endl;    \n"
                },
                {
                    "date": 1691565800209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1384,8 +1384,13 @@\n     }\n \n     else if(control_mode == 1)\n     {\n+        for(int i= 0; i<7; i++)\n+        {\n+            cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n+        }\n+        \n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1691565844657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1384,12 +1384,12 @@\n     }\n \n     else if(control_mode == 1)\n     {\n-        for(int i= 0; i<7; i++)\n-        {\n-            cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n-        }\n+        // for(int i= 0; i<7; i++)\n+        // {\n+        //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n+        // }\n         \n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n"
                },
                {
                    "date": 1691565864601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n+#include \"cuda.cuh\"\n #include <cuda_runtime.h>\n #include <device_launch_parameters.h>\n-#include \"cuda.cuh\"\n+// #include \"cuda.cuh\"\n \n #define THREADS_PER_BLOCK _sampling_num\n #define THREADS_PER_BLOCK2 _sampling_num\n \n"
                },
                {
                    "date": 1691566062854,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,10 +2,10 @@\n #include <cuda_runtime.h>\n #include <device_launch_parameters.h>\n // #include \"cuda.cuh\"\n \n-#define THREADS_PER_BLOCK _sampling_num\n-#define THREADS_PER_BLOCK2 _sampling_num\n+#define THREADS_PER_BLOCK __sampling_num\n+#define THREADS_PER_BLOCK2 __sampling_num\n \n // device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n@@ -243,9 +243,9 @@\n     // int index2 = index/_time_window;\n     int index3 = index*6*_JDOF;\n     // double theta[7];\n \n-    if(index<_sampling_num )\n+    if(index<__sampling_num )\n     {\n         \n         // for(int i = 0; i<_JDOF;)\n         // {\n@@ -519,9 +519,9 @@\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n-    if(index < _sampling_num * _time_window)\n+    if(index < __sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n@@ -775,9 +775,9 @@\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n \n-    if(index < _sampling_num)\n+    if(index < __sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double transformationMatrix[16];\n@@ -1023,9 +1023,9 @@\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n     \n-    if (tid < _sampling_num) {\n+    if (tid < __sampling_num) {\n         for (int j = 0; j < _nodes_cuda; j++) {\n             hidden0[j] = 0.0;\n         }\n     \n@@ -1074,9 +1074,9 @@\n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n-    if (index < _JDOF * _sampling_num)\n+    if (index < _JDOF * __sampling_num)\n     {\n         inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n \n         if (inputs[index] > 1)\n@@ -1093,9 +1093,9 @@\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    if(index < _sampling_num)\n+    if(index < __sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n@@ -1237,14 +1237,14 @@\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n     dim3 blockDim(N/_time_window, 1, 1);\n     dim3 gridDim(_time_window, 1, 1);\n-    dim3 gridDim2(_sampling_num, 1);\n+    dim3 gridDim2(__sampling_num, 1);\n     dim3 blockDim2(1, 1);\n     dim3 blockSize(1, 1);\n     dim3 gridSize(1, 1);\n     dim3 blockSize2(1, 1);\n-    dim3 gridSize2(_sampling_num * _time_window, 1);\n+    dim3 gridSize2(__sampling_num * _time_window, 1);\n \n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n@@ -1312,12 +1312,12 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n \n         \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();    \n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1335,9 +1335,9 @@\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1345,9 +1345,9 @@\n             }\n         }\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1441,11 +1441,11 @@\n         cudaDeviceSynchronize();\n \n         // cout<<\"222222222222222222222222\"<<endl;\n         // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         // cudaDeviceSynchronize();\n-        // for(int k = 0 ;k <_sampling_num; k++)\n+        // for(int k = 0 ;k <__sampling_num; k++)\n         // {\n         //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n         //     for(int i = 0; i<42; i++)\n         //     {\n@@ -1459,12 +1459,12 @@\n         //         }            \n         //     }\n         // }        \n         \n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n-        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(manipulability, dev_manipulability, __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n \n \n         // cout<<\"CUDA manipulability\"<<endl;\n         // for(int i = 0; i<N/_JDOF; i++)\n@@ -1475,16 +1475,16 @@\n         cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n \n         prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n-        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        computeForwardKinematics <<<N/__sampling_num, __sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n         cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n \n-        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaMemcpy(position_EE, dev_position_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1498,10 +1498,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/__sampling_num, __sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n@@ -1511,21 +1511,21 @@\n \n \n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n-        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(cost_xerr, dev_cost_x, __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // for(int i = 0; i<_sampling_num * _time_window; i++)\n+        // for(int i = 0; i<__sampling_num * _time_window; i++)\n         // {\n         //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n         // }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n         calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * __sampling_num; i++)\n         // {\n         //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n         // }\n         cudaDeviceSynchronize();\n@@ -1536,20 +1536,20 @@\n         cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n-        // for(int i = 0; i<_sampling_num; i++)\n+        // for(int i = 0; i<__sampling_num; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n         //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n         //     }\n         // }\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1596,9 +1596,9 @@\n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n         // _sol_cost = 0.0;\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1607,9 +1607,9 @@\n         }\n         _sol_cost = _min_cost;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<__sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1732,19 +1732,19 @@\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n \n-    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(position_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n \n     memset(FK_d, 0, 9 * sizeof(double));\n     memset(FK_a, 0, 9 * sizeof(double));\n     memset(FK_alpha, 0, 9 * sizeof(double));\n     \n-    memset(_return_cost, 0, _sampling_num * sizeof(double));\n-    memset(_cost, 0, _sampling_num * sizeof(double));\n+    memset(_return_cost, 0, __sampling_num * sizeof(double));\n+    memset(_cost, 0, __sampling_num * sizeof(double));\n \n     memset(_max_joint_position, 0, _JDOF * sizeof(double));\n     memset(_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_q_des, 0, _JDOF * sizeof(double));\n@@ -1753,24 +1753,24 @@\n     memset(_weighted_A, 0, _JDOF * sizeof(double));\n     memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n     \n-    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n+    memset(inputs, 0, _JDOF * __sampling_num * sizeof(double));\n     memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n     memset(weights1, 0, _nodes_cuda * sizeof(double));\n     memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n     memset(weights3, 0, _nodes_cuda * sizeof(double));\n     memset(weights4, 0, _nodes_cuda * sizeof(double));\n     // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n-    memset(outputs, 0, _sampling_num * sizeof(double));\n+    memset(outputs, 0, __sampling_num * sizeof(double));\n     memset(returnArray, 0, _JDOF*3 * sizeof(double));\n \n     memset(_prev_x, 0, 3 * sizeof(double));\n     memset(_prev_r, 0, 3 * sizeof(double));\n \n-    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n+    memset(jacobian, 0, _JDOF * 6 * __sampling_num *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * __sampling_num *sizeof(double));\n+    memset(manipulability, 0, __sampling_num * _time_window *sizeof(double));\n \n     \n     weights5[0] = 0.0;\n     position_sec1[0] = 0.0;\n@@ -1793,9 +1793,9 @@\n     cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_d, N * sizeof(double));\n     cudaMalloc((void**)&dev_e, N * sizeof(double));\n     cudaMalloc((void**)&dev_cost, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, __sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n@@ -1805,14 +1805,14 @@\n     cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n-    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, __sampling_num * sizeof(double));\n \n     cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n     cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n \n-    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_inputs, _JDOF * __sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n@@ -1823,30 +1823,30 @@\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n \n     // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n-    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, __sampling_num * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, __sampling_num * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * __sampling_num * _time_window * sizeof(double));\n \n-    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * __sampling_num * _time_window * sizeof(double));\n \n     cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n     cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n \n     cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n \n-    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n-    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_rot_EE, 9 * __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * __sampling_num  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * __sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, __sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n-    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, __sampling_num * sizeof(double));\n \n     \n }\n \n"
                },
                {
                    "date": 1691566261289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,10 @@\n-#include \"cuda.cuh\"\n #include <cuda_runtime.h>\n #include <device_launch_parameters.h>\n-// #include \"cuda.cuh\"\n+#include \"cuda.cuh\"\n \n-#define THREADS_PER_BLOCK __sampling_num\n-#define THREADS_PER_BLOCK2 __sampling_num\n+#define THREADS_PER_BLOCK _sampling_num\n+#define THREADS_PER_BLOCK2 _sampling_num\n \n // device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n@@ -243,9 +242,9 @@\n     // int index2 = index/_time_window;\n     int index3 = index*6*_JDOF;\n     // double theta[7];\n \n-    if(index<__sampling_num )\n+    if(index<_sampling_num )\n     {\n         \n         // for(int i = 0; i<_JDOF;)\n         // {\n@@ -519,9 +518,9 @@\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n-    if(index < __sampling_num * _time_window)\n+    if(index < _sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n@@ -775,9 +774,9 @@\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n \n-    if(index < __sampling_num)\n+    if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double transformationMatrix[16];\n@@ -1023,9 +1022,9 @@\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n     \n-    if (tid < __sampling_num) {\n+    if (tid < _sampling_num) {\n         for (int j = 0; j < _nodes_cuda; j++) {\n             hidden0[j] = 0.0;\n         }\n     \n@@ -1074,9 +1073,9 @@\n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n-    if (index < _JDOF * __sampling_num)\n+    if (index < _JDOF * _sampling_num)\n     {\n         inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n \n         if (inputs[index] > 1)\n@@ -1093,9 +1092,9 @@\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    if(index < __sampling_num)\n+    if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n@@ -1237,14 +1236,14 @@\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n     dim3 blockDim(N/_time_window, 1, 1);\n     dim3 gridDim(_time_window, 1, 1);\n-    dim3 gridDim2(__sampling_num, 1);\n+    dim3 gridDim2(_sampling_num, 1);\n     dim3 blockDim2(1, 1);\n     dim3 blockSize(1, 1);\n     dim3 gridSize(1, 1);\n     dim3 blockSize2(1, 1);\n-    dim3 gridSize2(__sampling_num * _time_window, 1);\n+    dim3 gridSize2(_sampling_num * _time_window, 1);\n \n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n@@ -1312,12 +1311,12 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n \n         \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();    \n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1335,9 +1334,9 @@\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1345,9 +1344,9 @@\n             }\n         }\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1441,11 +1440,11 @@\n         cudaDeviceSynchronize();\n \n         // cout<<\"222222222222222222222222\"<<endl;\n         // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         // cudaDeviceSynchronize();\n-        // for(int k = 0 ;k <__sampling_num; k++)\n+        // for(int k = 0 ;k <_sampling_num; k++)\n         // {\n         //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n         //     for(int i = 0; i<42; i++)\n         //     {\n@@ -1459,12 +1458,12 @@\n         //         }            \n         //     }\n         // }        \n         \n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n-        // cudaMemcpy(manipulability, dev_manipulability, __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n \n \n         // cout<<\"CUDA manipulability\"<<endl;\n         // for(int i = 0; i<N/_JDOF; i++)\n@@ -1475,16 +1474,16 @@\n         cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n \n         prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n-        computeForwardKinematics <<<N/__sampling_num, __sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n         cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n \n-        cudaMemcpy(position_EE, dev_position_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1498,10 +1497,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/__sampling_num, __sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n@@ -1511,21 +1510,21 @@\n \n \n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n-        cudaMemcpy(cost_xerr, dev_cost_x, __sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // for(int i = 0; i<__sampling_num * _time_window; i++)\n+        // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n         //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n         // }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n         calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_JDOF * __sampling_num; i++)\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n         // {\n         //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n         // }\n         cudaDeviceSynchronize();\n@@ -1536,20 +1535,20 @@\n         cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, __sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n-        // for(int i = 0; i<__sampling_num; i++)\n+        // for(int i = 0; i<_sampling_num; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n         //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n         //     }\n         // }\n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1596,9 +1595,9 @@\n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n         // _sol_cost = 0.0;\n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1607,9 +1606,9 @@\n         }\n         _sol_cost = _min_cost;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<__sampling_num; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1732,19 +1731,19 @@\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n \n-    memset(position_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n-    memset(orientation_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n-    memset(velocity_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n-    memset(velocity_ori_EE, 0, 3 * __sampling_num * _time_window * sizeof(double));\n+    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n \n     memset(FK_d, 0, 9 * sizeof(double));\n     memset(FK_a, 0, 9 * sizeof(double));\n     memset(FK_alpha, 0, 9 * sizeof(double));\n     \n-    memset(_return_cost, 0, __sampling_num * sizeof(double));\n-    memset(_cost, 0, __sampling_num * sizeof(double));\n+    memset(_return_cost, 0, _sampling_num * sizeof(double));\n+    memset(_cost, 0, _sampling_num * sizeof(double));\n \n     memset(_max_joint_position, 0, _JDOF * sizeof(double));\n     memset(_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_q_des, 0, _JDOF * sizeof(double));\n@@ -1753,24 +1752,24 @@\n     memset(_weighted_A, 0, _JDOF * sizeof(double));\n     memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n     \n-    memset(inputs, 0, _JDOF * __sampling_num * sizeof(double));\n+    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n     memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n     memset(weights1, 0, _nodes_cuda * sizeof(double));\n     memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n     memset(weights3, 0, _nodes_cuda * sizeof(double));\n     memset(weights4, 0, _nodes_cuda * sizeof(double));\n     // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n-    memset(outputs, 0, __sampling_num * sizeof(double));\n+    memset(outputs, 0, _sampling_num * sizeof(double));\n     memset(returnArray, 0, _JDOF*3 * sizeof(double));\n \n     memset(_prev_x, 0, 3 * sizeof(double));\n     memset(_prev_r, 0, 3 * sizeof(double));\n \n-    memset(jacobian, 0, _JDOF * 6 * __sampling_num *sizeof(double));\n-    memset(jacobian_transpose, 0, _JDOF * 6 * __sampling_num *sizeof(double));\n-    memset(manipulability, 0, __sampling_num * _time_window *sizeof(double));\n+    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n \n     \n     weights5[0] = 0.0;\n     position_sec1[0] = 0.0;\n@@ -1793,9 +1792,9 @@\n     cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_d, N * sizeof(double));\n     cudaMalloc((void**)&dev_e, N * sizeof(double));\n     cudaMalloc((void**)&dev_cost, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost_x, __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n@@ -1805,14 +1804,14 @@\n     cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n-    cudaMalloc((void**)&d_outputs, __sampling_num * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n \n     cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n     cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n \n-    cudaMalloc((void**)&dev_inputs, _JDOF * __sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n@@ -1823,30 +1822,30 @@\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n \n     // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n-    // cudaMalloc((void**)&dev_position_EE, __sampling_num * _time_window * 3 * sizeof(double));\n-    // cudaMalloc((void**)&dev_orientation_EE, __sampling_num * _time_window * 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_position_EE, 3 * __sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_orientation_EE, 3 * __sampling_num * _time_window * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n \n-    cudaMalloc((void**)&dev_velocity_EE, 3 * __sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n \n     cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n     cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n \n     cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n \n-    cudaMalloc((void**)&dev_rot_EE, 9 * __sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * __sampling_num  * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * __sampling_num * sizeof(double));\n-    cudaMalloc((void**)&dev_manipulability, __sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n-    cudaMalloc((void**)&dev_found_sol, __sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     \n }\n \n"
                },
                {
                    "date": 1691566433927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n #include <cuda_runtime.h>\n #include <device_launch_parameters.h>\n #include \"cuda.cuh\"\n \n-#define THREADS_PER_BLOCK _sampling_num\n-#define THREADS_PER_BLOCK2 _sampling_num\n+#define THREADS_PER_BLOCK SAM_NUM_MACRO_PRE\n+#define THREADS_PER_BLOCK2 SAM_NUM_MACRO_PRE\n \n // device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n@@ -242,9 +242,9 @@\n     // int index2 = index/_time_window;\n     int index3 = index*6*_JDOF;\n     // double theta[7];\n \n-    if(index<_sampling_num )\n+    if(index<SAM_NUM_MACRO_PRE )\n     {\n         \n         // for(int i = 0; i<_JDOF;)\n         // {\n@@ -518,9 +518,9 @@\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n-    if(index < _sampling_num * _time_window)\n+    if(index < SAM_NUM_MACRO_PRE * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n@@ -774,9 +774,9 @@\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n \n-    if(index < _sampling_num)\n+    if(index < SAM_NUM_MACRO_PRE)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double transformationMatrix[16];\n@@ -1022,9 +1022,9 @@\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n     \n-    if (tid < _sampling_num) {\n+    if (tid < SAM_NUM_MACRO_PRE) {\n         for (int j = 0; j < _nodes_cuda; j++) {\n             hidden0[j] = 0.0;\n         }\n     \n@@ -1073,9 +1073,9 @@\n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n-    if (index < _JDOF * _sampling_num)\n+    if (index < _JDOF * SAM_NUM_MACRO_PRE)\n     {\n         inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n \n         if (inputs[index] > 1)\n@@ -1092,9 +1092,9 @@\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    if(index < _sampling_num)\n+    if(index < SAM_NUM_MACRO_PRE)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n@@ -1236,14 +1236,14 @@\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n     dim3 blockDim(N/_time_window, 1, 1);\n     dim3 gridDim(_time_window, 1, 1);\n-    dim3 gridDim2(_sampling_num, 1);\n+    dim3 gridDim2(SAM_NUM_MACRO_PRE, 1);\n     dim3 blockDim2(1, 1);\n     dim3 blockSize(1, 1);\n     dim3 gridSize(1, 1);\n     dim3 blockSize2(1, 1);\n-    dim3 gridSize2(_sampling_num * _time_window, 1);\n+    dim3 gridSize2(SAM_NUM_MACRO_PRE * _time_window, 1);\n \n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n@@ -1311,12 +1311,12 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n \n         \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();    \n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1334,9 +1334,9 @@\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1344,9 +1344,9 @@\n             }\n         }\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1440,11 +1440,11 @@\n         cudaDeviceSynchronize();\n \n         // cout<<\"222222222222222222222222\"<<endl;\n         // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n         // cudaDeviceSynchronize();\n-        // for(int k = 0 ;k <_sampling_num; k++)\n+        // for(int k = 0 ;k <SAM_NUM_MACRO_PRE; k++)\n         // {\n         //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n         //     for(int i = 0; i<42; i++)\n         //     {\n@@ -1458,12 +1458,12 @@\n         //         }            \n         //     }\n         // }        \n         \n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n-        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(manipulability, dev_manipulability, SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n \n \n         // cout<<\"CUDA manipulability\"<<endl;\n         // for(int i = 0; i<N/_JDOF; i++)\n@@ -1474,16 +1474,16 @@\n         cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n \n         prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n-        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        computeForwardKinematics <<<N/SAM_NUM_MACRO_PRE, SAM_NUM_MACRO_PRE>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n         cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n \n-        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaMemcpy(position_EE, dev_position_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1497,10 +1497,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/SAM_NUM_MACRO_PRE, SAM_NUM_MACRO_PRE>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n@@ -1510,21 +1510,21 @@\n \n \n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n-        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(cost_xerr, dev_cost_x, SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // for(int i = 0; i<_sampling_num * _time_window; i++)\n+        // for(int i = 0; i<SAM_NUM_MACRO_PRE * _time_window; i++)\n         // {\n         //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n         // }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n         calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * SAM_NUM_MACRO_PRE; i++)\n         // {\n         //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n         // }\n         cudaDeviceSynchronize();\n@@ -1535,20 +1535,20 @@\n         cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n-        // for(int i = 0; i<_sampling_num; i++)\n+        // for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n         //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n         //     }\n         // }\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1595,9 +1595,9 @@\n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n         // _sol_cost = 0.0;\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1606,9 +1606,9 @@\n         }\n         _sol_cost = _min_cost;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<_sampling_num; i++)\n+        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1731,19 +1731,19 @@\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n \n-    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(position_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n \n     memset(FK_d, 0, 9 * sizeof(double));\n     memset(FK_a, 0, 9 * sizeof(double));\n     memset(FK_alpha, 0, 9 * sizeof(double));\n     \n-    memset(_return_cost, 0, _sampling_num * sizeof(double));\n-    memset(_cost, 0, _sampling_num * sizeof(double));\n+    memset(_return_cost, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n+    memset(_cost, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n \n     memset(_max_joint_position, 0, _JDOF * sizeof(double));\n     memset(_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_q_des, 0, _JDOF * sizeof(double));\n@@ -1752,24 +1752,24 @@\n     memset(_weighted_A, 0, _JDOF * sizeof(double));\n     memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n     \n-    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n+    memset(inputs, 0, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double));\n     memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n     memset(weights1, 0, _nodes_cuda * sizeof(double));\n     memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n     memset(weights3, 0, _nodes_cuda * sizeof(double));\n     memset(weights4, 0, _nodes_cuda * sizeof(double));\n     // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n-    memset(outputs, 0, _sampling_num * sizeof(double));\n+    memset(outputs, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n     memset(returnArray, 0, _JDOF*3 * sizeof(double));\n \n     memset(_prev_x, 0, 3 * sizeof(double));\n     memset(_prev_r, 0, 3 * sizeof(double));\n \n-    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n+    memset(jacobian, 0, _JDOF * 6 * SAM_NUM_MACRO_PRE *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * SAM_NUM_MACRO_PRE *sizeof(double));\n+    memset(manipulability, 0, SAM_NUM_MACRO_PRE * _time_window *sizeof(double));\n \n     \n     weights5[0] = 0.0;\n     position_sec1[0] = 0.0;\n@@ -1792,9 +1792,9 @@\n     cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_d, N * sizeof(double));\n     cudaMalloc((void**)&dev_e, N * sizeof(double));\n     cudaMalloc((void**)&dev_cost, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n@@ -1804,14 +1804,14 @@\n     cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n-    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, SAM_NUM_MACRO_PRE * sizeof(double));\n \n     cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n     cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n \n-    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_inputs, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double));\n     cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n@@ -1822,30 +1822,30 @@\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n \n     // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n-    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, SAM_NUM_MACRO_PRE * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, SAM_NUM_MACRO_PRE * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n \n-    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n \n     cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n     cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n \n     cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n \n-    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n-    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_rot_EE, 9 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * SAM_NUM_MACRO_PRE * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n-    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, SAM_NUM_MACRO_PRE * sizeof(double));\n \n     \n }\n \n"
                },
                {
                    "date": 1691566519179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,10 @@\n #include <cuda_runtime.h>\n #include <device_launch_parameters.h>\n #include \"cuda.cuh\"\n \n-#define THREADS_PER_BLOCK SAM_NUM_MACRO_PRE\n-#define THREADS_PER_BLOCK2 SAM_NUM_MACRO_PRE\n+#define THREADS_PER_BLOCK _sampling_num\n+#define THREADS_PER_BLOCK2 _sampling_num\n \n // device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n \n \n@@ -242,9 +242,9 @@\n     // int index2 = index/_time_window;\n     int index3 = index*6*_JDOF;\n     // double theta[7];\n \n-    if(index<SAM_NUM_MACRO_PRE )\n+    if(index<_sampling_num )\n     {\n         \n         // for(int i = 0; i<_JDOF;)\n         // {\n@@ -518,9 +518,9 @@\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n-    if(index < SAM_NUM_MACRO_PRE * _time_window)\n+    if(index < _sampling_num * _time_window)\n     {\n         double rotation_EE_index[9];\n         for(int i = 0; i<9; i++)\n         {\n@@ -774,9 +774,9 @@\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n \n-    if(index < SAM_NUM_MACRO_PRE)\n+    if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double transformationMatrix[16];\n@@ -1022,9 +1022,9 @@\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n     \n-    if (tid < SAM_NUM_MACRO_PRE) {\n+    if (tid < _sampling_num) {\n         for (int j = 0; j < _nodes_cuda; j++) {\n             hidden0[j] = 0.0;\n         }\n     \n@@ -1073,9 +1073,9 @@\n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n-    if (index < _JDOF * SAM_NUM_MACRO_PRE)\n+    if (index < _JDOF * _sampling_num)\n     {\n         inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n \n         if (inputs[index] > 1)\n@@ -1092,9 +1092,9 @@\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    if(index < SAM_NUM_MACRO_PRE)\n+    if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n         {\n             double tmp_p = 0.0;\n@@ -1236,14 +1236,14 @@\n     // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n     \n     dim3 blockDim(N/_time_window, 1, 1);\n     dim3 gridDim(_time_window, 1, 1);\n-    dim3 gridDim2(SAM_NUM_MACRO_PRE, 1);\n+    dim3 gridDim2(_sampling_num, 1);\n     dim3 blockDim2(1, 1);\n     dim3 blockSize(1, 1);\n     dim3 gridSize(1, 1);\n     dim3 blockSize2(1, 1);\n-    dim3 gridSize2(SAM_NUM_MACRO_PRE * _time_window, 1);\n+    dim3 gridSize2(_sampling_num * _time_window, 1);\n \n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n@@ -1311,12 +1311,12 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n \n         \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();    \n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1334,9 +1334,9 @@\n \n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1344,9 +1344,9 @@\n             }\n         }\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1440,11 +1440,11 @@\n         cudaDeviceSynchronize();\n \n         // cout<<\"222222222222222222222222\"<<endl;\n         // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         // cudaDeviceSynchronize();\n-        // for(int k = 0 ;k <SAM_NUM_MACRO_PRE; k++)\n+        // for(int k = 0 ;k <_sampling_num; k++)\n         // {\n         //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n         //     for(int i = 0; i<42; i++)\n         //     {\n@@ -1458,12 +1458,12 @@\n         //         }            \n         //     }\n         // }        \n         \n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n-        // cudaMemcpy(manipulability, dev_manipulability, SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n \n \n         // cout<<\"CUDA manipulability\"<<endl;\n         // for(int i = 0; i<N/_JDOF; i++)\n@@ -1474,16 +1474,16 @@\n         cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n \n         prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n-        computeForwardKinematics <<<N/SAM_NUM_MACRO_PRE, SAM_NUM_MACRO_PRE>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n         cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n \n-        cudaMemcpy(position_EE, dev_position_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1497,10 +1497,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/SAM_NUM_MACRO_PRE, SAM_NUM_MACRO_PRE>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n@@ -1510,21 +1510,21 @@\n \n \n \n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n-        cudaMemcpy(cost_xerr, dev_cost_x, SAM_NUM_MACRO_PRE * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // for(int i = 0; i<SAM_NUM_MACRO_PRE * _time_window; i++)\n+        // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n         //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n         // }\n \n         cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n \n         calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_JDOF * SAM_NUM_MACRO_PRE; i++)\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n         // {\n         //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n         // }\n         cudaDeviceSynchronize();\n@@ -1535,20 +1535,20 @@\n         cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, SAM_NUM_MACRO_PRE * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n-        // for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        // for(int i = 0; i<_sampling_num; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n         //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n         //     }\n         // }\n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _return_cost[i] = 0.0;\n             for(int j = 0; j<_JDOF; j++)\n             {\n@@ -1595,9 +1595,9 @@\n         _min_cost = 1000000000000000.0;\n         weight_sum = 0.0;\n         // _sol_cost = 0.0;\n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n@@ -1606,9 +1606,9 @@\n         }\n         _sol_cost = _min_cost;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n-        for(int i = 0; i<SAM_NUM_MACRO_PRE; i++)\n+        for(int i = 0; i<_sampling_num; i++)\n         {\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n@@ -1731,19 +1731,19 @@\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n \n-    memset(position_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    memset(orientation_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    memset(velocity_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    memset(velocity_ori_EE, 0, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n \n     memset(FK_d, 0, 9 * sizeof(double));\n     memset(FK_a, 0, 9 * sizeof(double));\n     memset(FK_alpha, 0, 9 * sizeof(double));\n     \n-    memset(_return_cost, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n-    memset(_cost, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n+    memset(_return_cost, 0, _sampling_num * sizeof(double));\n+    memset(_cost, 0, _sampling_num * sizeof(double));\n \n     memset(_max_joint_position, 0, _JDOF * sizeof(double));\n     memset(_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_q_des, 0, _JDOF * sizeof(double));\n@@ -1752,24 +1752,24 @@\n     memset(_weighted_A, 0, _JDOF * sizeof(double));\n     memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n     memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n     \n-    memset(inputs, 0, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double));\n+    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n     memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n     memset(weights1, 0, _nodes_cuda * sizeof(double));\n     memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n     memset(weights3, 0, _nodes_cuda * sizeof(double));\n     memset(weights4, 0, _nodes_cuda * sizeof(double));\n     // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n-    memset(outputs, 0, SAM_NUM_MACRO_PRE * sizeof(double));\n+    memset(outputs, 0, _sampling_num * sizeof(double));\n     memset(returnArray, 0, _JDOF*3 * sizeof(double));\n \n     memset(_prev_x, 0, 3 * sizeof(double));\n     memset(_prev_r, 0, 3 * sizeof(double));\n \n-    memset(jacobian, 0, _JDOF * 6 * SAM_NUM_MACRO_PRE *sizeof(double));\n-    memset(jacobian_transpose, 0, _JDOF * 6 * SAM_NUM_MACRO_PRE *sizeof(double));\n-    memset(manipulability, 0, SAM_NUM_MACRO_PRE * _time_window *sizeof(double));\n+    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n \n     \n     weights5[0] = 0.0;\n     position_sec1[0] = 0.0;\n@@ -1792,9 +1792,9 @@\n     cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_d, N * sizeof(double));\n     cudaMalloc((void**)&dev_e, N * sizeof(double));\n     cudaMalloc((void**)&dev_cost, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost_x, SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n     cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n@@ -1804,14 +1804,14 @@\n     cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n     cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n-    cudaMalloc((void**)&d_outputs, SAM_NUM_MACRO_PRE * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n \n     cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n     cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n \n-    cudaMalloc((void**)&dev_inputs, _JDOF * SAM_NUM_MACRO_PRE * sizeof(double));\n+    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n     cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n \n     cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n@@ -1822,30 +1822,30 @@\n     cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n     cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n \n     // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n-    // cudaMalloc((void**)&dev_position_EE, SAM_NUM_MACRO_PRE * _time_window * 3 * sizeof(double));\n-    // cudaMalloc((void**)&dev_orientation_EE, SAM_NUM_MACRO_PRE * _time_window * 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_position_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_orientation_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n \n-    cudaMalloc((void**)&dev_velocity_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n \n     cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n     cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n \n     cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n     cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n \n-    cudaMalloc((void**)&dev_rot_EE, 9 * SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * SAM_NUM_MACRO_PRE  * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * SAM_NUM_MACRO_PRE * sizeof(double));\n-    cudaMalloc((void**)&dev_manipulability, SAM_NUM_MACRO_PRE * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n-    cudaMalloc((void**)&dev_found_sol, SAM_NUM_MACRO_PRE * sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     \n }\n \n"
                },
                {
                    "date": 1691567133005,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,8 @@\n \n \n CudaTest::CudaTest(void)\n {   \n-    cpu_memory_save();\n-    cuda_memory_save();\n-    load_weight();\n-    initialize();\n }\n \n CudaTest::~CudaTest(void)\n {    \n"
                },
                {
                    "date": 1691568981355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1243,9 +1243,9 @@\n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        generate_random2<<<1, 1>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691569436610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -666,9 +666,9 @@\n         // }\n         // else\n         // {\n             _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n+            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n"
                },
                {
                    "date": 1691569770899,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1243,9 +1243,9 @@\n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<1, 1>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n"
                },
                {
                    "date": 1691570274159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -349,8 +349,9 @@\n             e[index] = 0.0;\n         }\n         \n     }\n+    printf(\"state_update OK \\n\");\n     __syncthreads();\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n@@ -681,8 +682,9 @@\n         {\n             _matrix_for_cuda[index] = 0.0;   \n         }\n     }\n+    printf(\"generate_random2 OK \\n\");\n     __syncthreads();\n }\n \n __global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n"
                },
                {
                    "date": 1691570295637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -763,8 +763,9 @@\n     rpy_from_transformationmatrix(transformationMatrix, tempVec);\n     orientation_EE[0] = tempVec[0];\n     orientation_EE[1] = tempVec[1];\n     orientation_EE[2] = tempVec[2];\n+    printf(\"prev_computeForwardKinematics OK \\n\");\n }\n \n __global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n {\n"
                },
                {
                    "date": 1691570307708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -768,8 +768,9 @@\n }\n \n __global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n {\n+    printf(\"computeForwardKinematics OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n"
                },
                {
                    "date": 1691570325169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -688,8 +688,9 @@\n }\n \n __global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n {\n+    printf(\"GetBodyRotationMatrix OK \\n\");\n     double Roll = xyzrpy_goal[3];\n     double Pitch = xyzrpy_goal[4];\n     double Yaw = xyzrpy_goal[5];\n \n"
                },
                {
                    "date": 1691570344751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,8 +311,9 @@\n }\n \n __global__ void Transpose_Matrix_3x3(double *input, double *output)\n {\n+    printf(\"Transpose_Matrix_3x3 OK \\n\");\n     output[0] = input[0];\n     output[1] = input[3];\n     output[2] = input[6];\n \n"
                },
                {
                    "date": 1691570356609,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1093,8 +1093,9 @@\n }\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n+    printf(\"if_find_solution OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n"
                },
                {
                    "date": 1691570367160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -356,8 +356,9 @@\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n+    printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n"
                },
                {
                    "date": 1691570379358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,8 +511,9 @@\n }\n \n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n+    printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n"
                },
                {
                    "date": 1691570392627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1075,8 +1075,9 @@\n }\n \n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n+    printf(\"calculate_inputs OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n     if (index < _JDOF * _sampling_num)\n     {\n"
                },
                {
                    "date": 1691570412284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1020,9 +1020,11 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) {\n+__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n+{\n+    printf(\"forwardPropagation OK \\n\");\n     int tid = threadIdx.x + blockIdx.x * blockDim.x;\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n"
                },
                {
                    "date": 1691570491804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -772,9 +772,9 @@\n }\n \n __global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n {\n-    printf(\"computeForwardKinematics OK \\n\");\n+    // printf(\"computeForwardKinematics OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index3 = index % (_time_window*7);\n     // int joint_num = index3 / _time_window;\n     // 각 변환 행렬 계산\n"
                },
                {
                    "date": 1691570523432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -511,9 +511,9 @@\n }\n \n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n-    printf(\"cost_function_task_space_control OK \\n\");\n+    // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     double weight1 = 80000.0; // 10000.0 (10.0) // rot\n     double weight2 = 300000.0; // 50000.0 (10.0) // pos\n"
                },
                {
                    "date": 1691570568189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -685,9 +685,9 @@\n         {\n             _matrix_for_cuda[index] = 0.0;   \n         }\n     }\n-    printf(\"generate_random2 OK \\n\");\n+    // printf(\"generate_random2 OK \\n\");\n     __syncthreads();\n }\n \n __global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n"
                },
                {
                    "date": 1691570622917,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,9 +350,9 @@\n             e[index] = 0.0;\n         }\n         \n     }\n-    printf(\"state_update OK \\n\");\n+    // printf(\"state_update OK \\n\");\n     __syncthreads();\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n@@ -1098,9 +1098,9 @@\n }\n \n __global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n {\n-    printf(\"if_find_solution OK \\n\");\n+    // printf(\"if_find_solution OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     if(index < _sampling_num)\n     {\n         for(int i = 0; i<_time_window; i++)\n"
                },
                {
                    "date": 1691570666225,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1077,9 +1077,9 @@\n }\n \n __global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n {\n-    printf(\"calculate_inputs OK \\n\");\n+    // printf(\"calculate_inputs OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n \n     if (index < _JDOF * _sampling_num)\n     {\n"
                },
                {
                    "date": 1691570677495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -356,9 +356,9 @@\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n-    printf(\"joint_limit_cost OK \\n\");\n+    // printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*7);\n"
                },
                {
                    "date": 1691570708400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1022,9 +1022,9 @@\n }\n \n __global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n {\n-    printf(\"forwardPropagation OK \\n\");\n+    // printf(\"forwardPropagation OK \\n\");\n     int tid = threadIdx.x + blockIdx.x * blockDim.x;\n     \n     double hidden0[_nodes_cuda];\n     double hidden1[_nodes_cuda];\n"
                },
                {
                    "date": 1691570759254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -311,9 +311,9 @@\n }\n \n __global__ void Transpose_Matrix_3x3(double *input, double *output)\n {\n-    printf(\"Transpose_Matrix_3x3 OK \\n\");\n+    // printf(\"Transpose_Matrix_3x3 OK \\n\");\n     output[0] = input[0];\n     output[1] = input[3];\n     output[2] = input[6];\n \n"
                },
                {
                    "date": 1691570774521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -691,9 +691,9 @@\n }\n \n __global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n {\n-    printf(\"GetBodyRotationMatrix OK \\n\");\n+    // printf(\"GetBodyRotationMatrix OK \\n\");\n     double Roll = xyzrpy_goal[3];\n     double Pitch = xyzrpy_goal[4];\n     double Yaw = xyzrpy_goal[5];\n \n@@ -767,9 +767,9 @@\n     rpy_from_transformationmatrix(transformationMatrix, tempVec);\n     orientation_EE[0] = tempVec[0];\n     orientation_EE[1] = tempVec[1];\n     orientation_EE[2] = tempVec[2];\n-    printf(\"prev_computeForwardKinematics OK \\n\");\n+    // printf(\"prev_computeForwardKinematics OK \\n\");\n }\n \n __global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n {\n"
                },
                {
                    "date": 1691651539717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,15 +509,15 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 =  alpha[0];// 80000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  beta[0];// 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n@@ -1513,13 +1513,11 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-\n-\n-\n-\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n+        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n@@ -1731,9 +1729,9 @@\n }\n \n void CudaTest::cpu_memory_save()\n {\n-    cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n     memset(cost_jointlimit, 0, N * sizeof(double));\n     memset(_mean_matrix, 0, N * sizeof(double));\n     memset(d, 0, N * sizeof(double));\n     memset(e, 0, N * sizeof(double));\n@@ -1853,9 +1851,10 @@\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n-    \n+    cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    cudaMalloc((void**)&dev_beta, sizeof(double));   \n }\n \n void CudaTest::cuda_memory_free()\n {    \n@@ -1911,8 +1910,11 @@\n \n     cudaFree(dev_jacobian);\n     cudaFree(dev_jacobian_transpose);\n \n+    cudaFree(dev_alpha);\n+    cudaFree(dev_beta);\n+\n     cudaError_t error = cudaGetLastError();\n     if (error != cudaSuccess) {\n         printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n         // 에러 처리 로직을 추가해야 합니다.\n"
                },
                {
                    "date": 1691651546657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1784,9 +1784,9 @@\n }\n \n void CudaTest::cuda_memory_save()\n {\n-    cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    // cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n     cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n     cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n     cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n     // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n@@ -1857,9 +1857,9 @@\n }\n \n void CudaTest::cuda_memory_free()\n {    \n-    cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n+    // cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n     cudaFree(dev__A);\n     cudaFree(dev__mean_matrix);\n     cudaFree(dev__matrix_for_cuda);\n     // cudaFree(dev__prev_matrix_for_cuda);\n"
                },
                {
                    "date": 1691740339200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n@@ -1923,9 +1923,9 @@\n \n void CudaTest::initialize()\n {\n     // cout<<endl;\n-    cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n+    // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n     // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n \n"
                },
                {
                    "date": 1691740354166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1219,8 +1219,11 @@\n     else\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n+\n+\n+    _dt_cuda2[0] = alpha\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691740380467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1219,11 +1219,9 @@\n     else\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n-\n-\n-    _dt_cuda2[0] = alpha\n+    \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691740391574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n@@ -1219,9 +1219,8 @@\n     else\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n-    \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691740406472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n@@ -1219,8 +1219,11 @@\n     else\n     {\n         _dt_cuda2[0] = _dt_cuda;\n     }\n+\n+\n+    _dt_cuda2[0] - alpha\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691740424886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1201,29 +1201,29 @@\n     // {\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     //////////////////////////////////////////////////////////////\n-    _sol_cost = _sol_cost / 5000;\n-    // 200/\n+    // _sol_cost = _sol_cost / 5000;\n+    // // 200/\n \n-    if(_sol_cost > 700)\n-    {\n-        _dt_cuda2[0] = 0.5;\n-    }\n-    else if(_sol_cost <= 700 && _sol_cost > 1)\n-    {\n-        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n-            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-        // _dt_cuda2[0] = 0.003;\n-    }\n-    else\n-    {\n-        _dt_cuda2[0] = _dt_cuda;\n-    }\n+    // if(_sol_cost > 700)\n+    // {\n+    //     _dt_cuda2[0] = 0.5;\n+    // }\n+    // else if(_sol_cost <= 700 && _sol_cost > 1)\n+    // {\n+    //     _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n+    //         //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     // _dt_cuda2[0] = 0.003;\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = _dt_cuda;\n+    // }\n \n \n-    _dt_cuda2[0] - alpha\n+    _dt_cuda2[0] = alpha;\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1691740437245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1516,10 +1516,10 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n"
                },
                {
                    "date": 1691740446155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1518,9 +1518,9 @@\n         \n \n         // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n         // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n"
                },
                {
                    "date": 1691740452013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1854,10 +1854,10 @@\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n-    cudaMalloc((void**)&dev_alpha, sizeof(double));\n-    cudaMalloc((void**)&dev_beta, sizeof(double));   \n+    // cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    // cudaMalloc((void**)&dev_beta, sizeof(double));   \n }\n \n void CudaTest::cuda_memory_free()\n {    \n"
                },
                {
                    "date": 1691740468159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,9 +509,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n@@ -1913,10 +1913,10 @@\n \n     cudaFree(dev_jacobian);\n     cudaFree(dev_jacobian_transpose);\n \n-    cudaFree(dev_alpha);\n-    cudaFree(dev_beta);\n+    // cudaFree(dev_alpha);\n+    // cudaFree(dev_beta);\n \n     cudaError_t error = cudaGetLastError();\n     if (error != cudaSuccess) {\n         printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n"
                },
                {
                    "date": 1691740477568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,10 +514,10 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  alpha[0];// 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 =  beta[0];// 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1691740555422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1221,9 +1221,9 @@\n     //     _dt_cuda2[0] = _dt_cuda;\n     // }\n \n \n-    _dt_cuda2[0] = alpha;\n+    _dt_cuda2[0] = alpha[0];\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n"
                },
                {
                    "date": 1692684978091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,21 +360,21 @@\n     // printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    int index3 = index % (_time_window*7);\n+    int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 500000.0;//pow(10,6)\n+    double constraint_gain = 500000;\n     double vel_gain = 300.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n-    }\n+    // if(now_gap[0] > gap_limit )\n+    // {\n+    //     vel_gain =  0.0;\n+    // }\n+    // else\n+    // {\n+    //     vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n+    // }\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -437,17 +437,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 4)\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }\n-        else\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }        \n+        // if(joint_num < 4)\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n         // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n     // }\n     __syncthreads();\n }\n@@ -509,15 +509,20 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+// __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 = 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n+    // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n+    // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 100000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n+    // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -531,9 +536,9 @@\n         for(int i = 0; i<3; i++)\n         {\n             PosEE_index[i] = position[index*3+i];\n         }\n-        PosEE_index[2] = PosEE_index[2] - 0.01;\n+        PosEE_index[2] = PosEE_index[2];\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n \n@@ -571,13 +576,13 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        if(PosGap_2 > gap_limit )\n-        {\n-            cost3 = weight1 * 3.14 * 3 * 2;\n-            weight1 =  0.0;            \n-        }\n+        // if(PosGap_2 > gap_limit )\n+        // {\n+        //     cost3 = weight1 * 3.14 * 3 * 2;\n+        //     weight1 =  0.0;            \n+        // }\n         // else\n         // {\n         //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n         // }\n@@ -599,18 +604,18 @@\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+/////////////////////////////////////// 학습용 전까지 일반 코드 ///////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n@@ -624,9 +629,12 @@\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         // f[index] = cost1 + cost2 + cost3;\n-        f[index] = cost1 + cost3;\n+        f[index] = cost1;// + cost3;\n+\n+        ///////////////////////  학습용 ///////////////////////\n+        // f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -647,13 +655,14 @@\n     }    \n     __syncthreads();\n }\n \n-__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n+__global__ void generate_random2(double* _A, double* _matrix_for_cuda)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n+    double tmptmp = 0.0;\n     // curandState localState = state[index%_time_window];\n     curandState state;\n     \n     // 현재 스레드의 인덱스로 상태 정보 초기화\n@@ -669,10 +678,19 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n+            tmptmp = curand_normal(&state);\n+            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n+\n+            // if(joint_num == 4)\n+            // {\n+            //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n+            // }\n+            \n+            // printf(\"_A[joint_num] : %f\\n\",_A[joint_num]);\n+            // printf(\"_matrix_for_cuda[joint_num] : %f\\n\",_matrix_for_cuda[index]);\n+            // printf(\"\\n\");\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n@@ -683,8 +701,9 @@\n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n+            // printf(\"_matrix_for_cuda[%d] : %f \\n\",index,_matrix_for_cuda[index]);\n         }\n     }\n     // printf(\"generate_random2 OK \\n\");\n     __syncthreads();\n@@ -1154,16 +1173,19 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *time_rl, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n     // {\n     //     cout<<_goal_pos_cuda[i]<<endl;    \n     // }\n+    // cout<<\"alpha : \"<<alpha[0]<<endl;\n+    // cout<<\"beta : \"<<beta[0]<<endl;\n+    // cout<<\"time_rl : \"<<time_rl[0]<<endl;\n     \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n     for(int i = 0; i<3; i++)\n@@ -1200,9 +1222,13 @@\n     // if(_dt_cuda2[0] != 0.7)\n     // {\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n-    //////////////////////////////////////////////////////////////\n+    // //////////////////////////////////////////////////////////////\n+\n+    // // _dt_cuda2[0] = 0.1;\n+    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n \n     // if(_sol_cost > 700)\n@@ -1221,9 +1247,11 @@\n     //     _dt_cuda2[0] = _dt_cuda;\n     // }\n \n \n-    _dt_cuda2[0] = alpha[0];\n+    // _dt_cuda2[0] = time_rl[0];\n+    _dt_cuda2[0] = 0.05;\n+\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n@@ -1258,9 +1286,9 @@\n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n@@ -1395,27 +1423,29 @@\n     }\n \n     else if(control_mode == 1)\n     {\n+        // cout<<endl;\n         // for(int i= 0; i<7; i++)\n         // {\n         //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n         // }\n+        // cout<<endl;\n         \n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         for(int i = 0; i<N; i++)\n         {\n             int index222 = i / _time_window;\n             if((i%_time_window) != 0)\n             {   \n                 _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n-                if((i%_time_window) >= _time_window-_dt2_window)\n-                {\n-                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n-                }                \n+                // if((i%_time_window) >= _time_window-_dt2_window)\n+                // {\n+                //     _matrix_for_cuda[i] = _matrix_for_cuda[i];\n+                // }                \n             }\n             // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n@@ -1494,8 +1524,14 @@\n         cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n+\n+        // for(int i = 0 ; i < 3 * _sampling_num * _time_window; i++)\n+        // {\n+        //     cout<<\"orientation_EE[\"<<i<<\"] : \"<<orientation_EE[i]<<endl;\n+        // }\n+        // cout<<\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1508,19 +1544,20 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        // cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n-        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n+        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap, dev_alpha, dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n@@ -1546,9 +1583,9 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n         cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-\n+        // cout<<\"?????\"<<endl;\n         // for(int i = 0; i<_sampling_num; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n@@ -1562,9 +1599,10 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    // _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1573,29 +1611,30 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                // _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  cost_xerr[i*_time_window + j];\n             }\n-            if(found_goal_list[i] == 1)\n-            {\n-                if(outputs[i] >= 0.5)\n-                {\n-                    found_goal_list[i] = 0;\n-                }\n-            }\n+            // if(found_goal_list[i] == 1)\n+            // {\n+            //     if(outputs[i] >= 0.5)\n+            //     {\n+            //         found_goal_list[i] = 0;\n+            //     }\n+            // }\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n             _return_cost[i] = _return_cost[i] / _JDOF;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-            if(found_goal_list[i] == 1)\n-            {\n-                found_goal = 1;\n-                // cout<<\"??\"<<endl;\n-                // _return_cost[i] = _return_cost[i];\n-            }\n+            // if(found_goal_list[i] == 1)\n+            // {\n+            //     found_goal = 1;\n+            //     // cout<<\"??\"<<endl;\n+            //     // _return_cost[i] = _return_cost[i];\n+            // }\n             // else\n             // {\n             //     _return_cost[i] = _return_cost[i] + 100.0;\n             // }\n@@ -1606,23 +1645,30 @@\n         // _sol_cost = 0.0;\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n-            _cost[i] = _return_cost[i];\n+            _cost[i] = _return_cost[i];// / 10000.0;\n             if(_min_cost > _cost[i])\n             {\n                 _min_cost = _cost[i];\n             }\n         }\n         _sol_cost = _min_cost;\n+        // cout<<endl;\n+        // cout<<\"_min_cost : \"<<_min_cost<<endl;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n+            // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n+            // _cost[i] = _cost[i] / 100.0;\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n+                // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n                 _cost[i] = exp(-_cost[i]);\t\t\n+                // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n+                \n                 weight_sum = weight_sum + _cost[i];\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n@@ -1649,9 +1695,9 @@\n         // }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n-            returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i];// * (1+_dt_cuda);\n             returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n             returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n \n             _q_des[i] = returnArray[i];\n@@ -1665,23 +1711,23 @@\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n     #else\n     #endif\n@@ -1734,9 +1780,9 @@\n void CudaTest::cpu_memory_save()\n {\n     // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n     memset(cost_jointlimit, 0, N * sizeof(double));\n-    memset(_mean_matrix, 0, N * sizeof(double));\n+    // memset(_mean_matrix, 0, N * sizeof(double));\n     memset(d, 0, N * sizeof(double));\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n@@ -1854,10 +1900,10 @@\n     cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n-    // cudaMalloc((void**)&dev_alpha, sizeof(double));\n-    // cudaMalloc((void**)&dev_beta, sizeof(double));   \n+    cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    cudaMalloc((void**)&dev_beta, sizeof(double));   \n }\n \n void CudaTest::cuda_memory_free()\n {    \n@@ -1913,10 +1959,10 @@\n \n     cudaFree(dev_jacobian);\n     cudaFree(dev_jacobian_transpose);\n \n-    // cudaFree(dev_alpha);\n-    // cudaFree(dev_beta);\n+    cudaFree(dev_alpha);\n+    cudaFree(dev_beta);\n \n     cudaError_t error = cudaGetLastError();\n     if (error != cudaSuccess) {\n         printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n@@ -1925,8 +1971,11 @@\n }\n \n void CudaTest::initialize()\n {\n+    // cpu_memory_save();\n+    // load_weight();\n+    memset(_A, 0, _JDOF * sizeof(double));\n     // cout<<endl;\n     // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n@@ -1971,8 +2020,9 @@\n \t_min_joint_position[1] = -1.7628;\n \t_min_joint_position[2] = -2.8973;\n \t_min_joint_position[3] = -3.0718;\n \t_min_joint_position[4] = -2.8973;\n+    // _min_joint_position[4] = 0.0;\n \t_min_joint_position[5] = -0.0175;\n \t_min_joint_position[6] = -2.8973;\n \n \t_max_joint_position[0] = 2.8973;\n@@ -2005,22 +2055,10 @@\n     // _hat_max_joint_position[5] = 3.43134;\n \n     // _hat_min_joint_position[6] = -2.37368;\n     // _hat_max_joint_position[6] = 2.37368;\n-\n-\n-\n-    for(int i = 0; i<_JDOF; i++)\n-    {\n-        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n-    }\n-\n     FK_a[0] = 0.0;\n-    FK_d[0] = 0.343;\n+    FK_d[0] = 0.333;\n     FK_alpha[0] = 0.0;\n \n     FK_a[1] = 0.0;\n     FK_d[1] = 0.0;\n@@ -2052,5 +2090,20 @@\n \n     FK_a[8] = 0.0;\n     FK_d[8] = 0.1034;\n     FK_alpha[8] = 0.0;\n+\n+\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n+    }\n+}\n+\n+void CudaTest::RL_initialize()\n+{\n+    memset(_A, 0, _JDOF * sizeof(double));\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1692685029696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1707,32 +1707,36 @@\n }\n \n void CudaTest::load_weight()\n {\n+    cout<<\"33\"<<endl;\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n+    cout<<\"33\"<<endl;\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n+    cout<<\"33\"<<endl;\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n+    cout<<\"33\"<<endl;\n     #else\n     #endif\n-    \n+    cout<<\"33\"<<endl;\n     weight0.open(filename_NN[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1740,16 +1744,16 @@\n             weight0 >> weights0[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    \n+    cout<<\"33\"<<endl;\n     weight0.open(filename_NN[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n-\n+    cout<<\"33\"<<endl;\n     weight0.open(filename_NN[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1757,16 +1761,16 @@\n             weight0 >> weights2[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-\n+    cout<<\"33\"<<endl;\n     weight0.open(filename_NN[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n-\n+    cout<<\"33\"<<endl;\n     weight0.open(filename_NN[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n@@ -1774,8 +1778,9 @@\n     weight0.close();\n     weight0.open(filename_NN[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n+    cout<<\"33\"<<endl;\n }\n \n void CudaTest::cpu_memory_save()\n {\n"
                },
                {
                    "date": 1692685150433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1715,28 +1715,28 @@\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     #else\n     #endif\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1744,16 +1744,16 @@\n             weight0 >> weights0[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1761,16 +1761,16 @@\n             weight0 >> weights2[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n@@ -1778,9 +1778,9 @@\n     weight0.close();\n     weight0.open(filename_NN[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n-    cout<<\"33\"<<endl;\n+    cout<<\"44\"<<endl;\n }\n \n void CudaTest::cpu_memory_save()\n {\n"
                },
                {
                    "date": 1692685248781,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1707,36 +1707,36 @@\n }\n \n void CudaTest::load_weight()\n {\n-    cout<<\"33\"<<endl;\n-    #if _nodes_cuda == 32\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n-        }\n-    }\n+    // cout<<\"33\"<<endl;\n+    // #if _nodes_cuda == 32\n+    // {\n+    //     for(int i = 0; i<6; i++)\n+    //     {\n+    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+    //     }\n+    // }\n+    // cout<<\"44\"<<endl;\n+    // #elif _nodes_cuda == 64\n+    // {\n+    //     for(int i = 0; i<6; i++)\n+    //     {\n+    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+    //     } \n+    // }\n+    // cout<<\"44\"<<endl;\n+    // #elif _nodes_cuda == 100\n+    // {\n+    //     for(int i = 0; i<6; i++)\n+    //     {\n+    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+    //     } \n+    // }\n+    // cout<<\"44\"<<endl;\n+    // #else\n+    // #endif\n     cout<<\"44\"<<endl;\n-    #elif _nodes_cuda == 64\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n-        } \n-    }\n-    cout<<\"44\"<<endl;\n-    #elif _nodes_cuda == 100\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n-        } \n-    }\n-    cout<<\"44\"<<endl;\n-    #else\n-    #endif\n-    cout<<\"44\"<<endl;\n     weight0.open(filename_NN[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n"
                },
                {
                    "date": 1692685275595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1735,9 +1735,9 @@\n     // cout<<\"44\"<<endl;\n     // #else\n     // #endif\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[0].str());\n+    weight0.open(\"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[0].txt\");\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n"
                },
                {
                    "date": 1692685300171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1707,37 +1707,37 @@\n }\n \n void CudaTest::load_weight()\n {\n-    // cout<<\"33\"<<endl;\n-    // #if _nodes_cuda == 32\n-    // {\n-    //     for(int i = 0; i<6; i++)\n-    //     {\n-    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n-    //     }\n-    // }\n-    // cout<<\"44\"<<endl;\n-    // #elif _nodes_cuda == 64\n-    // {\n-    //     for(int i = 0; i<6; i++)\n-    //     {\n-    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n-    //     } \n-    // }\n-    // cout<<\"44\"<<endl;\n-    // #elif _nodes_cuda == 100\n-    // {\n-    //     for(int i = 0; i<6; i++)\n-    //     {\n-    //         filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n-    //     } \n-    // }\n-    // cout<<\"44\"<<endl;\n-    // #else\n-    // #endif\n+    cout<<\"33\"<<endl;\n+    #if _nodes_cuda == 32\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+        }\n+    }\n     cout<<\"44\"<<endl;\n-    weight0.open(\"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[0].txt\");\n+    #elif _nodes_cuda == 64\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+        } \n+    }\n+    cout<<\"44\"<<endl;\n+    #elif _nodes_cuda == 100\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+        } \n+    }\n+    cout<<\"44\"<<endl;\n+    #else\n+    #endif\n+    cout<<\"44\"<<endl;\n+    weight0.open(filename_NN[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n"
                },
                {
                    "date": 1692685332443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1712,25 +1712,25 @@\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n     cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n     cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n     cout<<\"44\"<<endl;\n     #else\n"
                },
                {
                    "date": 1692685347013,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1707,9 +1707,9 @@\n }\n \n void CudaTest::load_weight()\n {\n-    cout<<\"33\"<<endl;\n+    cout<<\"333333\"<<endl;\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n"
                },
                {
                    "date": 1692685364645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1709,11 +1709,14 @@\n void CudaTest::load_weight()\n {\n     cout<<\"333333\"<<endl;\n     #if _nodes_cuda == 32\n+    cout<<\"444\"<<endl;\n     {\n+        cout<<\"5555\"<<endl;\n         for(int i = 0; i<6; i++)\n         {\n+            cout<<\"222\"<<endl;\n             filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n     cout<<\"44\"<<endl;\n"
                },
                {
                    "date": 1692685385187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1714,10 +1714,11 @@\n     {\n         cout<<\"5555\"<<endl;\n         for(int i = 0; i<6; i++)\n         {\n+            cout<<\"111\"<<endl;\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n             cout<<\"222\"<<endl;\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n     cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 64\n"
                },
                {
                    "date": 1692685515163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1715,9 +1715,9 @@\n         cout<<\"5555\"<<endl;\n         for(int i = 0; i<6; i++)\n         {\n             cout<<\"111\"<<endl;\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n             cout<<\"222\"<<endl;\n         }\n     }\n     cout<<\"44\"<<endl;\n"
                },
                {
                    "date": 1692685589576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1708,8 +1708,14 @@\n \n void CudaTest::load_weight()\n {\n     cout<<\"333333\"<<endl;\n+    for(int i = 0; i<6; i++)\n+    {\n+        cout<<\"111\"<<endl;\n+        filename_NN[i] << \"1\";\n+        cout<<\"222\"<<endl;\n+    }\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n     {\n         cout<<\"5555\"<<endl;\n"
                },
                {
                    "date": 1692685625697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1711,9 +1711,9 @@\n     cout<<\"333333\"<<endl;\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n-        filename_NN[i] << \"1\";\n+        filename_NN[i] << \"../weight/best_model_panda_0427_3[0]\";\n         cout<<\"222\"<<endl;\n     }\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n"
                },
                {
                    "date": 1692685912582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1711,9 +1711,9 @@\n     cout<<\"333333\"<<endl;\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n-        filename_NN[i] << \"../weight/best_model_panda_0427_3[0]\";\n+        filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n     }\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n"
                },
                {
                    "date": 1692686047469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1711,9 +1711,9 @@\n     cout<<\"333333\"<<endl;\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n-        filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+        filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n     }\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n@@ -1721,33 +1721,33 @@\n         cout<<\"5555\"<<endl;\n         for(int i = 0; i<6; i++)\n         {\n             cout<<\"111\"<<endl;\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n             cout<<\"222\"<<endl;\n         }\n     }\n     cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n     cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n     cout<<\"44\"<<endl;\n     #else\n     #endif\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[0].str());\n+    weight0.open(filename_NN2[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n@@ -1755,16 +1755,16 @@\n         }\n     }\n     weight0.close();\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[1].str());\n+    weight0.open(filename_NN2[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[2].str());\n+    weight0.open(filename_NN2[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n@@ -1772,22 +1772,22 @@\n         }\n     }\n     weight0.close();\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[3].str());\n+    weight0.open(filename_NN2[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n     cout<<\"44\"<<endl;\n-    weight0.open(filename_NN[4].str());\n+    weight0.open(filename_NN2[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n     }\n     weight0.close();\n-    weight0.open(filename_NN[5].str());\n+    weight0.open(filename_NN2[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n     cout<<\"44\"<<endl;\n }\n"
                },
                {
                    "date": 1692686425730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1711,11 +1711,14 @@\n     cout<<\"333333\"<<endl;\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n+        cout<<\"i : \"<<i<<endl;\n         filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n     }\n+\n+\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n     {\n         cout<<\"5555\"<<endl;\n"
                },
                {
                    "date": 1692686455864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1711,8 +1711,11 @@\n     cout<<\"333333\"<<endl;\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n+         std::ostringstream temp;\n+    temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n+    filename_NN2[i] << temp.str();\n         cout<<\"i : \"<<i<<endl;\n         filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n     }\n"
                },
                {
                    "date": 1692686464354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1712,10 +1712,10 @@\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n          std::ostringstream temp;\n-    temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n-    filename_NN2[i] << temp.str();\n+        temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n+        filename_NN2[i] << temp.str();\n         cout<<\"i : \"<<i<<endl;\n         filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n     }\n"
                },
                {
                    "date": 1692686482511,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1713,8 +1713,9 @@\n     {\n         cout<<\"111\"<<endl;\n          std::ostringstream temp;\n         temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n+        cout<<\"111\"<<endl;\n         filename_NN2[i] << temp.str();\n         cout<<\"i : \"<<i<<endl;\n         filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         cout<<\"222\"<<endl;\n"
                },
                {
                    "date": 1692686552597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1708,12 +1708,13 @@\n \n void CudaTest::load_weight()\n {\n     cout<<\"333333\"<<endl;\n+    std::ostringstream filename_NN2[6];\n     for(int i = 0; i<6; i++)\n     {\n         cout<<\"111\"<<endl;\n-         std::ostringstream temp;\n+         \n         temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n         cout<<\"111\"<<endl;\n         filename_NN2[i] << temp.str();\n         cout<<\"i : \"<<i<<endl;\n"
                },
                {
                    "date": 1692686560047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1709,19 +1709,8 @@\n void CudaTest::load_weight()\n {\n     cout<<\"333333\"<<endl;\n     std::ostringstream filename_NN2[6];\n-    for(int i = 0; i<6; i++)\n-    {\n-        cout<<\"111\"<<endl;\n-         \n-        temp << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\" << i << \"].txt\";\n-        cout<<\"111\"<<endl;\n-        filename_NN2[i] << temp.str();\n-        cout<<\"i : \"<<i<<endl;\n-        filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n-        cout<<\"222\"<<endl;\n-    }\n \n \n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n"
                },
                {
                    "date": 1692686566579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1709,10 +1709,8 @@\n void CudaTest::load_weight()\n {\n     cout<<\"333333\"<<endl;\n     std::ostringstream filename_NN2[6];\n-\n-\n     #if _nodes_cuda == 32\n     cout<<\"444\"<<endl;\n     {\n         cout<<\"5555\"<<endl;\n"
                },
                {
                    "date": 1692686605784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1710,19 +1710,15 @@\n {\n     cout<<\"333333\"<<endl;\n     std::ostringstream filename_NN2[6];\n     #if _nodes_cuda == 32\n-    cout<<\"444\"<<endl;\n     {\n-        cout<<\"5555\"<<endl;\n         for(int i = 0; i<6; i++)\n         {\n-            cout<<\"111\"<<endl;\n             filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n-            cout<<\"222\"<<endl;\n         }\n     }\n-    cout<<\"44\"<<endl;\n+    \n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n"
                },
                {
                    "date": 1692686619060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1716,9 +1716,9 @@\n         {\n             filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n-    \n+\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n@@ -1735,9 +1735,9 @@\n     }\n     cout<<\"44\"<<endl;\n     #else\n     #endif\n-    cout<<\"44\"<<endl;\n+    cout<<\"1\"<<endl;\n     weight0.open(filename_NN2[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1745,16 +1745,16 @@\n             weight0 >> weights0[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"44\"<<endl;\n+    cout<<\"2\"<<endl;\n     weight0.open(filename_NN2[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n-    cout<<\"44\"<<endl;\n+    cout<<\"3\"<<endl;\n     weight0.open(filename_NN2[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1762,16 +1762,16 @@\n             weight0 >> weights2[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"44\"<<endl;\n+    cout<<\"4\"<<endl;\n     weight0.open(filename_NN2[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n-    cout<<\"44\"<<endl;\n+    cout<<\"5\"<<endl;\n     weight0.open(filename_NN2[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n@@ -1779,9 +1779,9 @@\n     weight0.close();\n     weight0.open(filename_NN2[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n-    cout<<\"44\"<<endl;\n+    cout<<\"6\"<<endl;\n }\n \n void CudaTest::cpu_memory_save()\n {\n"
                },
                {
                    "date": 1692686628466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1724,17 +1724,15 @@\n         {\n             filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n-    cout<<\"44\"<<endl;\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n             filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n-    cout<<\"44\"<<endl;\n     #else\n     #endif\n     cout<<\"1\"<<endl;\n     weight0.open(filename_NN2[0].str());\n"
                },
                {
                    "date": 1692686634741,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1735,8 +1735,9 @@\n     #else\n     #endif\n     cout<<\"1\"<<endl;\n     weight0.open(filename_NN2[0].str());\n+    cout<<\"1-1\"<<endl;\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n"
                },
                {
                    "date": 1692686669383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1734,9 +1734,11 @@\n     }\n     #else\n     #endif\n     cout<<\"1\"<<endl;\n-    weight0.open(filename_NN2[0].str());\n+    std::string filepath = filename_NN2[0].str();\n+std::cout << \"Opening file: \" << filepath << std::endl;\n+weight0.open(filepath);\n     cout<<\"1-1\"<<endl;\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n"
                },
                {
                    "date": 1692686712761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1734,11 +1734,9 @@\n     }\n     #else\n     #endif\n     cout<<\"1\"<<endl;\n-    std::string filepath = filename_NN2[0].str();\n-std::cout << \"Opening file: \" << filepath << std::endl;\n-weight0.open(filepath);\n+    weight0.open(filename_NN2[0].str());\n     cout<<\"1-1\"<<endl;\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n"
                },
                {
                    "date": 1692686765287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1733,8 +1733,9 @@\n         } \n     }\n     #else\n     #endif\n+    ifstream weight0;\n     cout<<\"1\"<<endl;\n     weight0.open(filename_NN2[0].str());\n     cout<<\"1-1\"<<endl;\n     for(int i = 0; i<_JDOF ; i++)\n"
                },
                {
                    "date": 1692686886508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.05;\n+    _dt_cuda2[0] = 0.1;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692686910423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1707,9 +1707,8 @@\n }\n \n void CudaTest::load_weight()\n {\n-    cout<<\"333333\"<<endl;\n     std::ostringstream filename_NN2[6];\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n@@ -1734,27 +1733,23 @@\n     }\n     #else\n     #endif\n     ifstream weight0;\n-    cout<<\"1\"<<endl;\n     weight0.open(filename_NN2[0].str());\n-    cout<<\"1-1\"<<endl;\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n             weight0 >> weights0[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"2\"<<endl;\n     weight0.open(filename_NN2[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n-    cout<<\"3\"<<endl;\n     weight0.open(filename_NN2[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n@@ -1762,16 +1757,14 @@\n             weight0 >> weights2[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    cout<<\"4\"<<endl;\n     weight0.open(filename_NN2[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n-    cout<<\"5\"<<endl;\n     weight0.open(filename_NN2[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n@@ -1779,9 +1772,8 @@\n     weight0.close();\n     weight0.open(filename_NN2[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n-    cout<<\"6\"<<endl;\n }\n \n void CudaTest::cpu_memory_save()\n {\n"
                },
                {
                    "date": 1692687034060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.1;\n+    // _dt_cuda2[0] = 0.1;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692687044203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1197,33 +1197,33 @@\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     ////////////////////////////////////////////////////////////////\n-    // if(found_goal == 1)\n-    // {\n-    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-    //     {\n-    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-    //     }\n-    //     else if(now_pos_gap[0] <= position_sec2[0])\n-    //     {\n-    //         _dt_cuda2[0] = _dt_cuda;\n-    //     }\n-    //     else if(now_pos_gap[0] >= 1.0)\n-    //     {\n-    //         _dt_cuda2[0] = 0.7;\n-    //     }\n-    // }\n-    // else\n-    // {\n-    //     _dt_cuda2[0] = 0.7;\n-    // }\n-    // found_goal = 0;\n-    // if(_dt_cuda2[0] != 0.7)\n-    // {\n-    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    // }\n+    if(found_goal == 1)\n+    {\n+        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+        {\n+            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        }\n+        else if(now_pos_gap[0] <= position_sec2[0])\n+        {\n+            _dt_cuda2[0] = _dt_cuda;\n+        }\n+        else if(now_pos_gap[0] >= 1.0)\n+        {\n+            _dt_cuda2[0] = 0.7;\n+        }\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = 0.7;\n+    }\n+    found_goal = 0;\n+    if(_dt_cuda2[0] != 0.7)\n+    {\n+        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    }\n     // //////////////////////////////////////////////////////////////\n \n     // // _dt_cuda2[0] = 0.1;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n@@ -1544,10 +1544,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        // if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        // cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1692687059904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1614,15 +1614,15 @@\n             {\n                 // _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n                 _return_cost[i] = _return_cost[i] +  cost_xerr[i*_time_window + j];\n             }\n-            // if(found_goal_list[i] == 1)\n-            // {\n-            //     if(outputs[i] >= 0.5)\n-            //     {\n-            //         found_goal_list[i] = 0;\n-            //     }\n-            // }\n+            if(found_goal_list[i] == 1)\n+            {\n+                if(outputs[i] >= 0.5)\n+                {\n+                    found_goal_list[i] = 0;\n+                }\n+            }\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n"
                },
                {
                    "date": 1692687183805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.1-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.1;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.7;\n+            _dt_cuda2[0] = 0.1;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 0.1;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n+    if(_dt_cuda2[0] != 0.1)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n@@ -1627,14 +1627,14 @@\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n             _return_cost[i] = _return_cost[i] / _JDOF;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-            // if(found_goal_list[i] == 1)\n-            // {\n-            //     found_goal = 1;\n-            //     // cout<<\"??\"<<endl;\n-            //     // _return_cost[i] = _return_cost[i];\n-            // }\n+            if(found_goal_list[i] == 1)\n+            {\n+                found_goal = 1;\n+                // cout<<\"??\"<<endl;\n+                // _return_cost[i] = _return_cost[i];\n+            }\n             // else\n             // {\n             //     _return_cost[i] = _return_cost[i] + 100.0;\n             // }\n"
                },
                {
                    "date": 1692687323815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.1-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.1;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.1;\n+            _dt_cuda2[0] = 0.7;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.1;\n+        _dt_cuda2[0] = 0.7;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.1)\n+    if(_dt_cuda2[0] != 0.7)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n"
                },
                {
                    "date": 1692687359931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.7;\n+            _dt_cuda2[0] = 0.5;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.7;\n+        _dt_cuda2[0] = 0.5;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n+    if(_dt_cuda2[0] != 0.5)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n"
                },
                {
                    "date": 1692687376837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.5;\n+            _dt_cuda2[0] = -1 * ((0.3-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.3;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.5;\n+            _dt_cuda2[0] = 0.3;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.5;\n+        _dt_cuda2[0] = 0.3;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.5)\n+    if(_dt_cuda2[0] != 0.3)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n"
                },
                {
                    "date": 1692687417556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.3-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.3;\n+            _dt_cuda2[0] = -1 * ((0.1-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.1;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.3;\n+            _dt_cuda2[0] = 0.1;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.3;\n+        _dt_cuda2[0] = 0.1;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.3)\n+    if(_dt_cuda2[0] != 0.1)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n"
                },
                {
                    "date": 1692687491267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1202,25 +1202,25 @@\n     {\n         if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n         {\n             // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.1-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.1;\n+            _dt_cuda2[0] = -1 * ((0.05-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.05;\n         }\n         else if(now_pos_gap[0] <= position_sec2[0])\n         {\n             _dt_cuda2[0] = _dt_cuda;\n         }\n         else if(now_pos_gap[0] >= 1.0)\n         {\n-            _dt_cuda2[0] = 0.1;\n+            _dt_cuda2[0] = 0.05;\n         }\n     }\n     else\n     {\n-        _dt_cuda2[0] = 0.1;\n+        _dt_cuda2[0] = 0.05;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.1)\n+    if(_dt_cuda2[0] != 0.05)\n     {\n         // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     }\n     // //////////////////////////////////////////////////////////////\n"
                },
                {
                    "date": 1692687514465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1197,36 +1197,36 @@\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     ////////////////////////////////////////////////////////////////\n-    if(found_goal == 1)\n-    {\n-        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-        {\n-            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.05-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.05;\n-        }\n-        else if(now_pos_gap[0] <= position_sec2[0])\n-        {\n-            _dt_cuda2[0] = _dt_cuda;\n-        }\n-        else if(now_pos_gap[0] >= 1.0)\n-        {\n-            _dt_cuda2[0] = 0.05;\n-        }\n-    }\n-    else\n-    {\n-        _dt_cuda2[0] = 0.05;\n-    }\n-    found_goal = 0;\n-    if(_dt_cuda2[0] != 0.05)\n-    {\n-        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    }\n+    // if(found_goal == 1)\n+    // {\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.7;\n+    //     }\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = 0.7;\n+    // }\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.7)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n     // //////////////////////////////////////////////////////////////\n \n-    // // _dt_cuda2[0] = 0.1;\n+    // _dt_cuda2[0] = 0.1;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n"
                },
                {
                    "date": 1692687573236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1224,9 +1224,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     // //////////////////////////////////////////////////////////////\n \n-    // _dt_cuda2[0] = 0.1;\n+    _dt_cuda2[0] = 0.05;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n"
                },
                {
                    "date": 1692687597589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1544,10 +1544,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        // cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1692687607007,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1614,27 +1614,27 @@\n             {\n                 // _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n                 _return_cost[i] = _return_cost[i] +  cost_xerr[i*_time_window + j];\n             }\n-            if(found_goal_list[i] == 1)\n-            {\n-                if(outputs[i] >= 0.5)\n-                {\n-                    found_goal_list[i] = 0;\n-                }\n-            }\n+            // if(found_goal_list[i] == 1)\n+            // {\n+            //     if(outputs[i] >= 0.5)\n+            //     {\n+            //         found_goal_list[i] = 0;\n+            //     }\n+            // }\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n             _return_cost[i] = _return_cost[i] / _JDOF;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-            if(found_goal_list[i] == 1)\n-            {\n-                found_goal = 1;\n-                // cout<<\"??\"<<endl;\n-                // _return_cost[i] = _return_cost[i];\n-            }\n+            // if(found_goal_list[i] == 1)\n+            // {\n+            //     found_goal = 1;\n+            //     // cout<<\"??\"<<endl;\n+            //     // _return_cost[i] = _return_cost[i];\n+            // }\n             // else\n             // {\n             //     _return_cost[i] = _return_cost[i] + 100.0;\n             // }\n"
                },
                {
                    "date": 1692687710482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,10 +517,10 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 100000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 50000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 200000.0;// + beta[0]; // 50000.0 (10.0) // pos\n     // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n"
                },
                {
                    "date": 1692687748140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,10 +517,10 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 50000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 200000.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 20000.0;// + beta[0]; // 50000.0 (10.0) // pos\n     // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n"
                },
                {
                    "date": 1692687763823,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,10 +517,10 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 5000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 20000.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 50.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 200.0;// + beta[0]; // 50000.0 (10.0) // pos\n     // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n"
                },
                {
                    "date": 1692687770575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,10 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 500000;\n-    double vel_gain = 300.0;//pow(10,6)\n+    double constraint_gain = 5000;\n+    double vel_gain = 10.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n"
                },
                {
                    "date": 1692687793044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1224,9 +1224,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     // //////////////////////////////////////////////////////////////\n \n-    _dt_cuda2[0] = 0.05;\n+    _dt_cuda2[0] = 0.005;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n"
                },
                {
                    "date": 1692687833616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -517,10 +517,10 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 50.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 200.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 5000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 20000.0;// + beta[0]; // 50000.0 (10.0) // pos\n     // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n"
                },
                {
                    "date": 1692687873413,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,10 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 5000;\n-    double vel_gain = 10.0;//pow(10,6)\n+    double constraint_gain = 500000;\n+    double vel_gain = 300.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n@@ -517,10 +517,10 @@\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 5000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 20000.0;// + beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 = 100000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n+    double weight2 = 300000.0;// + beta[0]; // 50000.0 (10.0) // pos\n     // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n     // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n@@ -1224,9 +1224,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     // //////////////////////////////////////////////////////////////\n \n-    _dt_cuda2[0] = 0.005;\n+    _dt_cuda2[0] = 0.05;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n"
                },
                {
                    "date": 1692687885683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -679,9 +679,9 @@\n         // }\n         // else\n         // {\n             tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n+            _matrix_for_cuda[index] = tmptmp + _A[joint_num];\n \n             // if(joint_num == 4)\n             // {\n             //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n"
                },
                {
                    "date": 1692687913259,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1224,9 +1224,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     // //////////////////////////////////////////////////////////////\n \n-    _dt_cuda2[0] = 0.05;\n+    _dt_cuda2[0] = 00.05;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n"
                },
                {
                    "date": 1692687945018,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -679,9 +679,9 @@\n         // }\n         // else\n         // {\n             tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp + _A[joint_num];\n+            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n \n             // if(joint_num == 4)\n             // {\n             //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n@@ -1224,9 +1224,9 @@\n     //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n     // //////////////////////////////////////////////////////////////\n \n-    _dt_cuda2[0] = 00.05;\n+    // // _dt_cuda2[0] = 0.1;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     \n     // _sol_cost = _sol_cost / 5000;\n     // // 200/\n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    // _dt_cuda2[0] = 0.1;\n+    _dt_cuda2[0] = 0.1;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688040066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.1;\n+    _dt_cuda2[0] = 0.005;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688115996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,9 +350,9 @@\n             e[index] = 0.0;\n         }\n         \n     }\n-    // printf(\"state_update OK \\n\");\n+    printf(\"state_update OK \\n\");\n     __syncthreads();\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n"
                },
                {
                    "date": 1692688128003,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -350,9 +350,9 @@\n             e[index] = 0.0;\n         }\n         \n     }\n-    printf(\"state_update OK \\n\");\n+    // printf(\"state_update OK \\n\");\n     __syncthreads();\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n"
                },
                {
                    "date": 1692688142454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -679,9 +679,9 @@\n         // }\n         // else\n         // {\n             tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n+            _matrix_for_cuda[index] = tmptmp + _A[joint_num];\n \n             // if(joint_num == 4)\n             // {\n             //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n"
                },
                {
                    "date": 1692688192600,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -679,9 +679,9 @@\n         // }\n         // else\n         // {\n             tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp + _A[joint_num];\n+            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n \n             // if(joint_num == 4)\n             // {\n             //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n"
                },
                {
                    "date": 1692688292696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -356,9 +356,9 @@\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n-    // printf(\"joint_limit_cost OK \\n\");\n+    printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n"
                },
                {
                    "date": 1692688305433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -356,9 +356,9 @@\n }\n \n __global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n { \n-    printf(\"joint_limit_cost OK \\n\");\n+    // printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n"
                },
                {
                    "date": 1692688326077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,10 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 500000;\n-    double vel_gain = 300.0;//pow(10,6)\n+    double constraint_gain = pow(10,6);\n+    double vel_gain = 1000.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n"
                },
                {
                    "date": 1692688395313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.005;\n+    _dt_cuda2[0] = 0.1;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688455880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -363,10 +363,10 @@\n     // int index2 = index % _time_window ;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = pow(10,6);\n-    double vel_gain = 1000.0;//pow(10,6)\n+    double constraint_gain = 500000;\n+    double vel_gain = 300.0;//pow(10,6)\n     // if(now_gap[0] > gap_limit )\n     // {\n     //     vel_gain =  0.0;\n     // }\n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.1;\n+    _dt_cuda2[0] = 0.005;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688468582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.005;\n+    _dt_cuda2[0] = 0.01;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688569178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1248,9 +1248,9 @@\n     // }\n \n \n     // _dt_cuda2[0] = time_rl[0];\n-    _dt_cuda2[0] = 0.01;\n+    // _dt_cuda2[0] = 0.01;\n \n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n"
                },
                {
                    "date": 1692688574629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1197,33 +1197,33 @@\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     ////////////////////////////////////////////////////////////////\n-    // if(found_goal == 1)\n-    // {\n-    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-    //     {\n-    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-    //     }\n-    //     else if(now_pos_gap[0] <= position_sec2[0])\n-    //     {\n-    //         _dt_cuda2[0] = _dt_cuda;\n-    //     }\n-    //     else if(now_pos_gap[0] >= 1.0)\n-    //     {\n-    //         _dt_cuda2[0] = 0.7;\n-    //     }\n-    // }\n-    // else\n-    // {\n-    //     _dt_cuda2[0] = 0.7;\n-    // }\n-    // found_goal = 0;\n-    // if(_dt_cuda2[0] != 0.7)\n-    // {\n-    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    // }\n+    if(found_goal == 1)\n+    {\n+        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+        {\n+            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        }\n+        else if(now_pos_gap[0] <= position_sec2[0])\n+        {\n+            _dt_cuda2[0] = _dt_cuda;\n+        }\n+        else if(now_pos_gap[0] >= 1.0)\n+        {\n+            _dt_cuda2[0] = 0.7;\n+        }\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = 0.7;\n+    }\n+    found_goal = 0;\n+    if(_dt_cuda2[0] != 0.7)\n+    {\n+        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    }\n     // //////////////////////////////////////////////////////////////\n \n     // // _dt_cuda2[0] = 0.1;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n"
                },
                {
                    "date": 1692688677191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1218,12 +1218,12 @@\n     {\n         _dt_cuda2[0] = 0.7;\n     }\n     found_goal = 0;\n-    if(_dt_cuda2[0] != 0.7)\n-    {\n-        // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    }\n+    // if(_dt_cuda2[0] != 0.7)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n     // //////////////////////////////////////////////////////////////\n \n     // // _dt_cuda2[0] = 0.1;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n"
                },
                {
                    "date": 1692688686248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1544,10 +1544,10 @@\n         GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n         // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n-        // if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        // cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1692688694553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1614,27 +1614,27 @@\n             {\n                 // _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n                 _return_cost[i] = _return_cost[i] +  cost_xerr[i*_time_window + j];\n             }\n-            // if(found_goal_list[i] == 1)\n-            // {\n-            //     if(outputs[i] >= 0.5)\n-            //     {\n-            //         found_goal_list[i] = 0;\n-            //     }\n-            // }\n+            if(found_goal_list[i] == 1)\n+            {\n+                if(outputs[i] >= 0.5)\n+                {\n+                    found_goal_list[i] = 0;\n+                }\n+            }\n             if(outputs[i] > 0.5)\n             {\n                 _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n             }\n             _return_cost[i] = _return_cost[i] / _JDOF;\n             // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-            // if(found_goal_list[i] == 1)\n-            // {\n-            //     found_goal = 1;\n-            //     // cout<<\"??\"<<endl;\n-            //     // _return_cost[i] = _return_cost[i];\n-            // }\n+            if(found_goal_list[i] == 1)\n+            {\n+                found_goal = 1;\n+                // cout<<\"??\"<<endl;\n+                // _return_cost[i] = _return_cost[i];\n+            }\n             // else\n             // {\n             //     _return_cost[i] = _return_cost[i] + 100.0;\n             // }\n"
                },
                {
                    "date": 1692688741585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -679,9 +679,9 @@\n         // }\n         // else\n         // {\n             tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp * 2.0 + _A[joint_num];\n+            _matrix_for_cuda[index] = tmptmp/2.0 + _A[joint_num];\n \n             // if(joint_num == 4)\n             // {\n             //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n"
                },
                {
                    "date": 1692689490655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,21 +360,21 @@\n     // printf(\"joint_limit_cost OK \\n\");\n     // vel pos cost goal\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    int index3 = index % (_time_window*_JDOF);\n+    int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n-    double constraint_gain = 500000;\n+    double constraint_gain = 500000.0;//pow(10,6)\n     double vel_gain = 300.0;//pow(10,6)\n-    // if(now_gap[0] > gap_limit )\n-    // {\n-    //     vel_gain =  0.0;\n-    // }\n-    // else\n-    // {\n-    //     vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n-    // }\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n+    }\n     \n \n     cost_joint_limit[index]=0.0;\n \n@@ -437,17 +437,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        // if(joint_num < 4)\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n+        if(joint_num < 4)\n+        {\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }\n+        else\n+        {\n+            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        }        \n         // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n     // }\n     __syncthreads();\n }\n@@ -509,20 +509,15 @@\n     }\n     __syncthreads();\n }\n \n-// __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n __global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    // double weight1 = 80000.0 + alpha[0]; // 10000.0 (10.0) // rot\n-    // double weight2 = 300000.0 + beta[0]; // 50000.0 (10.0) // pos\n-    double weight1 = 100000.0;// + alpha[0]; // 10000.0 (10.0) // rot\n-    double weight2 = 300000.0;// + beta[0]; // 50000.0 (10.0) // pos\n-    // double weight1 = alpha[0]; // 10000.0 (10.0) // rot\n-    // double weight2 = beta[0]; // 50000.0 (10.0) // pos\n+    double weight1 =  alpha[0];// 80000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  beta[0];// 300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n@@ -536,9 +531,9 @@\n         for(int i = 0; i<3; i++)\n         {\n             PosEE_index[i] = position[index*3+i];\n         }\n-        PosEE_index[2] = PosEE_index[2];\n+        PosEE_index[2] = PosEE_index[2] - 0.01;\n \n         double RotGoalT_x_RotEE[9];\n         double RotGap[3];\n \n@@ -576,13 +571,13 @@\n             // }\n             cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n         }\n \n-        // if(PosGap_2 > gap_limit )\n-        // {\n-        //     cost3 = weight1 * 3.14 * 3 * 2;\n-        //     weight1 =  0.0;            \n-        // }\n+        if(PosGap_2 > gap_limit )\n+        {\n+            cost3 = weight1 * 3.14 * 3 * 2;\n+            weight1 =  0.0;            \n+        }\n         // else\n         // {\n         //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n         // }\n@@ -604,18 +599,18 @@\n         // {\n         //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n         // }\n \n-/////////////////////////////////////// 학습용 전까지 일반 코드 ///////////////////////////////////////////////////////////////////////////////////////////////////////\n+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n         if(cost2_2 >  position_sec1[0])\n         {\n-            cost1 = _time_window*_time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n         else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n         {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n             // cost2 = weight_manipul * (1-_manipulability[index]);\n         }\n         ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n         else\n@@ -629,12 +624,9 @@\n         {\n             cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n         }\n         // f[index] = cost1 + cost2 + cost3;\n-        f[index] = cost1;// + cost3;\n-\n-        ///////////////////////  학습용 ///////////////////////\n-        // f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n+        f[index] = cost1 + cost3;\n //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n \n \n \n@@ -655,14 +647,13 @@\n     }    \n     __syncthreads();\n }\n \n-__global__ void generate_random2(double* _A, double* _matrix_for_cuda)\n+__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n {\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     int index3 = index % (_time_window*_JDOF);\n     int joint_num = index3 / _time_window;\n-    double tmptmp = 0.0;\n     // curandState localState = state[index%_time_window];\n     curandState state;\n     \n     // 현재 스레드의 인덱스로 상태 정보 초기화\n@@ -678,19 +669,10 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            tmptmp = curand_normal(&state);\n-            _matrix_for_cuda[index] = tmptmp/2.0 + _A[joint_num];\n-\n-            // if(joint_num == 4)\n-            // {\n-            //     printf(\"tmptmp : %f, _A[4] : %f, _matrix_for_cuda[4] : %f\\n\",tmptmp, _A[joint_num], _matrix_for_cuda[index]);\n-            // }\n-            \n-            // printf(\"_A[joint_num] : %f\\n\",_A[joint_num]);\n-            // printf(\"_matrix_for_cuda[joint_num] : %f\\n\",_matrix_for_cuda[index]);\n-            // printf(\"\\n\");\n+            _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n             // if(joint_num>=4)\n             // {\n             //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n             // }\n@@ -701,9 +683,8 @@\n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n-            // printf(\"_matrix_for_cuda[%d] : %f \\n\",index,_matrix_for_cuda[index]);\n         }\n     }\n     // printf(\"generate_random2 OK \\n\");\n     __syncthreads();\n@@ -1173,19 +1154,16 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *time_rl, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n     // {\n     //     cout<<_goal_pos_cuda[i]<<endl;    \n     // }\n-    // cout<<\"alpha : \"<<alpha[0]<<endl;\n-    // cout<<\"beta : \"<<beta[0]<<endl;\n-    // cout<<\"time_rl : \"<<time_rl[0]<<endl;\n     \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n     for(int i = 0; i<3; i++)\n@@ -1197,61 +1175,52 @@\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n     // }\n     ////////////////////////////////////////////////////////////////\n-    if(found_goal == 1)\n-    {\n-        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-        {\n-            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-        }\n-        else if(now_pos_gap[0] <= position_sec2[0])\n-        {\n-            _dt_cuda2[0] = _dt_cuda;\n-        }\n-        else if(now_pos_gap[0] >= 1.0)\n-        {\n-            _dt_cuda2[0] = 0.7;\n-        }\n-    }\n-    else\n-    {\n-        _dt_cuda2[0] = 0.7;\n-    }\n-    found_goal = 0;\n-    // if(_dt_cuda2[0] != 0.7)\n+    // if(found_goal == 1)\n     // {\n-    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.7;\n+    //     }\n     // }\n-    // //////////////////////////////////////////////////////////////\n-\n-    // // _dt_cuda2[0] = 0.1;\n-    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    \n-    // _sol_cost = _sol_cost / 5000;\n-    // // 200/\n-\n-    // if(_sol_cost > 700)\n+    // else\n     // {\n-    //     _dt_cuda2[0] = 0.5;\n+    //     _dt_cuda2[0] = 0.7;\n     // }\n-    // else if(_sol_cost <= 700 && _sol_cost > 1)\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.7)\n     // {\n-    //     _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n-    //         //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-    //         // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-    //     // _dt_cuda2[0] = 0.003;\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n     // }\n-    // else\n-    // {\n-    //     _dt_cuda2[0] = _dt_cuda;\n-    // }\n+    //////////////////////////////////////////////////////////////\n+    _sol_cost = _sol_cost / 5000;\n+    // 200/\n \n-\n-    // _dt_cuda2[0] = time_rl[0];\n-    // _dt_cuda2[0] = 0.01;\n-\n+    if(_sol_cost > 700)\n+    {\n+        _dt_cuda2[0] = 0.5;\n+    }\n+    else if(_sol_cost <= 700 && _sol_cost > 1)\n+    {\n+        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n+            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        // _dt_cuda2[0] = 0.003;\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = _dt_cuda;\n+    }\n     // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n \n     reset_check = 0;\n@@ -1286,9 +1255,9 @@\n     if(control_mode == 0)\n     {\n         cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__matrix_for_cuda);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n \n         cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n@@ -1423,29 +1392,27 @@\n     }\n \n     else if(control_mode == 1)\n     {\n-        // cout<<endl;\n         // for(int i= 0; i<7; i++)\n         // {\n         //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n         // }\n-        // cout<<endl;\n         \n         cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__matrix_for_cuda);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n         cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         for(int i = 0; i<N; i++)\n         {\n             int index222 = i / _time_window;\n             if((i%_time_window) != 0)\n             {   \n                 _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n-                // if((i%_time_window) >= _time_window-_dt2_window)\n-                // {\n-                //     _matrix_for_cuda[i] = _matrix_for_cuda[i];\n-                // }                \n+                if((i%_time_window) >= _time_window-_dt2_window)\n+                {\n+                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n+                }                \n             }\n             // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n         }\n \n@@ -1524,14 +1491,8 @@\n         cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n         cudaDeviceSynchronize();\n-\n-        // for(int i = 0 ; i < 3 * _sampling_num * _time_window; i++)\n-        // {\n-        //     cout<<\"orientation_EE[\"<<i<<\"] : \"<<orientation_EE[i]<<endl;\n-        // }\n-        // cout<<\n         \n         cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n@@ -1554,10 +1515,9 @@\n         \n \n         cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap, dev_alpha, dev_beta);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n@@ -1583,9 +1543,9 @@\n         cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n         forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n         cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n-        // cout<<\"?????\"<<endl;\n+\n         // for(int i = 0; i<_sampling_num; i++)\n         // {\n         //     if(outputs[i]>0.5)\n         //     {\n@@ -1599,10 +1559,9 @@\n             for(int j = 0; j<_JDOF; j++)\n             {\n                 for(int k = 0; k<_time_window; k++)\n                 {\n-                    // _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n-                    _return_cost[i] = _return_cost[i] + cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                 }\n                 // if(j == _JDOF-1)\n                 // {\n                 //     _return_cost[i] = _return_cost[i] / _JDOF;\n@@ -1611,10 +1570,9 @@\n             // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n \n             for(int j = 0 ; j<_time_window; j++)\n             {\n-                // _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n-                _return_cost[i] = _return_cost[i] +  cost_xerr[i*_time_window + j];\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n             }\n             if(found_goal_list[i] == 1)\n             {\n                 if(outputs[i] >= 0.5)\n@@ -1645,30 +1603,23 @@\n         // _sol_cost = 0.0;\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n-            _cost[i] = _return_cost[i];// / 10000.0;\n+            _cost[i] = _return_cost[i];\n             if(_min_cost > _cost[i])\n             {\n                 _min_cost = _cost[i];\n             }\n         }\n         _sol_cost = _min_cost;\n-        // cout<<endl;\n-        // cout<<\"_min_cost : \"<<_min_cost<<endl;\n         memset(_weighted_A, 0, _JDOF * sizeof(double));\n \n         for(int i = 0; i<_sampling_num; i++)\n         {\n-            // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n-            // _cost[i] = _cost[i] / 100.0;\n             _cost[i] = _cost[i] - _min_cost;\n             if(_cost[i]<100)\n             {\n-                // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n                 _cost[i] = exp(-_cost[i]);\t\t\n-                // cout<<\"_cost[\"<<i<<\"] : \"<<_cost[i]<<endl;\n-                \n                 weight_sum = weight_sum + _cost[i];\n                 for(int j = 0; j<_JDOF; j++)\n                 {\n                     _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n@@ -1695,9 +1646,9 @@\n         // }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n-            returnArray[(_JDOF*2)+i] = _weighted_A[i];// * (1+_dt_cuda);\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n             returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n             returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n \n             _q_des[i] = returnArray[i];\n@@ -1707,80 +1658,82 @@\n }\n \n void CudaTest::load_weight()\n {\n-    std::ostringstream filename_NN2[6];\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_3/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n         }\n     }\n-\n     #elif _nodes_cuda == 64\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n         } \n     }\n     #elif _nodes_cuda == 100\n     {\n         for(int i = 0; i<6; i++)\n         {\n-            filename_NN2[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n         } \n     }\n     #else\n     #endif\n-    ifstream weight0;\n-    weight0.open(filename_NN2[0].str());\n+    \n+    weight0.open(filename_NN[0].str());\n     for(int i = 0; i<_JDOF ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n             weight0 >> weights0[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    weight0.open(filename_NN2[1].str());\n+    \n+    weight0.open(filename_NN[1].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights1[i];\n     }\n     weight0.close();\n-    weight0.open(filename_NN2[2].str());\n+\n+    weight0.open(filename_NN[2].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         for(int j = 0; j<_nodes_cuda ; j++)\n         {\n             weight0 >> weights2[i*_nodes_cuda + j];\n         }\n     }\n     weight0.close();\n-    weight0.open(filename_NN2[3].str());\n+\n+    weight0.open(filename_NN[3].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights3[i];\n     }\n     weight0.close();\n-    weight0.open(filename_NN2[4].str());\n+\n+    weight0.open(filename_NN[4].str());\n     for(int i = 0; i<_nodes_cuda ; i++)\n     {\n         weight0 >> weights4[i];\n     }\n     weight0.close();\n-    weight0.open(filename_NN2[5].str());\n+    weight0.open(filename_NN[5].str());\n     weight0 >> weights5[0];\n     weight0.close();\n }\n \n void CudaTest::cpu_memory_save()\n {\n     // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n     memset(cost_jointlimit, 0, N * sizeof(double));\n-    // memset(_mean_matrix, 0, N * sizeof(double));\n+    memset(_mean_matrix, 0, N * sizeof(double));\n     memset(d, 0, N * sizeof(double));\n     memset(e, 0, N * sizeof(double));\n     memset(f, 0, N * sizeof(double));\n     memset(_matrix_for_cuda, 0, N * sizeof(double));\n@@ -1969,11 +1922,8 @@\n }\n \n void CudaTest::initialize()\n {\n-    // cpu_memory_save();\n-    // load_weight();\n-    memset(_A, 0, _JDOF * sizeof(double));\n     // cout<<endl;\n     // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n     // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n     // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n@@ -2018,9 +1968,8 @@\n \t_min_joint_position[1] = -1.7628;\n \t_min_joint_position[2] = -2.8973;\n \t_min_joint_position[3] = -3.0718;\n \t_min_joint_position[4] = -2.8973;\n-    // _min_joint_position[4] = 0.0;\n \t_min_joint_position[5] = -0.0175;\n \t_min_joint_position[6] = -2.8973;\n \n \t_max_joint_position[0] = 2.8973;\n@@ -2053,10 +2002,22 @@\n     // _hat_max_joint_position[5] = 3.43134;\n \n     // _hat_min_joint_position[6] = -2.37368;\n     // _hat_max_joint_position[6] = 2.37368;\n+\n+\n+\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n+    }\n+\n     FK_a[0] = 0.0;\n-    FK_d[0] = 0.333;\n+    FK_d[0] = 0.343;\n     FK_alpha[0] = 0.0;\n \n     FK_a[1] = 0.0;\n     FK_d[1] = 0.0;\n@@ -2088,20 +2049,5 @@\n \n     FK_a[8] = 0.0;\n     FK_d[8] = 0.1034;\n     FK_alpha[8] = 0.0;\n-\n-\n-    for(int i = 0; i<_JDOF; i++)\n-    {\n-        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n-    }\n-}\n-\n-void CudaTest::RL_initialize()\n-{\n-    memset(_A, 0, _JDOF * sizeof(double));\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1692689520139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,10 +514,10 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  alpha[0];// 80000.0; // 10000.0 (10.0) // rot\n-    double weight2 =  beta[0];// 300000.0; // 50000.0 (10.0) // pos\n+    double weight1 =  80000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n     {\n"
                },
                {
                    "date": 1692689526776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,9 +509,9 @@\n     }\n     __syncthreads();\n }\n \n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap, double *alpha, double *beta)\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n"
                },
                {
                    "date": 1692689554208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1154,9 +1154,9 @@\n         }\n     }\n }\n \n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *alpha, double *beta, double *returnArray)\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n { \n     // cout<<\"cuda code start\"<<endl;\n     // _dt_cuda2[0] = 0.5;\n     // for(int i = 0; i<6; i++)\n"
                },
                {
                    "date": 1692689567749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1513,9 +1513,9 @@\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n-        cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n         cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n         cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n"
                },
                {
                    "date": 1692689575460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1514,10 +1514,10 @@\n         cudaDeviceSynchronize();\n         \n \n         // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap,dev_alpha,dev_beta);\n+        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n         cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         // for(int i = 0; i<_sampling_num * _time_window; i++)\n         // {\n"
                },
                {
                    "date": 1692689637136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1658,8 +1658,10 @@\n }\n \n void CudaTest::load_weight()\n {\n+    ostringstream filename_NN2[6];\n+    ifstream weight0;\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n         {\n"
                },
                {
                    "date": 1692689643378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1658,9 +1658,9 @@\n }\n \n void CudaTest::load_weight()\n {\n-    ostringstream filename_NN2[6];\n+    ostringstream filename_NN[6];\n     ifstream weight0;\n     #if _nodes_cuda == 32\n     {\n         for(int i = 0; i<6; i++)\n"
                },
                {
                    "date": 1692693866637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1646,9 +1646,9 @@\n         // }\n         \n         for(int i = 0; i<_JDOF; i++)\n         {\n-            returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i] ;//* (1+_dt_cuda2[0]-_dt_cuda);\n             returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n             returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n \n             _q_des[i] = returnArray[i];\n"
                },
                {
                    "date": 1692694114912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -437,17 +437,17 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num < 4)\n+        if(joint_num == 4)\n         {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         }\n-        else\n-        {\n-            // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-            cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }        \n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n         // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n     // }\n     __syncthreads();\n }\n"
                },
                {
                    "date": 1692694887439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,9 +514,9 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  80000.0; // 10000.0 (10.0) // rot\n+    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n     double weight2 =  300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1692772988776,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,9 +514,9 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n+    double weight1 =  200000.0; // 10000.0 (10.0) // rot\n     double weight2 =  300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1692773043764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,9 +514,9 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  200000.0; // 10000.0 (10.0) // rot\n+    double weight1 =  150000.0; // 10000.0 (10.0) // rot\n     double weight2 =  300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1692773076962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -514,9 +514,9 @@\n {\n     // printf(\"cost_function_task_space_control OK \\n\");\n     int index = threadIdx.x + blockIdx.x * blockDim.x;\n     // int index2 = index % _time_window ;\n-    double weight1 =  150000.0; // 10000.0 (10.0) // rot\n+    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n     double weight2 =  300000.0; // 50000.0 (10.0) // pos\n     // double weight_manipul = 100.0;\n \n     if(index < _sampling_num * _time_window)\n"
                },
                {
                    "date": 1692773204278,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -669,18 +669,18 @@\n         //     _matrix_for_cuda[index] = 0.0;\n         // }\n         // else\n         // {\n-            _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            // _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n             // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n-            // if(joint_num>=4)\n-            // {\n-            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            // }\n-            // else\n-            // {\n-            //     _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            // }            \n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            }            \n         // }\n         if(abs_cuda1(_matrix_for_cuda[index])>100)\n         {\n             _matrix_for_cuda[index] = 0.0;   \n"
                },
                {
                    "date": 1692773500947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -437,12 +437,12 @@\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         // }  \n \n-        if(joint_num == 4)\n-        {\n+        // if(joint_num == 4)\n+        // {\n             cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        }\n+        // }\n         // else\n         // {\n         //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n         //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n"
                },
                {
                    "date": 1692773651293,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 500000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 0.0;//pow(10,6)\n     if(now_gap[0] > gap_limit )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1692777142478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1165,12 +1165,13 @@\n     // }\n     \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n+    now_pos_gap[1] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n-        // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+        now_pos_gap[1] = now_pos_gap[1] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n"
                },
                {
                    "date": 1692777157376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1165,9 +1165,9 @@\n     // }\n     \n     prev_x_cost = 0.0;\n     now_pos_gap[0] = 0.0;\n-    now_pos_gap[1] = 0.0;\n+    now_pos_gap_all[0] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n         now_pos_gap[1] = now_pos_gap[1] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n"
                },
                {
                    "date": 1692777165246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1169,9 +1169,9 @@\n     now_pos_gap_all[0] = 0.0;\n     for(int i = 0; i<3; i++)\n     {\n         now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n-        now_pos_gap[1] = now_pos_gap[1] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+        now_pos_gap_all[0] = now_pos_gap_all[0] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n     }\n     // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n     // {\n     //     _dt_cuda2[0] = now_pos_gap[0];\n"
                },
                {
                    "date": 1692777211175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1508,9 +1508,9 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n+        cudaMemcpy(dev_now_pos_gap, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n         joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n@@ -1850,9 +1850,10 @@\n     cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n     cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n     cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n+    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double));\n+    cudaMalloc((void**)&dev_now_pos_gap_all, sizeof(double));\n     cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n     cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n \n     cudaMalloc((void**)&dev_alpha, sizeof(double));\n"
                },
                {
                    "date": 1692777217480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1508,10 +1508,10 @@\n         Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n \n         if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n         cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n+        cudaMemcpy(dev_now_pos_gap_all, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap_all);\n         cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n         cudaDeviceSynchronize();\n         \n \n"
                },
                {
                    "date": 1692777228400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2057 @@\n+#include <cuda_runtime.h>\n+#include <device_launch_parameters.h>\n+#include \"cuda.cuh\"\n+\n+#define THREADS_PER_BLOCK _sampling_num\n+#define THREADS_PER_BLOCK2 _sampling_num\n+\n+// device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n+\n+\n+CudaTest::CudaTest(void)\n+{   \n+}\n+\n+CudaTest::~CudaTest(void)\n+{    \n+    \n+}\n+\n+__device__ double sigmoid(double x) {\n+    return 1.0 / (1.0 + expf(-x));\n+}\n+\n+__device__ double abs_cuda1(double x) {\n+    if(x<0)\n+    {\n+        return -x;\n+    }\n+    else\n+    {\n+        return x;\n+    }\n+}\n+\n+__device__ double abs_cuda2(double x, double y) {\n+    if(x-y<0)\n+    {\n+        return -x+y;\n+    }\n+    else\n+    {\n+        return x-y;\n+    }\n+}\n+\n+__device__ double pow2_cuda(double x) {\n+    return x*x;\n+}\n+\n+\n+__device__ double norm2_vector3(double *x)\n+{\n+    double _norm2 = 0.0;\n+    for(int i = 0; i<3; i++)\n+    {\n+        _norm2 = _norm2 + (x[i] * x[i]);\n+    }\n+    _norm2 = sqrt(_norm2);\n+    return _norm2;\n+}\n+\n+__device__ double calculateSingularValue(double* matrix) \n+{\n+    int row = threadIdx.y;\n+    int col = threadIdx.x;\n+    \n+    // 3x3 행렬의 크기를 정의\n+    int matrixSize = 3;\n+    \n+    // 행렬의 요소를 읽음\n+    double element = matrix[row * matrixSize + col];\n+    double singularValue = 0.0;\n+    \n+    // 행렬의 특잇값은 고유값의 제곱근이므로 제곱을 계산\n+    element *= element;\n+    \n+    // 각 스레드마다 계산한 제곱된 특잇값을 공유 메모리에 저장\n+    __shared__ double sharedData[9];\n+    sharedData[row * matrixSize + col] = element;\n+    \n+    // 동기화\n+    __syncthreads();\n+    \n+    // 공유 메모리의 값을 최대값으로 업데이트\n+    if (threadIdx.x == 0 && threadIdx.y == 0) {\n+        double maxVal = 0.0;\n+        for (int i = 0; i < 9; i++) {\n+            if (sharedData[i] > maxVal) {\n+                maxVal = sharedData[i];\n+            }\n+        }\n+        singularValue = sqrt(maxVal);\n+    }\n+    return singularValue;\n+}\n+\n+__device__ void computeTransformationMatrix(double alpha, double a, double d, double theta, double* matrix) \n+{\n+    double cosTheta = cos(theta);\n+    double sinTheta = sin(theta);\n+    double cosAlpha = cos(alpha);\n+    double sinAlpha = sin(alpha);\n+\n+    matrix[0] = cosTheta;\n+    matrix[1] = -sinTheta;\n+    matrix[2] = 0;\n+    matrix[3] = a;\n+\n+    matrix[4] = sinTheta * cosAlpha;\n+    matrix[5] = cosTheta * cosAlpha;\n+    matrix[6] = -sinAlpha;\n+    matrix[7] = -d * sinAlpha;\n+\n+    matrix[8] = sinTheta * sinAlpha;\n+    matrix[9] = cosTheta * sinAlpha;\n+    matrix[10] = cosAlpha;\n+    matrix[11] = d * cosAlpha;\n+    \n+    matrix[12] = 0.0;\n+    matrix[13] = 0.0;\n+    matrix[14] = 0.0;\n+    matrix[15] = 1.0;\n+}\n+\n+__device__ void matrixMultiply_4x4(double *mat1, double *mat2, double *mat3)\n+{\n+    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[4] + mat1[2] * mat2[8] + mat1[3] * mat2[12];\n+    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[5] + mat1[2] * mat2[9] + mat1[3] * mat2[13];\n+    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[6] + mat1[2] * mat2[10] + mat1[3] * mat2[14];\n+    mat3[3] = mat1[0] * mat2[3] + mat1[1] * mat2[7] + mat1[2] * mat2[11] + mat1[3] * mat2[15];\n+\n+    mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[4] + mat1[6] * mat2[8] + mat1[7] * mat2[12];\n+    mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[5] + mat1[6] * mat2[9] + mat1[7] * mat2[13];\n+    mat3[6] = mat1[4] * mat2[2] + mat1[5] * mat2[6] + mat1[6] * mat2[10] + mat1[7] * mat2[14];\n+    mat3[7] = mat1[4] * mat2[3] + mat1[5] * mat2[7] + mat1[6] * mat2[11] + mat1[7] * mat2[15];\n+\n+    mat3[8] = mat1[8] * mat2[0] + mat1[9] * mat2[4] + mat1[10] * mat2[8] + mat1[11] * mat2[12];\n+    mat3[9] = mat1[8] * mat2[1] + mat1[9] * mat2[5] + mat1[10] * mat2[9] + mat1[11] * mat2[13];\n+    mat3[10] = mat1[8] * mat2[2] + mat1[9] * mat2[6] + mat1[10] * mat2[10] + mat1[11] * mat2[14];\n+    mat3[11] = mat1[8] * mat2[3] + mat1[9] * mat2[7] + mat1[10] * mat2[11] + mat1[11] * mat2[15];\n+\n+    mat3[12] = mat1[12] * mat2[0] + mat1[13] * mat2[4] + mat1[14] * mat2[8] + mat1[15] * mat2[12];\n+    mat3[13] = mat1[12] * mat2[1] + mat1[13] * mat2[5] + mat1[14] * mat2[9] + mat1[15] * mat2[13];\n+    mat3[14] = mat1[12] * mat2[2] + mat1[13] * mat2[6] + mat1[14] * mat2[10] + mat1[15] * mat2[14];\n+    mat3[15] = mat1[12] * mat2[3] + mat1[13] * mat2[7] + mat1[14] * mat2[11] + mat1[15] * mat2[15];\n+}\n+\n+__device__ void matrixMultiply_3x3(double *mat1, double *mat2, double *mat3)\n+{\n+    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[3] + mat1[2] * mat2[6];\n+    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[4] + mat1[2] * mat2[7];\n+    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[5] + mat1[2] * mat2[8];\n+\n+    mat3[3] = mat1[3] * mat2[0] + mat1[4] * mat2[3] + mat1[5] * mat2[6];\n+    mat3[4] = mat1[3] * mat2[1] + mat1[4] * mat2[4] + mat1[5] * mat2[7];\n+    mat3[5] = mat1[3] * mat2[2] + mat1[4] * mat2[5] + mat1[5] * mat2[8];\n+\n+    mat3[6] = mat1[6] * mat2[0] + mat1[7] * mat2[3] + mat1[8] * mat2[6];\n+    mat3[7] = mat1[6] * mat2[1] + mat1[7] * mat2[4] + mat1[8] * mat2[7];\n+    mat3[8] = mat1[6] * mat2[2] + mat1[7] * mat2[5] + mat1[8] * mat2[8];\n+}\n+\n+__device__ void rpy_from_transformationmatrix(double *RotMat, double *rpy)\n+{\n+    // rpy[1] = RotMat[8];\n+    rpy[1] = -asin(RotMat[8]);\n+    if(RotMat[8] > 1.0 - _threshold_cuda && RotMat[8] < 1.0 + _threshold_cuda)\n+    {\n+        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else if (RotMat[8] < -1.0 + _threshold_cuda && RotMat[8] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n+    {//Gimbal lock, pitch = 90deg\n+        rpy[0] = atan2(RotMat[1], RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else //general solution\n+    {\n+        rpy[0] = atan2(RotMat[9], RotMat[10]);\n+        rpy[2] = atan2(RotMat[4], RotMat[0]);\n+    }\n+}\n+\n+__device__ void rpy_from_rotationmatrix(double *RotMat, double *rpy)\n+{\n+    // rpy[1] = RotMat[8];\n+    rpy[1] = -asin(RotMat[6]);\n+    if(RotMat[6] > 1.0 - _threshold_cuda && RotMat[6] < 1.0 + _threshold_cuda)\n+    {\n+        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else if (RotMat[6] < -1.0 + _threshold_cuda && RotMat[6] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n+    {//Gimbal lock, pitch = 90deg\n+        rpy[0] = atan2(RotMat[1], RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else //general solution\n+    {\n+        rpy[0] = atan2(RotMat[7], RotMat[8]);\n+        rpy[2] = atan2(RotMat[3], RotMat[0]);\n+    }\n+}\n+\n+__device__ void determinant_6x6(double *matrix, double result)\n+{\n+    int tid = threadIdx.x;\n+    int stride = blockDim.x;\n+\n+    double temp[6][6];\n+    for (int i = 0; i < 6; i++) {\n+        for (int j = 0; j < 6; j++) {\n+            temp[i][j] = matrix[i * 6 + j];\n+        }\n+    }\n+\n+    for (int k = 0; k < 6 - 1; k++) {\n+        for (int i = k + 1 + tid; i < 6; i += stride) {\n+            double ratio = temp[i][k] / temp[k][k];\n+            for (int j = k; j < 6; j++) {\n+                temp[i][j] -= ratio * temp[k][j];\n+            }\n+        }\n+        __syncthreads();\n+    }\n+\n+    if (tid == 0) {\n+        result = 1.0;\n+        for (int i = 0; i < 6; i++) {\n+            result *= temp[i][i];\n+        }\n+    }\n+}\n+\n+__global__ void cal_jacobian(double *theta_table, double *_jacobian)\n+{\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index/_time_window;\n+    int index3 = index*6*_JDOF;\n+    // double theta[7];\n+\n+    if(index<_sampling_num )\n+    {\n+        \n+        // for(int i = 0; i<_JDOF;)\n+        // {\n+        //     theta[i]= theta_table[(index*_JDOF*_time_window)+(_time_window*i)+(_time_window-1)];\n+        // }\n+\n+        double cash = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_1 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_2 = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_3 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        double cash0 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash0_1 = (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        double cash1 = (sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n+        double cash2 = ((-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]));\n+        double cash2_2 = (cash2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        double cash3 = ((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + cash*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        double cash4 = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);    \n+\n+        _jacobian[index3 + 0] = ((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+(((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+((-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))-768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-632)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n+        _jacobian[index3 + 1] = (176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cash+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+632)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n+        _jacobian[index3 + 2] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 3] = (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*cash;\n+        _jacobian[index3 + 4] = -cash0_1*cash1 + (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n+        _jacobian[index3 + 5] = -cash0_1*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        _jacobian[index3 + 6] = 0.0;\n+\n+        _jacobian[index3 + 7] = 11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400;\n+        _jacobian[index3 + 8] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 9] = -(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) + (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 10] =  -(sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125)*cash;\n+        _jacobian[index3 + 11] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*cash1 - (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n+        _jacobian[index3 + 12] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) - (cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        _jacobian[index3 + 13] = 0.0;\n+\n+        _jacobian[index3 + 14] = 0.0;\n+        _jacobian[index3 + 15] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 16] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 17] = (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125);\n+        _jacobian[index3 + 18] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])) + cash0_1*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n+        _jacobian[index3 + 19] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + cash0_1*(cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        _jacobian[index3 + 20] = 0.0;\n+\n+        _jacobian[index3 + 21] = 0.0;\n+        _jacobian[index3 + 22] = -sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 23] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 24] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 25] = -(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4;\n+        _jacobian[index3 + 26] = cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 27] = cash2_2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+\n+        _jacobian[index3 + 28] = 0.0;\n+        _jacobian[index3 + 29] = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 30] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 31] = cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        _jacobian[index3 + 32] = -(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n+        _jacobian[index3 + 33] = ((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 34] = (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+\n+        _jacobian[index3 + 35] = 1.0;\n+        _jacobian[index3 + 36] = 0.0;\n+        _jacobian[index3 + 37] = cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 38] = -cash;\n+        _jacobian[index3 + 39] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n+        _jacobian[index3 + 40] = (-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 41] = cash3*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - cash1*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+    }\n+    //  __syncthreads();\n+}\n+\n+__global__ void Transpose_Matrix_3x3(double *input, double *output)\n+{\n+    // printf(\"Transpose_Matrix_3x3 OK \\n\");\n+    output[0] = input[0];\n+    output[1] = input[3];\n+    output[2] = input[6];\n+\n+    output[3] = input[1];\n+    output[4] = input[4];\n+    output[5] = input[7];\n+\n+    output[6] = input[2];\n+    output[7] = input[5];\n+    output[8] = input[8];\n+}\n+\n+__global__ void state_update(double *a, double *b, double *c, double *d, double *e, double *_dt_cuda2){\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index2 = index % _time_window;\n+    int index3 = index % (_time_window * _JDOF);\n+    int joint_num = index3 / _time_window;\n+\n+    if (index2 == 0)\n+    {\n+        d[index] = b[joint_num] + (_dt_cuda * a[index]); // 속도\n+        e[index] = c[joint_num] + (_dt_cuda * d[index]); // 위치\n+    }\n+    else\n+    {\n+        if(index2 >= _time_window-_dt2_window)\n+        {\n+            d[index] = _dt_cuda2[0] * a[index];\n+            e[index] = 0.0;\n+        }\n+        else\n+        {\n+            d[index] = _dt_cuda * a[index];\n+            e[index] = 0.0;\n+        }\n+        \n+    }\n+    // printf(\"state_update OK \\n\");\n+    __syncthreads();\n+}\n+\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n+{ \n+    // printf(\"joint_limit_cost OK \\n\");\n+    // vel pos cost goal\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index % _time_window ;\n+    int index3 = index % (_time_window*7);\n+    int joint_num = index3 / _time_window;\n+\n+    double constraint_gain = 500000.0;//pow(10,6)\n+    double vel_gain = 300.0;//pow(10,6)\n+    if(now_gap[0] > gap_limit )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n+    }\n+    \n+\n+    cost_joint_limit[index]=0.0;\n+\n+    // if(index2 >= _time_window-5)\n+    // {   \n+        // if(now_gap[0] > 0.3)\n+        // {\n+        //     if(position[index] < min_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        //     }\n+\n+        //     else if(position[index] > max_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        //     }\n+        // }\n+        // else\n+        // {\n+        //     if(position[index] < min_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        //     }\n+\n+        //     else if(position[index] > max_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        //     }\n+        // }\n+\n+    // }\n+    // else\n+    // {\n+        if(position[index] <= min_joint_limit[joint_num])\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        }\n+\n+        else if(position[index] >= max_joint_limit[joint_num])\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        }\n+        else\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n+        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n+        }\n+        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }  \n+\n+        // if(joint_num == 4)\n+        // {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n+        // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+    // }\n+    __syncthreads();\n+}\n+\n+__global__ void cost_function_joint_control(double *d, double *e, double *f, double *g, double *position_sec1, double *position_sec2, double *velocity_lim, double *acc, double *prev_acc, double *min_joint_limit, double *max_joint_limit)\n+{\n+    // vel pos cost goal\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index3 = index % (_time_window*7);\n+    int joint_num = index3 / _time_window;\n+\n+    double cost_pos =  abs_cuda2(e[index],g[joint_num]);// + pow(10,2);// * abs(_vel_state(i,j));// + abs(_acc_state(i,j));\n+\tdouble cost_vel =  abs_cuda1(d[index]);\n+    double cost_acc =  abs_cuda2(acc[index],prev_acc[index]);\n+    double pos_gain = 10000.0;//pow(10,4)\n+    double vel_gain = 100.0;//pow(10,1)\n+    double constraint_gain = 10000000.0;//pow(10,6)\n+\n+    if(abs_cuda1(cost_pos) >  position_sec1[0])\n+    {\n+        f[index] = 10000.0 + pos_gain * cost_pos + vel_gain * cost_vel;// + 1.0 * cost_acc;\n+        // printf(\"sec1\\n\");\n+        // printf(\"sec1 : cost[%d] : %f \\n\", index,f[index]);\n+        // printf(\"sec1 : pos[%d] : %f \\n\", index,e[index]);\n+        // printf(\"sec1 : vel[%d] : %f \\n\", index,d[index]);\n+        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n+    }\n+\t///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+\telse if(abs_cuda1(cost_pos) <= position_sec1[0] && abs_cuda1(cost_pos) > position_sec2[0])\n+\t{\n+\t\tf[index] = 1000.0 + pos_gain * cost_pos + vel_gain * cost_vel;\n+        // printf(\"sec2\\n\");\n+        // printf(\"sec2 : cost[%d] : %f \\n\", index,f[index]);\n+        // printf(\"sec2 : pos[%d] : %f \\n\", index,e[index]);\n+        // printf(\"sec2 : vel[%d] : %f \\n\", index,d[index]);\n+        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n+    }\n+\t///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+\telse\n+\t{\n+\t\tf[index] = pos_gain * cost_pos + vel_gain * cost_vel;\n+    }\n+\n+\t///////////////////// Velocity Limit Constraint ///////////////////////////////////////////////////\n+\tif(abs_cuda1(cost_vel) > velocity_lim[0]) // 0.8\n+\t{\n+\t\tf[index] = f[index] + constraint_gain * cost_vel;\n+\t}\n+\n+    ///////////////////// Joint Limit Constraint   ///////////////////////////////////////////////////\n+    if(e[index] < min_joint_limit[joint_num])\n+    {\n+        f[index] = f[index] + constraint_gain * (e[index] - min_joint_limit[joint_num]) * (e[index] - min_joint_limit[joint_num]);\n+    }\n+\n+    else if(e[index] > max_joint_limit[joint_num])\n+    {\n+        f[index] = f[index] + constraint_gain * (e[index] - max_joint_limit[joint_num]) * (e[index] - max_joint_limit[joint_num]);\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+{\n+    // printf(\"cost_function_task_space_control OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index % _time_window ;\n+    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  300000.0; // 50000.0 (10.0) // pos\n+    // double weight_manipul = 100.0;\n+\n+    if(index < _sampling_num * _time_window)\n+    {\n+        double rotation_EE_index[9];\n+        for(int i = 0; i<9; i++)\n+        {\n+            rotation_EE_index[i] = rotation_EE[index*9+i];    \n+        }\n+\n+        double PosEE_index[3];\n+        for(int i = 0; i<3; i++)\n+        {\n+            PosEE_index[i] = position[index*3+i];\n+        }\n+        PosEE_index[2] = PosEE_index[2] - 0.01;\n+\n+        double RotGoalT_x_RotEE[9];\n+        double RotGap[3];\n+\n+\n+        // double RotGoalT_x_PosEE[3];\n+        // double RotGoalT_x_PosGoal[3];\n+        double PosGap[3];\n+        double PosGap_2 = 0.0;\n+\n+        matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n+        rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+\n+        double cost1 = 0.0;\n+        double cost2 = 0.0;\n+        double cost1_2 = 0.0;        \n+        double cost2_2 = 0.0;\n+        double cost3 = 0.0;\n+        // double cost2 = 0.0;\n+\n+        for(int i = 0;i<3; i++)\n+        {\n+            PosGap[i] = abs(PosEE_index[i]-g[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n+            // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+\n+            PosGap_2 += abs(PosGap[i]);\n+\n+            // if(PosGap[i] > 1)\n+            // {\n+            //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n+            // }\n+            // else\n+            // {\n+            //     cost2_2 = cost2_2 + PosGap[i];\n+            // }\n+            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+        }\n+\n+        if(PosGap_2 > gap_limit )\n+        {\n+            cost3 = weight1 * 3.14 * 3 * 2;\n+            weight1 =  0.0;            \n+        }\n+        // else\n+        // {\n+        //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n+\n+        // if(cost1_2 > 1)\n+        // {\n+        //     cost1_2 = pow2_cuda(cost1_2);\n+        // }\n+        // cost1 = cost1_2 + cost2_2;\n+        // if(cost1 > 2.0)\n+        // {\n+        //     f[index] = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+        // else if(cost1 <= 2.0 && cost1 > 1.0)\n+        // {\n+        //     f[index] = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+        // else\n+        // {\n+        //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+\n+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        if(cost2_2 >  position_sec1[0])\n+        {\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        {\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        else\n+        {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            // cost2 = (1-_manipulability[index]);\n+        }\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        if(sqrt(_manipulability[index])<= 0.1)\n+        {\n+            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        }\n+        // f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost3;\n+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+\n+        // if(now_gap[0] > 1.0)\n+        // {\n+        //     if(index2 < _time_window-5)\n+        //     {\n+        //         f[index] = 0.0;\n+        //     }\n+        // }\n+        // else\n+        // {\n+        //     if(index2 >= _time_window-5)\n+        //     {\n+        //         f[index] = 0.0;\n+        //     }\n+        // }\n+    }    \n+    __syncthreads();\n+}\n+\n+__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n+{\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index3 = index % (_time_window*_JDOF);\n+    int joint_num = index3 / _time_window;\n+    // curandState localState = state[index%_time_window];\n+    curandState state;\n+    \n+    // 현재 스레드의 인덱스로 상태 정보 초기화\n+    curand_init(0, index, 0, &state);\n+    // double rand_val;\n+\n+    // rand_val = curand_normal(&localState) * 1.0 + _A[joint_num];\n+    // _matrix_for_cuda[index] = rand_val;\n+    if (index % _time_window == 0)\n+    {\n+        // if(index == 0)\n+        // {\n+        //     _matrix_for_cuda[index] = 0.0;\n+        // }\n+        // else\n+        // {\n+            // _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            }            \n+        // }\n+        if(abs_cuda1(_matrix_for_cuda[index])>100)\n+        {\n+            _matrix_for_cuda[index] = 0.0;   \n+        }\n+    }\n+    // printf(\"generate_random2 OK \\n\");\n+    __syncthreads();\n+}\n+\n+__global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n+{\n+    // printf(\"GetBodyRotationMatrix OK \\n\");\n+    double Roll = xyzrpy_goal[3];\n+    double Pitch = xyzrpy_goal[4];\n+    double Yaw = xyzrpy_goal[5];\n+\n+    double R_yaw[9];\n+    R_yaw[0] = cos(Yaw);\n+    R_yaw[1] = -sin(Yaw);\n+    R_yaw[2] = 0.0;\n+    R_yaw[3] = sin(Yaw);\n+    R_yaw[4] = cos(Yaw);\n+    R_yaw[5] = 0.0;\n+    R_yaw[6] = 0.0;\n+    R_yaw[7] = 0.0;\n+    R_yaw[8] = 1.0;\n+\n+    double R_pitch[9];\n+    R_pitch[0] = cos(Pitch);\n+    R_pitch[1] = 0.0;\n+    R_pitch[2] = sin(Pitch);\n+    R_pitch[3] = 0.0;\n+    R_pitch[4] = 1.0;\n+    R_pitch[5] = 0.0;\n+    R_pitch[6] = -sin(Pitch);\n+    R_pitch[7] = 0.0;\n+    R_pitch[8] = cos(Pitch);\n+\n+    double R_roll[9];\n+    R_roll[0] = 1.0;\n+    R_roll[1] = 0.0;\n+    R_roll[2] = 0.0;\n+    R_roll[3] = 0.0;\n+    R_roll[4] = cos(Roll);\n+    R_roll[5] = -sin(Roll);\n+    R_roll[6] = 0.0;\n+    R_roll[7] = sin(Roll);\n+    R_roll[8] = cos(Roll);\n+    \n+    double tmp_mat3x3[9];\n+    matrixMultiply_3x3(R_yaw, R_pitch, tmp_mat3x3);\n+    matrixMultiply_3x3(tmp_mat3x3, R_roll, RGyro);\n+}\n+\n+__global__ void prev_computeForwardKinematics(double* FK_a, double* FK_d, double* FK_alpha, double* prev_q, double* position_EE, double* orientation_EE) \n+{\n+    double transformationMatrix[16];\n+    double transformationMatrix2[16];\n+    double tempMatrix[16];\n+    double tempMatrix2[16];\n+    \n+    computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], prev_q[0], transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], prev_q[1], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], prev_q[2], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], prev_q[3], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], prev_q[4], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], prev_q[5], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], prev_q[6], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n+    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n+    // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n+    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n+    position_EE[0] = transformationMatrix[3];\n+    position_EE[1] = transformationMatrix[7];\n+    position_EE[2] = transformationMatrix[11];\n+    //rpy\n+    double tempVec[3];\n+    rpy_from_transformationmatrix(transformationMatrix, tempVec);\n+    orientation_EE[0] = tempVec[0];\n+    orientation_EE[1] = tempVec[1];\n+    orientation_EE[2] = tempVec[2];\n+    // printf(\"prev_computeForwardKinematics OK \\n\");\n+}\n+\n+__global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n+{\n+    // printf(\"computeForwardKinematics OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index3 = index % (_time_window*7);\n+    // int joint_num = index3 / _time_window;\n+    // 각 변환 행렬 계산\n+\n+    if(index < _sampling_num)\n+    {\n+        for(int i = 0; i<_time_window; i++)\n+        {\n+            double transformationMatrix[16];\n+            double transformationMatrix2[16];\n+\n+            double tempMatrix[16];\n+            double tempMatrix2[16];\n+            double man_6x6[36];\n+\n+            double p0[3];\n+            double p1[3];\n+            double p2[3];\n+            double p3[3];\n+            double p4[3];\n+            double p5[3];\n+            double p6[3];\n+\n+            double z0[3];\n+            double z1[3];\n+            double z2[3];\n+            double z3[3];\n+            double z4[3];\n+            double z5[3];\n+            double z6[3];\n+\n+            double t0[3];\n+            double t1[3];\n+            double t2[3];\n+            double t3[3];\n+            double t4[3];\n+            double t5[3];\n+\n+            p0[0] = 0.0;\n+            p0[1] = 0.0;\n+            p0[2] = FK_d[0];\n+\n+            z0[0] = 0.0;\n+            z0[1] = 0.0;\n+            z0[2] = 1.0;      \n+            \n+            computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], jointAngles[index*_time_window*_JDOF+i], transformationMatrix);\n+\n+            computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], jointAngles[index*_time_window*_JDOF+_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p1[0] = transformationMatrix2[3];\n+            p1[1] = transformationMatrix2[7];\n+            p1[2] = transformationMatrix2[11];\n+            z1[0] = transformationMatrix2[2];\n+            z1[1] = transformationMatrix2[6];\n+            z1[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], jointAngles[index*_time_window*_JDOF+2*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p2[0] = transformationMatrix[3];\n+            p2[1] = transformationMatrix[7];\n+            p2[2] = transformationMatrix[11];\n+            z2[0] = transformationMatrix[2];\n+            z2[1] = transformationMatrix[6];\n+            z2[2] = transformationMatrix[10];\n+\n+            computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], jointAngles[index*_time_window*_JDOF+3*_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p3[0] = transformationMatrix2[3];\n+            p3[1] = transformationMatrix2[7];\n+            p3[2] = transformationMatrix2[11];\n+            z3[0] = transformationMatrix2[2];\n+            z3[1] = transformationMatrix2[6];\n+            z3[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], jointAngles[index*_time_window*_JDOF+4*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p4[0] = transformationMatrix[3];\n+            p4[1] = transformationMatrix[7];\n+            p4[2] = transformationMatrix[11];\n+            z4[0] = transformationMatrix[2];\n+            z4[1] = transformationMatrix[6];\n+            z4[2] = transformationMatrix[10];\n+\n+            computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], jointAngles[index*_time_window*_JDOF+5*_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p5[0] = transformationMatrix2[3];\n+            p5[1] = transformationMatrix2[7];\n+            p5[2] = transformationMatrix2[11];\n+            z5[0] = transformationMatrix2[2];\n+            z5[1] = transformationMatrix2[6];\n+            z5[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], jointAngles[index*_time_window*_JDOF+6*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p6[0] = transformationMatrix[3];\n+            p6[1] = transformationMatrix[7];\n+            p6[2] = transformationMatrix[11];\n+            z6[0] = transformationMatrix[2];\n+            z6[1] = transformationMatrix[6];\n+            z6[2] = transformationMatrix[10];\n+\n+            t0[0] =  p6[0]-p0[0];\n+            t0[1] =  p6[1]-p0[1];\n+            t0[2] =  p6[2]-p0[2];\n+\n+            t1[0] =  p6[0]-p1[0];\n+            t1[1] =  p6[1]-p1[1];\n+            t1[2] =  p6[2]-p1[2];\n+\n+            t2[0] =  p6[0]-p2[0];\n+            t2[1] =  p6[1]-p2[1];\n+            t2[2] =  p6[2]-p2[2];\n+\n+            t3[0] =  p6[0]-p3[0];\n+            t3[1] =  p6[1]-p3[1];\n+            t3[2] =  p6[2]-p3[2];\n+\n+            t4[0] =  p6[0]-p4[0];\n+            t4[1] =  p6[1]-p4[1];\n+            t4[2] =  p6[2]-p4[2];\n+\n+            t5[0] =  p6[0]-p5[0];\n+            t5[1] =  p6[1]-p5[1];\n+            t5[2] =  p6[2]-p5[2];            \n+\n+            jacobian_matrix[index*_time_window*42+i*42+0] = z0[1]*t0[2]-z0[2]*t0[1];\n+            jacobian_matrix[index*_time_window*42+i*42+7] = z0[2]*t0[0]-z0[0]*t0[2];\n+            jacobian_matrix[index*_time_window*42+i*42+14] = z0[0]*t0[1]-z0[1]*t0[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+1] = z1[1]*t1[2]-z1[2]*t1[1];\n+            jacobian_matrix[index*_time_window*42+i*42+8] = z1[2]*t1[0]-z1[0]*t1[2];\n+            jacobian_matrix[index*_time_window*42+i*42+15] = z1[0]*t1[1]-z1[1]*t1[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+2] = z2[1]*t2[2]-z2[2]*t2[1];\n+            jacobian_matrix[index*_time_window*42+i*42+9] = z2[2]*t2[0]-z2[0]*t2[2];\n+            jacobian_matrix[index*_time_window*42+i*42+16] = z2[0]*t2[1]-z2[1]*t2[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+3] = z3[1]*t3[2]-z3[2]*t3[1];\n+            jacobian_matrix[index*_time_window*42+i*42+10] = z3[2]*t3[0]-z3[0]*t3[2];\n+            jacobian_matrix[index*_time_window*42+i*42+17] = z3[0]*t3[1]-z3[1]*t3[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+4] = z4[1]*t4[2]-z4[2]*t4[1];\n+            jacobian_matrix[index*_time_window*42+i*42+11] = z4[2]*t4[0]-z4[0]*t4[2];\n+            jacobian_matrix[index*_time_window*42+i*42+18] = z4[0]*t4[1]-z4[1]*t4[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+5] = z5[1]*t5[2]-z5[2]*t5[1];\n+            jacobian_matrix[index*_time_window*42+i*42+12] = z5[2]*t5[0]-z5[0]*t5[2];\n+            jacobian_matrix[index*_time_window*42+i*42+19] = z5[0]*t5[1]-z5[1]*t5[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+6] = 0.0;\n+            jacobian_matrix[index*_time_window*42+i*42+13] = 0.0;\n+            jacobian_matrix[index*_time_window*42+i*42+20] = 0.0;\n+\n+            jacobian_matrix[index*_time_window*42+i*42+21] = z0[0];\n+            jacobian_matrix[index*_time_window*42+i*42+28] = z0[1];\n+            jacobian_matrix[index*_time_window*42+i*42+35] = z0[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+22] = z1[0];\n+            jacobian_matrix[index*_time_window*42+i*42+29] = z1[1];\n+            jacobian_matrix[index*_time_window*42+i*42+36] = z1[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+23] = z2[0];\n+            jacobian_matrix[index*_time_window*42+i*42+30] = z2[1];\n+            jacobian_matrix[index*_time_window*42+i*42+37] = z2[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+24] = z3[0];\n+            jacobian_matrix[index*_time_window*42+i*42+31] = z3[1];\n+            jacobian_matrix[index*_time_window*42+i*42+38] = z3[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+25] = z4[0];\n+            jacobian_matrix[index*_time_window*42+i*42+32] = z4[1];\n+            jacobian_matrix[index*_time_window*42+i*42+39] = z4[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+26] = z5[0];\n+            jacobian_matrix[index*_time_window*42+i*42+33] = z5[1];\n+            jacobian_matrix[index*_time_window*42+i*42+40] = z5[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+27] = z6[0];\n+            jacobian_matrix[index*_time_window*42+i*42+34] = z6[1];\n+            jacobian_matrix[index*_time_window*42+i*42+41] = z6[2];\n+            \n+            for(int l = 0; l<6; l++)\n+            {\n+                for(int j = 0; j<6; j++)\n+                {\n+                    man_6x6[l*6+j] = 0.0;\n+                    for(int k = 0; k<7; k++)\n+                    {\n+                        man_6x6[l*6+j] = man_6x6[l*6+j] + (jacobian_matrix[index*_time_window*42+i*42+l*7+k] * jacobian_matrix[index*_time_window*42+i*42+j*7+k]);\n+                    }                \n+                }\n+            }\n+            determinant_6x6(man_6x6,_manipulability[index*_time_window+i]);\n+            // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n+            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+\n+            // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n+            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9] = transformationMatrix[0];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+1] = transformationMatrix[1];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+2] = transformationMatrix[2];\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9+3] = transformationMatrix[4];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+4] = transformationMatrix[5];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+5] = transformationMatrix[6];\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9+6] = transformationMatrix[8];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+7] = transformationMatrix[9];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+8] = transformationMatrix[10];\n+\n+            position_EE[index*_time_window*3+i*3] = transformationMatrix[3];\n+            position_EE[index*_time_window*3+i*3+1] = transformationMatrix[7];\n+            position_EE[index*_time_window*3+i*3+2] = transformationMatrix[11];\n+\n+            //rpy\n+            double tempVec[3];\n+            rpy_from_transformationmatrix(transformationMatrix, tempVec);\n+            orientation_EE[index*_time_window*3+i*3] = tempVec[0];\n+            orientation_EE[index*_time_window*3+i*3+1] = tempVec[1];\n+            orientation_EE[index*_time_window*3+i*3+2] = tempVec[2];\n+            \n+            if(i == 0)\n+            {\n+                velocity_EE[index*_time_window*3+i*3] = (transformationMatrix[3] - prev_x[0]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - prev_x[1]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - prev_x[2]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3] = (tempVec[0] - prev_r[0]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - prev_r[1]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - prev_r[2]) / _dt_cuda;\n+            }\n+            else\n+            {\n+                velocity_EE[index*_time_window*3+i*3+0] = (transformationMatrix[3] - position_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - position_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - position_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+0] = (tempVec[0] - orientation_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - orientation_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - orientation_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n+            }            \n+        }    \n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n+{\n+    // printf(\"forwardPropagation OK \\n\");\n+    int tid = threadIdx.x + blockIdx.x * blockDim.x;\n+    \n+    double hidden0[_nodes_cuda];\n+    double hidden1[_nodes_cuda];\n+    \n+    if (tid < _sampling_num) {\n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            hidden0[j] = 0.0;\n+        }\n+    \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            hidden1[j] = 0.0;\n+        }\n+        \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            for (int i = 0; i < _JDOF; i++) {\n+                hidden0[j] += inputs[tid * _JDOF + i] * weights0[i * _nodes_cuda + j];\n+            }\n+            \n+            hidden0[j] += weights1[j];\n+            \n+            if (hidden0[j] <= 0) {\n+                hidden0[j] = 0.0;\n+            }\n+        }\n+        \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            for (int i = 0; i < _nodes_cuda; i++) {\n+                hidden1[j] += hidden0[i] * weights2[i * _nodes_cuda + j];\n+            }\n+            \n+            hidden1[j] += weights3[j];\n+            \n+            if (hidden1[j] <= 0) {\n+                hidden1[j] = 0.0;\n+            }\n+        }\n+    \n+        double output1 = 0.0;\n+    \n+        for (int i = 0; i < _nodes_cuda; i++) {\n+            output1 += hidden1[i] * weights4[i];\n+        }\n+    \n+        output1 += weights5[0];\n+        output1 = sigmoid(output1);\n+    \n+        outputs[tid] = output1;\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n+{\n+    // printf(\"calculate_inputs OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+\n+    if (index < _JDOF * _sampling_num)\n+    {\n+        inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n+\n+        if (inputs[index] > 1)\n+        {\n+            inputs[index] = 1;\n+        }\n+        else if (inputs[index] < -1)\n+        {\n+            inputs[index] = -1;\n+        }\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n+{\n+    // printf(\"if_find_solution OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    if(index < _sampling_num)\n+    {\n+        for(int i = 0; i<_time_window; i++)\n+        {\n+            double tmp_p = 0.0;\n+            tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n+            tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n+            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n+\n+            double rotation_EE_index[9];\n+            for(int j = 0; j<9; j++)\n+            {\n+                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+            }\n+\n+            double RotGoalT_x_RotEE[9];\n+            double RotGap[3];\n+\n+            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n+            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+\n+            double tmp_p2 = 0.0;\n+            tmp_p2 = abs_cuda1(RotGap[0]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n+\n+            find_sol[index] = 0;\n+            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n+            {\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n+                    {\n+                        break;\n+                    }\n+                    else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        find_sol[index] = 1;\n+                        // break;\n+                    }\n+                }\n+                if(find_sol[index] == 1)\n+                {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n+{ \n+    // cout<<\"cuda code start\"<<endl;\n+    // _dt_cuda2[0] = 0.5;\n+    // for(int i = 0; i<6; i++)\n+    // {\n+    //     cout<<_goal_pos_cuda[i]<<endl;    \n+    // }\n+    \n+    prev_x_cost = 0.0;\n+    now_pos_gap[0] = 0.0;\n+    now_pos_gap_all[0] = 0.0;\n+    for(int i = 0; i<3; i++)\n+    {\n+        now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n+        now_pos_gap_all[0] = now_pos_gap_all[0] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+    }\n+    // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n+    // {\n+    //     _dt_cuda2[0] = now_pos_gap[0];\n+    // }\n+    ////////////////////////////////////////////////////////////////\n+    // if(found_goal == 1)\n+    // {\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.7;\n+    //     }\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = 0.7;\n+    // }\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.7)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n+    //////////////////////////////////////////////////////////////\n+    _sol_cost = _sol_cost / 5000;\n+    // 200/\n+\n+    if(_sol_cost > 700)\n+    {\n+        _dt_cuda2[0] = 0.5;\n+    }\n+    else if(_sol_cost <= 700 && _sol_cost > 1)\n+    {\n+        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n+            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        // _dt_cuda2[0] = 0.003;\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = _dt_cuda;\n+    }\n+    // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n+    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+\n+    reset_check = 0;\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n+        {            \n+            reset_check = 1;\n+            break;\n+        }\n+    }\n+    if(reset_check == 1)\n+    {\n+        for(int i = 0; i<_JDOF; i++)\n+        {        \n+            _q_des[i] = _init_pos[i];\n+            _qdot_des[i] = _init_vel[i];\n+            _A[i] = 0.0;\n+        }\n+    }\n+    // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n+    \n+    dim3 blockDim(N/_time_window, 1, 1);\n+    dim3 gridDim(_time_window, 1, 1);\n+    dim3 gridDim2(_sampling_num, 1);\n+    dim3 blockDim2(1, 1);\n+    dim3 blockSize(1, 1);\n+    dim3 gridSize(1, 1);\n+    dim3 blockSize2(1, 1);\n+    dim3 gridSize2(_sampling_num * _time_window, 1);\n+\n+    if(control_mode == 0)\n+    {\n+        cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n+        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        for(int i = 0; i<N; i++)\n+        {\n+            int index222 = i / _time_window;\n+            if((i%_time_window) != 0)\n+            {\n+                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n+            }\n+        }\n+\n+        // _dt_cuda2\n+        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n+        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n+        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        \n+        for(int i = 0; i<N; i++)\n+        {\n+            if((i%_time_window) != 0)\n+            {\n+                d[i] = d[i-1] + d[i];\n+                e[i] = e[i-1] + d[i] * _dt_cuda;\n+            }\n+        }\n+\n+        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_q_goal, _goal_pos_cuda, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cost_function_joint_control <<< gridDim, blockDim>>> (dev_d, dev_e, dev_cost, dev_q_goal, dev_position_sec1, dev_position_sec2, dev_velocity_lim, dev__matrix_for_cuda, dev__prev_matrix_for_cuda, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost);\n+        \n+        cudaMemcpy(f, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n+        // cudaDeviceSynchronize();\n+\n+        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        \n+        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();    \n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _return_cost[i] = 0.0;\n+            for(int j = 0; j<_JDOF; j++)\n+            {\n+                for(int k = 0; k<_time_window; k++)\n+                {\n+                    _return_cost[i] = _return_cost[i] + f[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                }\n+            }\n+            if(outputs[i] > 0.5)\n+            {\n+                _return_cost[i] = _return_cost[i] + outputs[i] * pow(10,6);\n+            }\n+            _return_cost[i] = _return_cost[i] / _JDOF;\n+        }\n+\n+        _min_cost = 1000000000000000.0;\n+        weight_sum = 0.0;\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _return_cost[i];\n+            if(_min_cost > _cost[i])\n+            {\n+                _min_cost = _cost[i];\n+            }\n+        }\n+        memset(_weighted_A, 0, _JDOF * sizeof(double));\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _cost[i] - _min_cost;\n+            if(_cost[i]<100)\n+            {\n+                _cost[i] = exp(-_cost[i]);\t\t\n+                weight_sum = weight_sum + _cost[i];\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n+                }\n+            }\n+        }\n+        for(int j = 0; j<_JDOF; j++)\n+        {\n+            _weighted_A[j] /=  weight_sum;\n+            _A[j] = _weighted_A[j];\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n+        }\n+        \n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i];\n+            returnArray[_JDOF+i] = _qdot_des[i] + (_weighted_A[i] * _dt_cuda);\n+            returnArray[i] = _q_des[i] + (_qdot_des[i] * _dt_cuda);\n+\n+            _q_des[i] = returnArray[i];\n+            _qdot_des[i] = returnArray[_JDOF+i];\n+        }\n+    }\n+\n+    else if(control_mode == 1)\n+    {\n+        // for(int i= 0; i<7; i++)\n+        // {\n+        //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n+        // }\n+        \n+        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        for(int i = 0; i<N; i++)\n+        {\n+            int index222 = i / _time_window;\n+            if((i%_time_window) != 0)\n+            {   \n+                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n+                if((i%_time_window) >= _time_window-_dt2_window)\n+                {\n+                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n+                }                \n+            }\n+            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+        }\n+\n+        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev__matrix_for_cuda, _matrix_for_cuda, N*sizeof(double), cudaMemcpyHostToDevice);\n+        \n+        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n+        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n+        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n+\n+        cudaDeviceSynchronize();\n+        for(int i = 0; i<N; i++)\n+        {\n+            if((i%_time_window) != 0)\n+            {\n+                if((i%_time_window) >= _time_window-_dt2_window)\n+                {\n+                    d[i] = d[i-1] + d[i];\n+                    e[i] = e[i-1] + d[i] * _dt_cuda2[0];\n+                }\n+                else\n+                {\n+                    d[i] = d[i-1] + d[i];\n+                    e[i] = e[i-1] + d[i] * _dt_cuda;\n+                }\n+            }\n+        }\n+\n+        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaDeviceSynchronize();\n+\n+        // cout<<\"222222222222222222222222\"<<endl;\n+        // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaDeviceSynchronize();\n+        // for(int k = 0 ;k <_sampling_num; k++)\n+        // {\n+        //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n+        //     for(int i = 0; i<42; i++)\n+        //     {\n+        //         if(i%7 == 6)\n+        //         {\n+        //             cout<<jacobian[i+42*k]<<endl;    \n+        //         }\n+        //         else\n+        //         {\n+        //             cout<<jacobian[i+42*k]<<\" \";\n+        //         }            \n+        //     }\n+        // }        \n+        \n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n+        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+\n+\n+        // cout<<\"CUDA manipulability\"<<endl;\n+        // for(int i = 0; i<N/_JDOF; i++)\n+        // {\n+        //     cout<<\"manipulability ith : \"<<i<<manipulability[i]<<endl;\n+        // }\n+        cudaMemcpy(dev_FK_a, FK_a, 9*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n+        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n+\n+        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaDeviceSynchronize();\n+        \n+        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n+        // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n+        Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n+\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(dev_now_pos_gap_all, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap_all);\n+        cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        \n+\n+        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n+        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        // for(int i = 0; i<_sampling_num * _time_window; i++)\n+        // {\n+        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n+        // }\n+\n+        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n+        // {\n+        //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n+        // }\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n+        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        // for(int i = 0; i<_sampling_num; i++)\n+        // {\n+        //     if(outputs[i]>0.5)\n+        //     {\n+        //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n+        //     }\n+        // }\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _return_cost[i] = 0.0;\n+            for(int j = 0; j<_JDOF; j++)\n+            {\n+                for(int k = 0; k<_time_window; k++)\n+                {\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                }\n+                // if(j == _JDOF-1)\n+                // {\n+                //     _return_cost[i] = _return_cost[i] / _JDOF;\n+                // }\n+            }\n+            // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n+\n+            for(int j = 0 ; j<_time_window; j++)\n+            {\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+            }\n+            if(found_goal_list[i] == 1)\n+            {\n+                if(outputs[i] >= 0.5)\n+                {\n+                    found_goal_list[i] = 0;\n+                }\n+            }\n+            if(outputs[i] > 0.5)\n+            {\n+                _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n+            }\n+            _return_cost[i] = _return_cost[i] / _JDOF;\n+            // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n+            if(found_goal_list[i] == 1)\n+            {\n+                found_goal = 1;\n+                // cout<<\"??\"<<endl;\n+                // _return_cost[i] = _return_cost[i];\n+            }\n+            // else\n+            // {\n+            //     _return_cost[i] = _return_cost[i] + 100.0;\n+            // }\n+        }\n+\n+        _min_cost = 1000000000000000.0;\n+        weight_sum = 0.0;\n+        // _sol_cost = 0.0;\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _return_cost[i];\n+            if(_min_cost > _cost[i])\n+            {\n+                _min_cost = _cost[i];\n+            }\n+        }\n+        _sol_cost = _min_cost;\n+        memset(_weighted_A, 0, _JDOF * sizeof(double));\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _cost[i] - _min_cost;\n+            if(_cost[i]<100)\n+            {\n+                _cost[i] = exp(-_cost[i]);\t\t\n+                weight_sum = weight_sum + _cost[i];\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n+                }\n+            }\n+        }\n+        for(int j = 0; j<_JDOF; j++)\n+        {\n+            _weighted_A[j] /=  weight_sum;\n+            _A[j] = _weighted_A[j];\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n+        }\n+\n+        // for(int i = 0; i<_JDOF; i++)\n+        // {\n+        //     cout<<_weighted_A[i]<<endl;    \n+        // }\n+        \n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i] ;//* (1+_dt_cuda2[0]-_dt_cuda);\n+            returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n+            returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n+\n+            _q_des[i] = returnArray[i];\n+            _qdot_des[i] = returnArray[_JDOF+i];\n+        }\n+    }\n+}\n+\n+void CudaTest::load_weight()\n+{\n+    ostringstream filename_NN[6];\n+    ifstream weight0;\n+    #if _nodes_cuda == 32\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+        }\n+    }\n+    #elif _nodes_cuda == 64\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+        } \n+    }\n+    #elif _nodes_cuda == 100\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+        } \n+    }\n+    #else\n+    #endif\n+    \n+    weight0.open(filename_NN[0].str());\n+    for(int i = 0; i<_JDOF ; i++)\n+    {\n+        for(int j = 0; j<_nodes_cuda ; j++)\n+        {\n+            weight0 >> weights0[i*_nodes_cuda + j];\n+        }\n+    }\n+    weight0.close();\n+    \n+    weight0.open(filename_NN[1].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights1[i];\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[2].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        for(int j = 0; j<_nodes_cuda ; j++)\n+        {\n+            weight0 >> weights2[i*_nodes_cuda + j];\n+        }\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[3].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights3[i];\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[4].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights4[i];\n+    }\n+    weight0.close();\n+    weight0.open(filename_NN[5].str());\n+    weight0 >> weights5[0];\n+    weight0.close();\n+}\n+\n+void CudaTest::cpu_memory_save()\n+{\n+    // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    memset(cost_jointlimit, 0, N * sizeof(double));\n+    memset(_mean_matrix, 0, N * sizeof(double));\n+    memset(d, 0, N * sizeof(double));\n+    memset(e, 0, N * sizeof(double));\n+    memset(f, 0, N * sizeof(double));\n+    memset(_matrix_for_cuda, 0, N * sizeof(double));\n+\n+    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    memset(FK_d, 0, 9 * sizeof(double));\n+    memset(FK_a, 0, 9 * sizeof(double));\n+    memset(FK_alpha, 0, 9 * sizeof(double));\n+    \n+    memset(_return_cost, 0, _sampling_num * sizeof(double));\n+    memset(_cost, 0, _sampling_num * sizeof(double));\n+\n+    memset(_max_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_min_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_q_des, 0, _JDOF * sizeof(double));\n+    memset(_qdot_des, 0, _JDOF * sizeof(double));\n+    memset(_A, 0, _JDOF * sizeof(double));\n+    memset(_weighted_A, 0, _JDOF * sizeof(double));\n+    memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n+    \n+    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n+    memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n+    memset(weights1, 0, _nodes_cuda * sizeof(double));\n+    memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n+    memset(weights3, 0, _nodes_cuda * sizeof(double));\n+    memset(weights4, 0, _nodes_cuda * sizeof(double));\n+    // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n+    memset(outputs, 0, _sampling_num * sizeof(double));\n+    memset(returnArray, 0, _JDOF*3 * sizeof(double));\n+\n+    memset(_prev_x, 0, 3 * sizeof(double));\n+    memset(_prev_r, 0, 3 * sizeof(double));\n+\n+    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n+\n+    \n+    weights5[0] = 0.0;\n+    position_sec1[0] = 0.0;\n+    position_sec2[0] = 0.0;\n+    velocity_lim[0] = 0.0;\n+}\n+\n+void CudaTest::cuda_memory_save()\n+{\n+    // cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n+    cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n+    // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n+    cudaMalloc((void**)&dev_states, N*sizeof(double));\n+\n+    // cudaMalloc((void**)&dev_a, N * sizeof(double));\n+    cudaMalloc((void**)&dev_b, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_c, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_d, N * sizeof(double));\n+    cudaMalloc((void**)&dev_e, N * sizeof(double));\n+    cudaMalloc((void**)&dev_cost, N * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n+    cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n+    cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n+\n+    cudaMalloc((void**)&d_weights0, _JDOF * _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights1, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n+\n+    cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n+    cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n+    cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n+\n+    // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n+    cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n+    cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double));\n+    cudaMalloc((void**)&dev_now_pos_gap_all, sizeof(double));\n+    cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    cudaMalloc((void**)&dev_beta, sizeof(double));   \n+}\n+\n+void CudaTest::cuda_memory_free()\n+{    \n+    // cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n+    cudaFree(dev__A);\n+    cudaFree(dev__mean_matrix);\n+    cudaFree(dev__matrix_for_cuda);\n+    // cudaFree(dev__prev_matrix_for_cuda);\n+    cudaFree(dev_states);\n+\n+    cudaFree(dev_b);\n+    cudaFree(dev_c);\n+    cudaFree(dev_d);\n+    cudaFree(dev_e);\n+    cudaFree(dev_cost);\n+    cudaFree(dev_cost_x);\n+    \n+    cudaFree(dev_q_goal);\n+    cudaFree(dev_x_goal);\n+    cudaFree(dev_rot_goal);\n+    cudaFree(dev_rot_goal_T);\n+\n+    cudaFree(d_weights0);\n+    cudaFree(d_weights1);\n+    cudaFree(d_weights2);\n+    cudaFree(d_weights3);\n+    cudaFree(d_weights4);\n+    cudaFree(d_weights5);\n+    cudaFree(d_outputs);\n+\n+    cudaFree(hidden0);\n+    cudaFree(hidden1);\n+\n+    cudaFree(dev_inputs);\n+    cudaFree(dev_min_joint_position_for_NN);\n+    cudaFree(dev_max_joint_position_for_NN);\n+\n+    cudaFree(dev_joint_min_limit_for_cost);\n+    cudaFree(dev_joint_max_limit_for_cost);\n+    cudaFree(dev_cen_joint_position);\n+\n+    cudaFree(dev_position_sec1);\n+    cudaFree(dev_position_sec2);\n+    cudaFree(dev_velocity_lim);\n+\n+    // cudaFree(_dev_jacobian);\n+    cudaFree(dev_position_EE);\n+    cudaFree(dev_orientation_EE);\n+\n+    cudaFree(dev_FK_a);\n+    cudaFree(dev_FK_d);\n+    cudaFree(dev_FK_alpha);\n+\n+    cudaFree(dev_jacobian);\n+    cudaFree(dev_jacobian_transpose);\n+\n+    cudaFree(dev_alpha);\n+    cudaFree(dev_beta);\n+\n+    cudaError_t error = cudaGetLastError();\n+    if (error != cudaSuccess) {\n+        printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n+        // 에러 처리 로직을 추가해야 합니다.\n+    }\n+}\n+\n+void CudaTest::initialize()\n+{\n+    // cout<<endl;\n+    // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n+    // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n+    // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n+    // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n+\n+    // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n+    _sol_cost = 0.0;\n+\n+    position_sec1[0] = 0.03125;\n+    position_sec2[0] = 0.005;\n+    velocity_lim[0] = 0.8;\n+\n+    // position_sec1[0] = 0.03125;\n+    // position_sec2[0] = 0.00625;\n+    // velocity_lim[0] = 1.0;\n+\t\n+    // numBlocks = N / THREADS_PER_BLOCK;\n+    // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n+\n+\n+    // panda_arm_hand.urdf // panda_arm_hand.xml model\n+\t// _min_joint_position[0] = -2.9671;\n+\t// _min_joint_position[1] = -1.8326;\n+\t// _min_joint_position[2] = -2.9671;\n+\t// _min_joint_position[3] = -3.1416;\n+\t// _min_joint_position[4] = -2.9671;\n+\t// _min_joint_position[5] = -0.0873;\n+\t// _min_joint_position[6] = -2.9671;\n+\n+\t// _max_joint_position[0] = 2.9671;\n+\t// _max_joint_position[1] = 1.8326;\n+\t// _max_joint_position[2] = 2.9671;\n+\t// _max_joint_position[3] = 0.0;\n+\t// _max_joint_position[4] = 2.9671;\n+\t// _max_joint_position[5] = 3.8223;\n+\t// _max_joint_position[6] = 2.9671;\n+\n+\n+\n+    // fr3.urdf // fr3.xml model\n+    _min_joint_position[0] = -2.8973;\n+\t_min_joint_position[1] = -1.7628;\n+\t_min_joint_position[2] = -2.8973;\n+\t_min_joint_position[3] = -3.0718;\n+\t_min_joint_position[4] = -2.8973;\n+\t_min_joint_position[5] = -0.0175;\n+\t_min_joint_position[6] = -2.8973;\n+\n+\t_max_joint_position[0] = 2.8973;\n+\t_max_joint_position[1] = 1.7628;\n+\t_max_joint_position[2] = 2.8973;\n+\t_max_joint_position[3] = -0.0698;\n+\t_max_joint_position[4] = 2.8973;\n+\t_max_joint_position[5] = 3.7525;\n+\t_max_joint_position[6] = 2.8973;\n+\n+\n+\n+    //k = 0.1\n+    // _hat_min_joint_position[0] = -2.37368;\n+    // _hat_max_joint_position[0] = 2.37368;\n+\n+    // _hat_min_joint_position[1] = -1.46608;\n+    // _hat_max_joint_position[1] = 1.46608;\n+\n+    // _hat_min_joint_position[2] = -2.37368;\n+    // _hat_max_joint_position[2] = 2.37368;\n+\n+    // _hat_min_joint_position[3] = −2.82744;\n+    // _hat_max_joint_position[3] = -0.31416;\n+\n+    // _hat_min_joint_position[4] = -2.37368;\n+    // _hat_max_joint_position[4] = 2.37368;\n+\n+    // _hat_min_joint_position[5] = 0.30366;\n+    // _hat_max_joint_position[5] = 3.43134;\n+\n+    // _hat_min_joint_position[6] = -2.37368;\n+    // _hat_max_joint_position[6] = 2.37368;\n+\n+\n+\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n+    }\n+\n+    FK_a[0] = 0.0;\n+    FK_d[0] = 0.343;\n+    FK_alpha[0] = 0.0;\n+\n+    FK_a[1] = 0.0;\n+    FK_d[1] = 0.0;\n+    FK_alpha[1] = -PI_CUDA/2.0;\n+\n+    FK_a[2] = 0.0;\n+    FK_d[2] = 0.316;\n+    FK_alpha[2] = PI_CUDA/2.0;\n+\n+    FK_a[3] = 0.0825;\n+    FK_d[3] = 0.0;\n+    FK_alpha[3] = PI_CUDA/2.0;\n+\n+    FK_a[4] = -0.0825;\n+    FK_d[4] = 0.384;\n+    FK_alpha[4] = -PI_CUDA/2.0;\n+\n+    FK_a[5] = 0.0;\n+    FK_d[5] = 0.0;\n+    FK_alpha[5] = PI_CUDA/2.0;\n+\n+    FK_a[6] = 0.088;\n+    FK_d[6] = 0.0;\n+    FK_alpha[6] = PI_CUDA/2.0;\n+\n+    FK_a[7] = 0.0;\n+    FK_d[7] = 0.107;\n+    FK_alpha[7] = 0.0;\n+\n+    FK_a[8] = 0.0;\n+    FK_d[8] = 0.1034;\n+    FK_alpha[8] = 0.0;\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1692777238687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -365,9 +365,9 @@\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 500000.0;//pow(10,6)\n     double vel_gain = 300.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n+    if(now_gap[0] > 0.05 )\n     {\n         vel_gain =  0.0;\n     }\n     else\n@@ -2053,2062 +2053,5 @@\n \n     FK_a[8] = 0.0;\n     FK_d[8] = 0.1034;\n     FK_alpha[8] = 0.0;\n-}\n-#include <cuda_runtime.h>\n-#include <device_launch_parameters.h>\n-#include \"cuda.cuh\"\n-\n-#define THREADS_PER_BLOCK _sampling_num\n-#define THREADS_PER_BLOCK2 _sampling_num\n-\n-// device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n-\n-\n-CudaTest::CudaTest(void)\n-{   \n-}\n-\n-CudaTest::~CudaTest(void)\n-{    \n-    \n-}\n-\n-__device__ double sigmoid(double x) {\n-    return 1.0 / (1.0 + expf(-x));\n-}\n-\n-__device__ double abs_cuda1(double x) {\n-    if(x<0)\n-    {\n-        return -x;\n-    }\n-    else\n-    {\n-        return x;\n-    }\n-}\n-\n-__device__ double abs_cuda2(double x, double y) {\n-    if(x-y<0)\n-    {\n-        return -x+y;\n-    }\n-    else\n-    {\n-        return x-y;\n-    }\n-}\n-\n-__device__ double pow2_cuda(double x) {\n-    return x*x;\n-}\n-\n-\n-__device__ double norm2_vector3(double *x)\n-{\n-    double _norm2 = 0.0;\n-    for(int i = 0; i<3; i++)\n-    {\n-        _norm2 = _norm2 + (x[i] * x[i]);\n-    }\n-    _norm2 = sqrt(_norm2);\n-    return _norm2;\n-}\n-\n-__device__ double calculateSingularValue(double* matrix) \n-{\n-    int row = threadIdx.y;\n-    int col = threadIdx.x;\n-    \n-    // 3x3 행렬의 크기를 정의\n-    int matrixSize = 3;\n-    \n-    // 행렬의 요소를 읽음\n-    double element = matrix[row * matrixSize + col];\n-    double singularValue = 0.0;\n-    \n-    // 행렬의 특잇값은 고유값의 제곱근이므로 제곱을 계산\n-    element *= element;\n-    \n-    // 각 스레드마다 계산한 제곱된 특잇값을 공유 메모리에 저장\n-    __shared__ double sharedData[9];\n-    sharedData[row * matrixSize + col] = element;\n-    \n-    // 동기화\n-    __syncthreads();\n-    \n-    // 공유 메모리의 값을 최대값으로 업데이트\n-    if (threadIdx.x == 0 && threadIdx.y == 0) {\n-        double maxVal = 0.0;\n-        for (int i = 0; i < 9; i++) {\n-            if (sharedData[i] > maxVal) {\n-                maxVal = sharedData[i];\n-            }\n-        }\n-        singularValue = sqrt(maxVal);\n-    }\n-    return singularValue;\n-}\n-\n-__device__ void computeTransformationMatrix(double alpha, double a, double d, double theta, double* matrix) \n-{\n-    double cosTheta = cos(theta);\n-    double sinTheta = sin(theta);\n-    double cosAlpha = cos(alpha);\n-    double sinAlpha = sin(alpha);\n-\n-    matrix[0] = cosTheta;\n-    matrix[1] = -sinTheta;\n-    matrix[2] = 0;\n-    matrix[3] = a;\n-\n-    matrix[4] = sinTheta * cosAlpha;\n-    matrix[5] = cosTheta * cosAlpha;\n-    matrix[6] = -sinAlpha;\n-    matrix[7] = -d * sinAlpha;\n-\n-    matrix[8] = sinTheta * sinAlpha;\n-    matrix[9] = cosTheta * sinAlpha;\n-    matrix[10] = cosAlpha;\n-    matrix[11] = d * cosAlpha;\n-    \n-    matrix[12] = 0.0;\n-    matrix[13] = 0.0;\n-    matrix[14] = 0.0;\n-    matrix[15] = 1.0;\n-}\n-\n-__device__ void matrixMultiply_4x4(double *mat1, double *mat2, double *mat3)\n-{\n-    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[4] + mat1[2] * mat2[8] + mat1[3] * mat2[12];\n-    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[5] + mat1[2] * mat2[9] + mat1[3] * mat2[13];\n-    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[6] + mat1[2] * mat2[10] + mat1[3] * mat2[14];\n-    mat3[3] = mat1[0] * mat2[3] + mat1[1] * mat2[7] + mat1[2] * mat2[11] + mat1[3] * mat2[15];\n-\n-    mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[4] + mat1[6] * mat2[8] + mat1[7] * mat2[12];\n-    mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[5] + mat1[6] * mat2[9] + mat1[7] * mat2[13];\n-    mat3[6] = mat1[4] * mat2[2] + mat1[5] * mat2[6] + mat1[6] * mat2[10] + mat1[7] * mat2[14];\n-    mat3[7] = mat1[4] * mat2[3] + mat1[5] * mat2[7] + mat1[6] * mat2[11] + mat1[7] * mat2[15];\n-\n-    mat3[8] = mat1[8] * mat2[0] + mat1[9] * mat2[4] + mat1[10] * mat2[8] + mat1[11] * mat2[12];\n-    mat3[9] = mat1[8] * mat2[1] + mat1[9] * mat2[5] + mat1[10] * mat2[9] + mat1[11] * mat2[13];\n-    mat3[10] = mat1[8] * mat2[2] + mat1[9] * mat2[6] + mat1[10] * mat2[10] + mat1[11] * mat2[14];\n-    mat3[11] = mat1[8] * mat2[3] + mat1[9] * mat2[7] + mat1[10] * mat2[11] + mat1[11] * mat2[15];\n-\n-    mat3[12] = mat1[12] * mat2[0] + mat1[13] * mat2[4] + mat1[14] * mat2[8] + mat1[15] * mat2[12];\n-    mat3[13] = mat1[12] * mat2[1] + mat1[13] * mat2[5] + mat1[14] * mat2[9] + mat1[15] * mat2[13];\n-    mat3[14] = mat1[12] * mat2[2] + mat1[13] * mat2[6] + mat1[14] * mat2[10] + mat1[15] * mat2[14];\n-    mat3[15] = mat1[12] * mat2[3] + mat1[13] * mat2[7] + mat1[14] * mat2[11] + mat1[15] * mat2[15];\n-}\n-\n-__device__ void matrixMultiply_3x3(double *mat1, double *mat2, double *mat3)\n-{\n-    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[3] + mat1[2] * mat2[6];\n-    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[4] + mat1[2] * mat2[7];\n-    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[5] + mat1[2] * mat2[8];\n-\n-    mat3[3] = mat1[3] * mat2[0] + mat1[4] * mat2[3] + mat1[5] * mat2[6];\n-    mat3[4] = mat1[3] * mat2[1] + mat1[4] * mat2[4] + mat1[5] * mat2[7];\n-    mat3[5] = mat1[3] * mat2[2] + mat1[4] * mat2[5] + mat1[5] * mat2[8];\n-\n-    mat3[6] = mat1[6] * mat2[0] + mat1[7] * mat2[3] + mat1[8] * mat2[6];\n-    mat3[7] = mat1[6] * mat2[1] + mat1[7] * mat2[4] + mat1[8] * mat2[7];\n-    mat3[8] = mat1[6] * mat2[2] + mat1[7] * mat2[5] + mat1[8] * mat2[8];\n-}\n-\n-__device__ void rpy_from_transformationmatrix(double *RotMat, double *rpy)\n-{\n-    // rpy[1] = RotMat[8];\n-    rpy[1] = -asin(RotMat[8]);\n-    if(RotMat[8] > 1.0 - _threshold_cuda && RotMat[8] < 1.0 + _threshold_cuda)\n-    {\n-        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n-        rpy[2] = 0.0;\n-    }\n-    else if (RotMat[8] < -1.0 + _threshold_cuda && RotMat[8] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n-    {//Gimbal lock, pitch = 90deg\n-        rpy[0] = atan2(RotMat[1], RotMat[2]);\n-        rpy[2] = 0.0;\n-    }\n-    else //general solution\n-    {\n-        rpy[0] = atan2(RotMat[9], RotMat[10]);\n-        rpy[2] = atan2(RotMat[4], RotMat[0]);\n-    }\n-}\n-\n-__device__ void rpy_from_rotationmatrix(double *RotMat, double *rpy)\n-{\n-    // rpy[1] = RotMat[8];\n-    rpy[1] = -asin(RotMat[6]);\n-    if(RotMat[6] > 1.0 - _threshold_cuda && RotMat[6] < 1.0 + _threshold_cuda)\n-    {\n-        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n-        rpy[2] = 0.0;\n-    }\n-    else if (RotMat[6] < -1.0 + _threshold_cuda && RotMat[6] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n-    {//Gimbal lock, pitch = 90deg\n-        rpy[0] = atan2(RotMat[1], RotMat[2]);\n-        rpy[2] = 0.0;\n-    }\n-    else //general solution\n-    {\n-        rpy[0] = atan2(RotMat[7], RotMat[8]);\n-        rpy[2] = atan2(RotMat[3], RotMat[0]);\n-    }\n-}\n-\n-__device__ void determinant_6x6(double *matrix, double result)\n-{\n-    int tid = threadIdx.x;\n-    int stride = blockDim.x;\n-\n-    double temp[6][6];\n-    for (int i = 0; i < 6; i++) {\n-        for (int j = 0; j < 6; j++) {\n-            temp[i][j] = matrix[i * 6 + j];\n-        }\n-    }\n-\n-    for (int k = 0; k < 6 - 1; k++) {\n-        for (int i = k + 1 + tid; i < 6; i += stride) {\n-            double ratio = temp[i][k] / temp[k][k];\n-            for (int j = k; j < 6; j++) {\n-                temp[i][j] -= ratio * temp[k][j];\n-            }\n-        }\n-        __syncthreads();\n-    }\n-\n-    if (tid == 0) {\n-        result = 1.0;\n-        for (int i = 0; i < 6; i++) {\n-            result *= temp[i][i];\n-        }\n-    }\n-}\n-\n-__global__ void cal_jacobian(double *theta_table, double *_jacobian)\n-{\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    // int index2 = index/_time_window;\n-    int index3 = index*6*_JDOF;\n-    // double theta[7];\n-\n-    if(index<_sampling_num )\n-    {\n-        \n-        // for(int i = 0; i<_JDOF;)\n-        // {\n-        //     theta[i]= theta_table[(index*_JDOF*_time_window)+(_time_window*i)+(_time_window-1)];\n-        // }\n-\n-        double cash = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n-        double cash_1 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n-        double cash_2 = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n-        double cash_3 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        double cash0 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n-        double cash0_1 = (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n-        double cash1 = (sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n-        double cash2 = ((-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]));\n-        double cash2_2 = (cash2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n-        double cash3 = ((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + cash*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n-        double cash4 = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);    \n-\n-        _jacobian[index3 + 0] = ((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+(((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+((-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))-768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-632)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n-        _jacobian[index3 + 1] = (176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cash+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+632)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n-        _jacobian[index3 + 2] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n-        _jacobian[index3 + 3] = (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*cash;\n-        _jacobian[index3 + 4] = -cash0_1*cash1 + (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n-        _jacobian[index3 + 5] = -cash0_1*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n-        _jacobian[index3 + 6] = 0.0;\n-\n-        _jacobian[index3 + 7] = 11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400;\n-        _jacobian[index3 + 8] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 9] = -(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) + (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n-        _jacobian[index3 + 10] =  -(sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125)*cash;\n-        _jacobian[index3 + 11] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*cash1 - (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n-        _jacobian[index3 + 12] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) - (cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n-        _jacobian[index3 + 13] = 0.0;\n-\n-        _jacobian[index3 + 14] = 0.0;\n-        _jacobian[index3 + 15] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 16] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 17] = (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125);\n-        _jacobian[index3 + 18] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])) + cash0_1*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n-        _jacobian[index3 + 19] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + cash0_1*(cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n-        _jacobian[index3 + 20] = 0.0;\n-\n-        _jacobian[index3 + 21] = 0.0;\n-        _jacobian[index3 + 22] = -sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 23] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 24] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n-        _jacobian[index3 + 25] = -(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4;\n-        _jacobian[index3 + 26] = cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n-        _jacobian[index3 + 27] = cash2_2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n-\n-        _jacobian[index3 + 28] = 0.0;\n-        _jacobian[index3 + 29] = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n-        _jacobian[index3 + 30] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n-        _jacobian[index3 + 31] = cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n-        _jacobian[index3 + 32] = -(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n-        _jacobian[index3 + 33] = ((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n-        _jacobian[index3 + 34] = (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n-\n-        _jacobian[index3 + 35] = 1.0;\n-        _jacobian[index3 + 36] = 0.0;\n-        _jacobian[index3 + 37] = cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n-        _jacobian[index3 + 38] = -cash;\n-        _jacobian[index3 + 39] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n-        _jacobian[index3 + 40] = (-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n-        _jacobian[index3 + 41] = cash3*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - cash1*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n-    }\n-    //  __syncthreads();\n-}\n-\n-__global__ void Transpose_Matrix_3x3(double *input, double *output)\n-{\n-    // printf(\"Transpose_Matrix_3x3 OK \\n\");\n-    output[0] = input[0];\n-    output[1] = input[3];\n-    output[2] = input[6];\n-\n-    output[3] = input[1];\n-    output[4] = input[4];\n-    output[5] = input[7];\n-\n-    output[6] = input[2];\n-    output[7] = input[5];\n-    output[8] = input[8];\n-}\n-\n-__global__ void state_update(double *a, double *b, double *c, double *d, double *e, double *_dt_cuda2){\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    int index2 = index % _time_window;\n-    int index3 = index % (_time_window * _JDOF);\n-    int joint_num = index3 / _time_window;\n-\n-    if (index2 == 0)\n-    {\n-        d[index] = b[joint_num] + (_dt_cuda * a[index]); // 속도\n-        e[index] = c[joint_num] + (_dt_cuda * d[index]); // 위치\n-    }\n-    else\n-    {\n-        if(index2 >= _time_window-_dt2_window)\n-        {\n-            d[index] = _dt_cuda2[0] * a[index];\n-            e[index] = 0.0;\n-        }\n-        else\n-        {\n-            d[index] = _dt_cuda * a[index];\n-            e[index] = 0.0;\n-        }\n-        \n-    }\n-    // printf(\"state_update OK \\n\");\n-    __syncthreads();\n-}\n-\n-__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n-{ \n-    // printf(\"joint_limit_cost OK \\n\");\n-    // vel pos cost goal\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    // int index2 = index % _time_window ;\n-    int index3 = index % (_time_window*7);\n-    int joint_num = index3 / _time_window;\n-\n-    double constraint_gain = 500000.0;//pow(10,6)\n-    double vel_gain = 0.0;//pow(10,6)\n-    if(now_gap[0] > gap_limit )\n-    {\n-        vel_gain =  0.0;\n-    }\n-    else\n-    {\n-        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n-    }\n-    \n-\n-    cost_joint_limit[index]=0.0;\n-\n-    // if(index2 >= _time_window-5)\n-    // {   \n-        // if(now_gap[0] > 0.3)\n-        // {\n-        //     if(position[index] < min_joint_limit[joint_num])\n-        //     {\n-        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n-        //     }\n-\n-        //     else if(position[index] > max_joint_limit[joint_num])\n-        //     {\n-        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n-        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n-        //     }\n-        // }\n-        // else\n-        // {\n-        //     if(position[index] < min_joint_limit[joint_num])\n-        //     {\n-        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],min_joint_limit[joint_num]);\n-        //     }\n-\n-        //     else if(position[index] > max_joint_limit[joint_num])\n-        //     {\n-        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],max_joint_limit[joint_num]);\n-        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n-        //     }\n-        // }\n-\n-    // }\n-    // else\n-    // {\n-        if(position[index] <= min_joint_limit[joint_num])\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n-        }\n-\n-        else if(position[index] >= max_joint_limit[joint_num])\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n-            // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n-        }\n-        else\n-        {\n-            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n-        }\n-        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n-        {\n-            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n-        }\n-        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n-        // {\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }  \n-\n-        // if(joint_num == 4)\n-        // {\n-            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }\n-        // else\n-        // {\n-        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-        // }        \n-        // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n-    // }\n-    __syncthreads();\n-}\n-\n-__global__ void cost_function_joint_control(double *d, double *e, double *f, double *g, double *position_sec1, double *position_sec2, double *velocity_lim, double *acc, double *prev_acc, double *min_joint_limit, double *max_joint_limit)\n-{\n-    // vel pos cost goal\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    int index3 = index % (_time_window*7);\n-    int joint_num = index3 / _time_window;\n-\n-    double cost_pos =  abs_cuda2(e[index],g[joint_num]);// + pow(10,2);// * abs(_vel_state(i,j));// + abs(_acc_state(i,j));\n-\tdouble cost_vel =  abs_cuda1(d[index]);\n-    double cost_acc =  abs_cuda2(acc[index],prev_acc[index]);\n-    double pos_gain = 10000.0;//pow(10,4)\n-    double vel_gain = 100.0;//pow(10,1)\n-    double constraint_gain = 10000000.0;//pow(10,6)\n-\n-    if(abs_cuda1(cost_pos) >  position_sec1[0])\n-    {\n-        f[index] = 10000.0 + pos_gain * cost_pos + vel_gain * cost_vel;// + 1.0 * cost_acc;\n-        // printf(\"sec1\\n\");\n-        // printf(\"sec1 : cost[%d] : %f \\n\", index,f[index]);\n-        // printf(\"sec1 : pos[%d] : %f \\n\", index,e[index]);\n-        // printf(\"sec1 : vel[%d] : %f \\n\", index,d[index]);\n-        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n-    }\n-\t///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-\telse if(abs_cuda1(cost_pos) <= position_sec1[0] && abs_cuda1(cost_pos) > position_sec2[0])\n-\t{\n-\t\tf[index] = 1000.0 + pos_gain * cost_pos + vel_gain * cost_vel;\n-        // printf(\"sec2\\n\");\n-        // printf(\"sec2 : cost[%d] : %f \\n\", index,f[index]);\n-        // printf(\"sec2 : pos[%d] : %f \\n\", index,e[index]);\n-        // printf(\"sec2 : vel[%d] : %f \\n\", index,d[index]);\n-        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n-    }\n-\t///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-\telse\n-\t{\n-\t\tf[index] = pos_gain * cost_pos + vel_gain * cost_vel;\n-    }\n-\n-\t///////////////////// Velocity Limit Constraint ///////////////////////////////////////////////////\n-\tif(abs_cuda1(cost_vel) > velocity_lim[0]) // 0.8\n-\t{\n-\t\tf[index] = f[index] + constraint_gain * cost_vel;\n-\t}\n-\n-    ///////////////////// Joint Limit Constraint   ///////////////////////////////////////////////////\n-    if(e[index] < min_joint_limit[joint_num])\n-    {\n-        f[index] = f[index] + constraint_gain * (e[index] - min_joint_limit[joint_num]) * (e[index] - min_joint_limit[joint_num]);\n-    }\n-\n-    else if(e[index] > max_joint_limit[joint_num])\n-    {\n-        f[index] = f[index] + constraint_gain * (e[index] - max_joint_limit[joint_num]) * (e[index] - max_joint_limit[joint_num]);\n-    }\n-    __syncthreads();\n-}\n-\n-__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n-{\n-    // printf(\"cost_function_task_space_control OK \\n\");\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    // int index2 = index % _time_window ;\n-    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n-    double weight2 =  300000.0; // 50000.0 (10.0) // pos\n-    // double weight_manipul = 100.0;\n-\n-    if(index < _sampling_num * _time_window)\n-    {\n-        double rotation_EE_index[9];\n-        for(int i = 0; i<9; i++)\n-        {\n-            rotation_EE_index[i] = rotation_EE[index*9+i];    \n-        }\n-\n-        double PosEE_index[3];\n-        for(int i = 0; i<3; i++)\n-        {\n-            PosEE_index[i] = position[index*3+i];\n-        }\n-        PosEE_index[2] = PosEE_index[2] - 0.01;\n-\n-        double RotGoalT_x_RotEE[9];\n-        double RotGap[3];\n-\n-\n-        // double RotGoalT_x_PosEE[3];\n-        // double RotGoalT_x_PosGoal[3];\n-        double PosGap[3];\n-        double PosGap_2 = 0.0;\n-\n-        matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n-        rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n-\n-        double cost1 = 0.0;\n-        double cost2 = 0.0;\n-        double cost1_2 = 0.0;        \n-        double cost2_2 = 0.0;\n-        double cost3 = 0.0;\n-        // double cost2 = 0.0;\n-\n-        for(int i = 0;i<3; i++)\n-        {\n-            PosGap[i] = abs(PosEE_index[i]-g[i]);\n-            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n-            // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n-\n-            PosGap_2 += abs(PosGap[i]);\n-\n-            // if(PosGap[i] > 1)\n-            // {\n-            //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n-            // }\n-            // else\n-            // {\n-            //     cost2_2 = cost2_2 + PosGap[i];\n-            // }\n-            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n-        }\n-\n-        if(PosGap_2 > gap_limit )\n-        {\n-            cost3 = weight1 * 3.14 * 3 * 2;\n-            weight1 =  0.0;            \n-        }\n-        // else\n-        // {\n-        //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n-        // }\n-\n-        // if(cost1_2 > 1)\n-        // {\n-        //     cost1_2 = pow2_cuda(cost1_2);\n-        // }\n-        // cost1 = cost1_2 + cost2_2;\n-        // if(cost1 > 2.0)\n-        // {\n-        //     f[index] = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        // }\n-        // else if(cost1 <= 2.0 && cost1 > 1.0)\n-        // {\n-        //     f[index] = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-        // }\n-        // else\n-        // {\n-        //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n-        // }\n-\n-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-        if(cost2_2 >  position_sec1[0])\n-        {\n-            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n-        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n-        {\n-            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n-            // cost2 = weight_manipul * (1-_manipulability[index]);\n-        }\n-        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n-        else\n-        {\n-            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n-            // cost2 = (1-_manipulability[index]);\n-        }\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n-        if(sqrt(_manipulability[index])<= 0.1)\n-        {\n-            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n-        }\n-        // f[index] = cost1 + cost2 + cost3;\n-        f[index] = cost1 + cost3;\n-//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n-\n-\n-\n-        // if(now_gap[0] > 1.0)\n-        // {\n-        //     if(index2 < _time_window-5)\n-        //     {\n-        //         f[index] = 0.0;\n-        //     }\n-        // }\n-        // else\n-        // {\n-        //     if(index2 >= _time_window-5)\n-        //     {\n-        //         f[index] = 0.0;\n-        //     }\n-        // }\n-    }    \n-    __syncthreads();\n-}\n-\n-__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n-{\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    int index3 = index % (_time_window*_JDOF);\n-    int joint_num = index3 / _time_window;\n-    // curandState localState = state[index%_time_window];\n-    curandState state;\n-    \n-    // 현재 스레드의 인덱스로 상태 정보 초기화\n-    curand_init(0, index, 0, &state);\n-    // double rand_val;\n-\n-    // rand_val = curand_normal(&localState) * 1.0 + _A[joint_num];\n-    // _matrix_for_cuda[index] = rand_val;\n-    if (index % _time_window == 0)\n-    {\n-        // if(index == 0)\n-        // {\n-        //     _matrix_for_cuda[index] = 0.0;\n-        // }\n-        // else\n-        // {\n-            // _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n-            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n-            if(joint_num>=4)\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n-            }\n-            else\n-            {\n-                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n-            }            \n-        // }\n-        if(abs_cuda1(_matrix_for_cuda[index])>100)\n-        {\n-            _matrix_for_cuda[index] = 0.0;   \n-        }\n-    }\n-    // printf(\"generate_random2 OK \\n\");\n-    __syncthreads();\n-}\n-\n-__global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n-{\n-    // printf(\"GetBodyRotationMatrix OK \\n\");\n-    double Roll = xyzrpy_goal[3];\n-    double Pitch = xyzrpy_goal[4];\n-    double Yaw = xyzrpy_goal[5];\n-\n-    double R_yaw[9];\n-    R_yaw[0] = cos(Yaw);\n-    R_yaw[1] = -sin(Yaw);\n-    R_yaw[2] = 0.0;\n-    R_yaw[3] = sin(Yaw);\n-    R_yaw[4] = cos(Yaw);\n-    R_yaw[5] = 0.0;\n-    R_yaw[6] = 0.0;\n-    R_yaw[7] = 0.0;\n-    R_yaw[8] = 1.0;\n-\n-    double R_pitch[9];\n-    R_pitch[0] = cos(Pitch);\n-    R_pitch[1] = 0.0;\n-    R_pitch[2] = sin(Pitch);\n-    R_pitch[3] = 0.0;\n-    R_pitch[4] = 1.0;\n-    R_pitch[5] = 0.0;\n-    R_pitch[6] = -sin(Pitch);\n-    R_pitch[7] = 0.0;\n-    R_pitch[8] = cos(Pitch);\n-\n-    double R_roll[9];\n-    R_roll[0] = 1.0;\n-    R_roll[1] = 0.0;\n-    R_roll[2] = 0.0;\n-    R_roll[3] = 0.0;\n-    R_roll[4] = cos(Roll);\n-    R_roll[5] = -sin(Roll);\n-    R_roll[6] = 0.0;\n-    R_roll[7] = sin(Roll);\n-    R_roll[8] = cos(Roll);\n-    \n-    double tmp_mat3x3[9];\n-    matrixMultiply_3x3(R_yaw, R_pitch, tmp_mat3x3);\n-    matrixMultiply_3x3(tmp_mat3x3, R_roll, RGyro);\n-}\n-\n-__global__ void prev_computeForwardKinematics(double* FK_a, double* FK_d, double* FK_alpha, double* prev_q, double* position_EE, double* orientation_EE) \n-{\n-    double transformationMatrix[16];\n-    double transformationMatrix2[16];\n-    double tempMatrix[16];\n-    double tempMatrix2[16];\n-    \n-    computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], prev_q[0], transformationMatrix);\n-    computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], prev_q[1], tempMatrix);\n-    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-    computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], prev_q[2], tempMatrix2);\n-    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-    computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], prev_q[3], tempMatrix);\n-    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-    computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], prev_q[4], tempMatrix2);\n-    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-    computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], prev_q[5], tempMatrix);\n-    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-    computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], prev_q[6], tempMatrix2);\n-    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-    // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n-    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n-    // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n-    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n-    position_EE[0] = transformationMatrix[3];\n-    position_EE[1] = transformationMatrix[7];\n-    position_EE[2] = transformationMatrix[11];\n-    //rpy\n-    double tempVec[3];\n-    rpy_from_transformationmatrix(transformationMatrix, tempVec);\n-    orientation_EE[0] = tempVec[0];\n-    orientation_EE[1] = tempVec[1];\n-    orientation_EE[2] = tempVec[2];\n-    // printf(\"prev_computeForwardKinematics OK \\n\");\n-}\n-\n-__global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n-{\n-    // printf(\"computeForwardKinematics OK \\n\");\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    // int index3 = index % (_time_window*7);\n-    // int joint_num = index3 / _time_window;\n-    // 각 변환 행렬 계산\n-\n-    if(index < _sampling_num)\n-    {\n-        for(int i = 0; i<_time_window; i++)\n-        {\n-            double transformationMatrix[16];\n-            double transformationMatrix2[16];\n-\n-            double tempMatrix[16];\n-            double tempMatrix2[16];\n-            double man_6x6[36];\n-\n-            double p0[3];\n-            double p1[3];\n-            double p2[3];\n-            double p3[3];\n-            double p4[3];\n-            double p5[3];\n-            double p6[3];\n-\n-            double z0[3];\n-            double z1[3];\n-            double z2[3];\n-            double z3[3];\n-            double z4[3];\n-            double z5[3];\n-            double z6[3];\n-\n-            double t0[3];\n-            double t1[3];\n-            double t2[3];\n-            double t3[3];\n-            double t4[3];\n-            double t5[3];\n-\n-            p0[0] = 0.0;\n-            p0[1] = 0.0;\n-            p0[2] = FK_d[0];\n-\n-            z0[0] = 0.0;\n-            z0[1] = 0.0;\n-            z0[2] = 1.0;      \n-            \n-            computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], jointAngles[index*_time_window*_JDOF+i], transformationMatrix);\n-\n-            computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], jointAngles[index*_time_window*_JDOF+_time_window+i], tempMatrix);\n-            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-            p1[0] = transformationMatrix2[3];\n-            p1[1] = transformationMatrix2[7];\n-            p1[2] = transformationMatrix2[11];\n-            z1[0] = transformationMatrix2[2];\n-            z1[1] = transformationMatrix2[6];\n-            z1[2] = transformationMatrix2[10];\n-\n-            computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], jointAngles[index*_time_window*_JDOF+2*_time_window+i], tempMatrix2);\n-            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-            p2[0] = transformationMatrix[3];\n-            p2[1] = transformationMatrix[7];\n-            p2[2] = transformationMatrix[11];\n-            z2[0] = transformationMatrix[2];\n-            z2[1] = transformationMatrix[6];\n-            z2[2] = transformationMatrix[10];\n-\n-            computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], jointAngles[index*_time_window*_JDOF+3*_time_window+i], tempMatrix);\n-            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-            p3[0] = transformationMatrix2[3];\n-            p3[1] = transformationMatrix2[7];\n-            p3[2] = transformationMatrix2[11];\n-            z3[0] = transformationMatrix2[2];\n-            z3[1] = transformationMatrix2[6];\n-            z3[2] = transformationMatrix2[10];\n-\n-            computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], jointAngles[index*_time_window*_JDOF+4*_time_window+i], tempMatrix2);\n-            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-            p4[0] = transformationMatrix[3];\n-            p4[1] = transformationMatrix[7];\n-            p4[2] = transformationMatrix[11];\n-            z4[0] = transformationMatrix[2];\n-            z4[1] = transformationMatrix[6];\n-            z4[2] = transformationMatrix[10];\n-\n-            computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], jointAngles[index*_time_window*_JDOF+5*_time_window+i], tempMatrix);\n-            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n-            p5[0] = transformationMatrix2[3];\n-            p5[1] = transformationMatrix2[7];\n-            p5[2] = transformationMatrix2[11];\n-            z5[0] = transformationMatrix2[2];\n-            z5[1] = transformationMatrix2[6];\n-            z5[2] = transformationMatrix2[10];\n-\n-            computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], jointAngles[index*_time_window*_JDOF+6*_time_window+i], tempMatrix2);\n-            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-            p6[0] = transformationMatrix[3];\n-            p6[1] = transformationMatrix[7];\n-            p6[2] = transformationMatrix[11];\n-            z6[0] = transformationMatrix[2];\n-            z6[1] = transformationMatrix[6];\n-            z6[2] = transformationMatrix[10];\n-\n-            t0[0] =  p6[0]-p0[0];\n-            t0[1] =  p6[1]-p0[1];\n-            t0[2] =  p6[2]-p0[2];\n-\n-            t1[0] =  p6[0]-p1[0];\n-            t1[1] =  p6[1]-p1[1];\n-            t1[2] =  p6[2]-p1[2];\n-\n-            t2[0] =  p6[0]-p2[0];\n-            t2[1] =  p6[1]-p2[1];\n-            t2[2] =  p6[2]-p2[2];\n-\n-            t3[0] =  p6[0]-p3[0];\n-            t3[1] =  p6[1]-p3[1];\n-            t3[2] =  p6[2]-p3[2];\n-\n-            t4[0] =  p6[0]-p4[0];\n-            t4[1] =  p6[1]-p4[1];\n-            t4[2] =  p6[2]-p4[2];\n-\n-            t5[0] =  p6[0]-p5[0];\n-            t5[1] =  p6[1]-p5[1];\n-            t5[2] =  p6[2]-p5[2];            \n-\n-            jacobian_matrix[index*_time_window*42+i*42+0] = z0[1]*t0[2]-z0[2]*t0[1];\n-            jacobian_matrix[index*_time_window*42+i*42+7] = z0[2]*t0[0]-z0[0]*t0[2];\n-            jacobian_matrix[index*_time_window*42+i*42+14] = z0[0]*t0[1]-z0[1]*t0[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+1] = z1[1]*t1[2]-z1[2]*t1[1];\n-            jacobian_matrix[index*_time_window*42+i*42+8] = z1[2]*t1[0]-z1[0]*t1[2];\n-            jacobian_matrix[index*_time_window*42+i*42+15] = z1[0]*t1[1]-z1[1]*t1[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+2] = z2[1]*t2[2]-z2[2]*t2[1];\n-            jacobian_matrix[index*_time_window*42+i*42+9] = z2[2]*t2[0]-z2[0]*t2[2];\n-            jacobian_matrix[index*_time_window*42+i*42+16] = z2[0]*t2[1]-z2[1]*t2[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+3] = z3[1]*t3[2]-z3[2]*t3[1];\n-            jacobian_matrix[index*_time_window*42+i*42+10] = z3[2]*t3[0]-z3[0]*t3[2];\n-            jacobian_matrix[index*_time_window*42+i*42+17] = z3[0]*t3[1]-z3[1]*t3[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+4] = z4[1]*t4[2]-z4[2]*t4[1];\n-            jacobian_matrix[index*_time_window*42+i*42+11] = z4[2]*t4[0]-z4[0]*t4[2];\n-            jacobian_matrix[index*_time_window*42+i*42+18] = z4[0]*t4[1]-z4[1]*t4[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+5] = z5[1]*t5[2]-z5[2]*t5[1];\n-            jacobian_matrix[index*_time_window*42+i*42+12] = z5[2]*t5[0]-z5[0]*t5[2];\n-            jacobian_matrix[index*_time_window*42+i*42+19] = z5[0]*t5[1]-z5[1]*t5[0];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+6] = 0.0;\n-            jacobian_matrix[index*_time_window*42+i*42+13] = 0.0;\n-            jacobian_matrix[index*_time_window*42+i*42+20] = 0.0;\n-\n-            jacobian_matrix[index*_time_window*42+i*42+21] = z0[0];\n-            jacobian_matrix[index*_time_window*42+i*42+28] = z0[1];\n-            jacobian_matrix[index*_time_window*42+i*42+35] = z0[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+22] = z1[0];\n-            jacobian_matrix[index*_time_window*42+i*42+29] = z1[1];\n-            jacobian_matrix[index*_time_window*42+i*42+36] = z1[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+23] = z2[0];\n-            jacobian_matrix[index*_time_window*42+i*42+30] = z2[1];\n-            jacobian_matrix[index*_time_window*42+i*42+37] = z2[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+24] = z3[0];\n-            jacobian_matrix[index*_time_window*42+i*42+31] = z3[1];\n-            jacobian_matrix[index*_time_window*42+i*42+38] = z3[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+25] = z4[0];\n-            jacobian_matrix[index*_time_window*42+i*42+32] = z4[1];\n-            jacobian_matrix[index*_time_window*42+i*42+39] = z4[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+26] = z5[0];\n-            jacobian_matrix[index*_time_window*42+i*42+33] = z5[1];\n-            jacobian_matrix[index*_time_window*42+i*42+40] = z5[2];\n-\n-            jacobian_matrix[index*_time_window*42+i*42+27] = z6[0];\n-            jacobian_matrix[index*_time_window*42+i*42+34] = z6[1];\n-            jacobian_matrix[index*_time_window*42+i*42+41] = z6[2];\n-            \n-            for(int l = 0; l<6; l++)\n-            {\n-                for(int j = 0; j<6; j++)\n-                {\n-                    man_6x6[l*6+j] = 0.0;\n-                    for(int k = 0; k<7; k++)\n-                    {\n-                        man_6x6[l*6+j] = man_6x6[l*6+j] + (jacobian_matrix[index*_time_window*42+i*42+l*7+k] * jacobian_matrix[index*_time_window*42+i*42+j*7+k]);\n-                    }                \n-                }\n-            }\n-            determinant_6x6(man_6x6,_manipulability[index*_time_window+i]);\n-            // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n-            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-\n-            // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n-            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n-\n-            transformationMatrix_3x3[index*_time_window*9+i*9] = transformationMatrix[0];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+1] = transformationMatrix[1];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+2] = transformationMatrix[2];\n-\n-            transformationMatrix_3x3[index*_time_window*9+i*9+3] = transformationMatrix[4];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+4] = transformationMatrix[5];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+5] = transformationMatrix[6];\n-\n-            transformationMatrix_3x3[index*_time_window*9+i*9+6] = transformationMatrix[8];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+7] = transformationMatrix[9];\n-            transformationMatrix_3x3[index*_time_window*9+i*9+8] = transformationMatrix[10];\n-\n-            position_EE[index*_time_window*3+i*3] = transformationMatrix[3];\n-            position_EE[index*_time_window*3+i*3+1] = transformationMatrix[7];\n-            position_EE[index*_time_window*3+i*3+2] = transformationMatrix[11];\n-\n-            //rpy\n-            double tempVec[3];\n-            rpy_from_transformationmatrix(transformationMatrix, tempVec);\n-            orientation_EE[index*_time_window*3+i*3] = tempVec[0];\n-            orientation_EE[index*_time_window*3+i*3+1] = tempVec[1];\n-            orientation_EE[index*_time_window*3+i*3+2] = tempVec[2];\n-            \n-            if(i == 0)\n-            {\n-                velocity_EE[index*_time_window*3+i*3] = (transformationMatrix[3] - prev_x[0]) / _dt_cuda;\n-                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - prev_x[1]) / _dt_cuda;\n-                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - prev_x[2]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3] = (tempVec[0] - prev_r[0]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - prev_r[1]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - prev_r[2]) / _dt_cuda;\n-            }\n-            else\n-            {\n-                velocity_EE[index*_time_window*3+i*3+0] = (transformationMatrix[3] - position_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n-                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - position_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n-                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - position_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3+0] = (tempVec[0] - orientation_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - orientation_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n-                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - orientation_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n-            }            \n-        }    \n-    }\n-    __syncthreads();\n-}\n-\n-__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n-{\n-    // printf(\"forwardPropagation OK \\n\");\n-    int tid = threadIdx.x + blockIdx.x * blockDim.x;\n-    \n-    double hidden0[_nodes_cuda];\n-    double hidden1[_nodes_cuda];\n-    \n-    if (tid < _sampling_num) {\n-        for (int j = 0; j < _nodes_cuda; j++) {\n-            hidden0[j] = 0.0;\n-        }\n-    \n-        for (int j = 0; j < _nodes_cuda; j++) {\n-            hidden1[j] = 0.0;\n-        }\n-        \n-        for (int j = 0; j < _nodes_cuda; j++) {\n-            for (int i = 0; i < _JDOF; i++) {\n-                hidden0[j] += inputs[tid * _JDOF + i] * weights0[i * _nodes_cuda + j];\n-            }\n-            \n-            hidden0[j] += weights1[j];\n-            \n-            if (hidden0[j] <= 0) {\n-                hidden0[j] = 0.0;\n-            }\n-        }\n-        \n-        for (int j = 0; j < _nodes_cuda; j++) {\n-            for (int i = 0; i < _nodes_cuda; i++) {\n-                hidden1[j] += hidden0[i] * weights2[i * _nodes_cuda + j];\n-            }\n-            \n-            hidden1[j] += weights3[j];\n-            \n-            if (hidden1[j] <= 0) {\n-                hidden1[j] = 0.0;\n-            }\n-        }\n-    \n-        double output1 = 0.0;\n-    \n-        for (int i = 0; i < _nodes_cuda; i++) {\n-            output1 += hidden1[i] * weights4[i];\n-        }\n-    \n-        output1 += weights5[0];\n-        output1 = sigmoid(output1);\n-    \n-        outputs[tid] = output1;\n-    }\n-    __syncthreads();\n-}\n-\n-__global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n-{\n-    // printf(\"calculate_inputs OK \\n\");\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-\n-    if (index < _JDOF * _sampling_num)\n-    {\n-        inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n-\n-        if (inputs[index] > 1)\n-        {\n-            inputs[index] = 1;\n-        }\n-        else if (inputs[index] < -1)\n-        {\n-            inputs[index] = -1;\n-        }\n-    }\n-    __syncthreads();\n-}\n-\n-__global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n-{\n-    // printf(\"if_find_solution OK \\n\");\n-    int index = threadIdx.x + blockIdx.x * blockDim.x;\n-    if(index < _sampling_num)\n-    {\n-        for(int i = 0; i<_time_window; i++)\n-        {\n-            double tmp_p = 0.0;\n-            tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n-            tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n-            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n-\n-            double rotation_EE_index[9];\n-            for(int j = 0; j<9; j++)\n-            {\n-                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n-            }\n-\n-            double RotGoalT_x_RotEE[9];\n-            double RotGap[3];\n-\n-            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n-            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n-\n-            double tmp_p2 = 0.0;\n-            tmp_p2 = abs_cuda1(RotGap[0]);\n-            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n-            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n-\n-            find_sol[index] = 0;\n-            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n-            {\n-                for(int j = 0; j<_JDOF; j++)\n-                {\n-                    if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n-                    {\n-                        break;\n-                    }\n-                    else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n-                    {\n-                        break;\n-                    }\n-                    else\n-                    {\n-                        find_sol[index] = 1;\n-                        // break;\n-                    }\n-                }\n-                if(find_sol[index] == 1)\n-                {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n-{ \n-    // cout<<\"cuda code start\"<<endl;\n-    // _dt_cuda2[0] = 0.5;\n-    // for(int i = 0; i<6; i++)\n-    // {\n-    //     cout<<_goal_pos_cuda[i]<<endl;    \n-    // }\n-    \n-    prev_x_cost = 0.0;\n-    now_pos_gap[0] = 0.0;\n-    now_pos_gap_all[0] = 0.0;\n-    for(int i = 0; i<3; i++)\n-    {\n-        now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n-        now_pos_gap_all[0] = now_pos_gap_all[0] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n-    }\n-    // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n-    // {\n-    //     _dt_cuda2[0] = now_pos_gap[0];\n-    // }\n-    ////////////////////////////////////////////////////////////////\n-    // if(found_goal == 1)\n-    // {\n-    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n-    //     {\n-    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-    //     }\n-    //     else if(now_pos_gap[0] <= position_sec2[0])\n-    //     {\n-    //         _dt_cuda2[0] = _dt_cuda;\n-    //     }\n-    //     else if(now_pos_gap[0] >= 1.0)\n-    //     {\n-    //         _dt_cuda2[0] = 0.7;\n-    //     }\n-    // }\n-    // else\n-    // {\n-    //     _dt_cuda2[0] = 0.7;\n-    // }\n-    // found_goal = 0;\n-    // if(_dt_cuda2[0] != 0.7)\n-    // {\n-    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-    // }\n-    //////////////////////////////////////////////////////////////\n-    _sol_cost = _sol_cost / 5000;\n-    // 200/\n-\n-    if(_sol_cost > 700)\n-    {\n-        _dt_cuda2[0] = 0.5;\n-    }\n-    else if(_sol_cost <= 700 && _sol_cost > 1)\n-    {\n-        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n-            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n-            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n-        // _dt_cuda2[0] = 0.003;\n-    }\n-    else\n-    {\n-        _dt_cuda2[0] = _dt_cuda;\n-    }\n-    // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n-    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n-\n-    reset_check = 0;\n-    for(int i = 0; i<_JDOF; i++)\n-    {\n-        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n-        {            \n-            reset_check = 1;\n-            break;\n-        }\n-    }\n-    if(reset_check == 1)\n-    {\n-        for(int i = 0; i<_JDOF; i++)\n-        {        \n-            _q_des[i] = _init_pos[i];\n-            _qdot_des[i] = _init_vel[i];\n-            _A[i] = 0.0;\n-        }\n-    }\n-    // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n-    \n-    dim3 blockDim(N/_time_window, 1, 1);\n-    dim3 gridDim(_time_window, 1, 1);\n-    dim3 gridDim2(_sampling_num, 1);\n-    dim3 blockDim2(1, 1);\n-    dim3 blockSize(1, 1);\n-    dim3 gridSize(1, 1);\n-    dim3 blockSize2(1, 1);\n-    dim3 gridSize2(_sampling_num * _time_window, 1);\n-\n-    if(control_mode == 0)\n-    {\n-        cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n-        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n-        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-\n-        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        for(int i = 0; i<N; i++)\n-        {\n-            int index222 = i / _time_window;\n-            if((i%_time_window) != 0)\n-            {\n-                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n-            }\n-        }\n-\n-        // _dt_cuda2\n-        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n-        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n-        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-        \n-        for(int i = 0; i<N; i++)\n-        {\n-            if((i%_time_window) != 0)\n-            {\n-                d[i] = d[i-1] + d[i];\n-                e[i] = e[i-1] + d[i] * _dt_cuda;\n-            }\n-        }\n-\n-        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cudaMemcpy(dev_q_goal, _goal_pos_cuda, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cost_function_joint_control <<< gridDim, blockDim>>> (dev_d, dev_e, dev_cost, dev_q_goal, dev_position_sec1, dev_position_sec2, dev_velocity_lim, dev__matrix_for_cuda, dev__prev_matrix_for_cuda, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost);\n-        \n-        cudaMemcpy(f, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-\n-        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaDeviceSynchronize();\n-\n-        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n-\n-        \n-        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();    \n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _return_cost[i] = 0.0;\n-            for(int j = 0; j<_JDOF; j++)\n-            {\n-                for(int k = 0; k<_time_window; k++)\n-                {\n-                    _return_cost[i] = _return_cost[i] + f[k + (_time_window*j) + (_time_window*_JDOF*i)];\n-                }\n-            }\n-            if(outputs[i] > 0.5)\n-            {\n-                _return_cost[i] = _return_cost[i] + outputs[i] * pow(10,6);\n-            }\n-            _return_cost[i] = _return_cost[i] / _JDOF;\n-        }\n-\n-        _min_cost = 1000000000000000.0;\n-        weight_sum = 0.0;\n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _cost[i] = _return_cost[i];\n-            if(_min_cost > _cost[i])\n-            {\n-                _min_cost = _cost[i];\n-            }\n-        }\n-        memset(_weighted_A, 0, _JDOF * sizeof(double));\n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _cost[i] = _cost[i] - _min_cost;\n-            if(_cost[i]<100)\n-            {\n-                _cost[i] = exp(-_cost[i]);\t\t\n-                weight_sum = weight_sum + _cost[i];\n-                for(int j = 0; j<_JDOF; j++)\n-                {\n-                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n-                }\n-            }\n-        }\n-        for(int j = 0; j<_JDOF; j++)\n-        {\n-            _weighted_A[j] /=  weight_sum;\n-            _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n-        }\n-        \n-        for(int i = 0; i<_JDOF; i++)\n-        {\n-            returnArray[(_JDOF*2)+i] = _weighted_A[i];\n-            returnArray[_JDOF+i] = _qdot_des[i] + (_weighted_A[i] * _dt_cuda);\n-            returnArray[i] = _q_des[i] + (_qdot_des[i] * _dt_cuda);\n-\n-            _q_des[i] = returnArray[i];\n-            _qdot_des[i] = returnArray[_JDOF+i];\n-        }\n-    }\n-\n-    else if(control_mode == 1)\n-    {\n-        // for(int i= 0; i<7; i++)\n-        // {\n-        //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n-        // }\n-        \n-        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n-        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-        for(int i = 0; i<N; i++)\n-        {\n-            int index222 = i / _time_window;\n-            if((i%_time_window) != 0)\n-            {   \n-                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n-                if((i%_time_window) >= _time_window-_dt2_window)\n-                {\n-                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n-                }                \n-            }\n-            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n-        }\n-\n-        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev__matrix_for_cuda, _matrix_for_cuda, N*sizeof(double), cudaMemcpyHostToDevice);\n-        \n-        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n-        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n-        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n-\n-        cudaDeviceSynchronize();\n-        for(int i = 0; i<N; i++)\n-        {\n-            if((i%_time_window) != 0)\n-            {\n-                if((i%_time_window) >= _time_window-_dt2_window)\n-                {\n-                    d[i] = d[i-1] + d[i];\n-                    e[i] = e[i-1] + d[i] * _dt_cuda2[0];\n-                }\n-                else\n-                {\n-                    d[i] = d[i-1] + d[i];\n-                    e[i] = e[i-1] + d[i] * _dt_cuda;\n-                }\n-            }\n-        }\n-\n-        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaDeviceSynchronize();\n-\n-        // cout<<\"222222222222222222222222\"<<endl;\n-        // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaDeviceSynchronize();\n-        // for(int k = 0 ;k <_sampling_num; k++)\n-        // {\n-        //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n-        //     for(int i = 0; i<42; i++)\n-        //     {\n-        //         if(i%7 == 6)\n-        //         {\n-        //             cout<<jacobian[i+42*k]<<endl;    \n-        //         }\n-        //         else\n-        //         {\n-        //             cout<<jacobian[i+42*k]<<\" \";\n-        //         }            \n-        //     }\n-        // }        \n-        \n-        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n-        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-\n-\n-        // cout<<\"CUDA manipulability\"<<endl;\n-        // for(int i = 0; i<N/_JDOF; i++)\n-        // {\n-        //     cout<<\"manipulability ith : \"<<i<<manipulability[i]<<endl;\n-        // }\n-        cudaMemcpy(dev_FK_a, FK_a, 9*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n-        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n-        cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n-\n-        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n-        cudaDeviceSynchronize();\n-        \n-        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n-\n-        cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n-        // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n-        Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n-\n-        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n-        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaMemcpy(dev_now_pos_gap_all, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n-        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap_all);\n-        cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-        \n-\n-        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n-        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n-        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n-        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-        // for(int i = 0; i<_sampling_num * _time_window; i++)\n-        // {\n-        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n-        // }\n-\n-        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n-\n-        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n-        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n-        // {\n-        //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n-        // }\n-        cudaDeviceSynchronize();\n-\n-        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n-        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n-        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n-        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n-        cudaDeviceSynchronize();\n-\n-        // for(int i = 0; i<_sampling_num; i++)\n-        // {\n-        //     if(outputs[i]>0.5)\n-        //     {\n-        //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-        //     }\n-        // }\n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _return_cost[i] = 0.0;\n-            for(int j = 0; j<_JDOF; j++)\n-            {\n-                for(int k = 0; k<_time_window; k++)\n-                {\n-                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n-                }\n-                // if(j == _JDOF-1)\n-                // {\n-                //     _return_cost[i] = _return_cost[i] / _JDOF;\n-                // }\n-            }\n-            // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n-\n-            for(int j = 0 ; j<_time_window; j++)\n-            {\n-                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n-            }\n-            if(found_goal_list[i] == 1)\n-            {\n-                if(outputs[i] >= 0.5)\n-                {\n-                    found_goal_list[i] = 0;\n-                }\n-            }\n-            if(outputs[i] > 0.5)\n-            {\n-                _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n-            }\n-            _return_cost[i] = _return_cost[i] / _JDOF;\n-            // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n-            if(found_goal_list[i] == 1)\n-            {\n-                found_goal = 1;\n-                // cout<<\"??\"<<endl;\n-                // _return_cost[i] = _return_cost[i];\n-            }\n-            // else\n-            // {\n-            //     _return_cost[i] = _return_cost[i] + 100.0;\n-            // }\n-        }\n-\n-        _min_cost = 1000000000000000.0;\n-        weight_sum = 0.0;\n-        // _sol_cost = 0.0;\n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _cost[i] = _return_cost[i];\n-            if(_min_cost > _cost[i])\n-            {\n-                _min_cost = _cost[i];\n-            }\n-        }\n-        _sol_cost = _min_cost;\n-        memset(_weighted_A, 0, _JDOF * sizeof(double));\n-\n-        for(int i = 0; i<_sampling_num; i++)\n-        {\n-            _cost[i] = _cost[i] - _min_cost;\n-            if(_cost[i]<100)\n-            {\n-                _cost[i] = exp(-_cost[i]);\t\t\n-                weight_sum = weight_sum + _cost[i];\n-                for(int j = 0; j<_JDOF; j++)\n-                {\n-                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n-                }\n-            }\n-        }\n-        for(int j = 0; j<_JDOF; j++)\n-        {\n-            _weighted_A[j] /=  weight_sum;\n-            _A[j] = _weighted_A[j];\n-            // if(_A[j] > 10.0)\n-            // {\n-            //     _A[j] = 10.0;\n-            // }\n-            // else if(_A[j] < -10.0)\n-            // {\n-            //     _A[j] = -10.0;\n-            // }\n-        }\n-\n-        // for(int i = 0; i<_JDOF; i++)\n-        // {\n-        //     cout<<_weighted_A[i]<<endl;    \n-        // }\n-        \n-        for(int i = 0; i<_JDOF; i++)\n-        {\n-            returnArray[(_JDOF*2)+i] = _weighted_A[i] ;//* (1+_dt_cuda2[0]-_dt_cuda);\n-            returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n-            returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n-\n-            _q_des[i] = returnArray[i];\n-            _qdot_des[i] = returnArray[_JDOF+i];\n-        }\n-    }\n-}\n-\n-void CudaTest::load_weight()\n-{\n-    ostringstream filename_NN[6];\n-    ifstream weight0;\n-    #if _nodes_cuda == 32\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n-        }\n-    }\n-    #elif _nodes_cuda == 64\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n-        } \n-    }\n-    #elif _nodes_cuda == 100\n-    {\n-        for(int i = 0; i<6; i++)\n-        {\n-            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n-        } \n-    }\n-    #else\n-    #endif\n-    \n-    weight0.open(filename_NN[0].str());\n-    for(int i = 0; i<_JDOF ; i++)\n-    {\n-        for(int j = 0; j<_nodes_cuda ; j++)\n-        {\n-            weight0 >> weights0[i*_nodes_cuda + j];\n-        }\n-    }\n-    weight0.close();\n-    \n-    weight0.open(filename_NN[1].str());\n-    for(int i = 0; i<_nodes_cuda ; i++)\n-    {\n-        weight0 >> weights1[i];\n-    }\n-    weight0.close();\n-\n-    weight0.open(filename_NN[2].str());\n-    for(int i = 0; i<_nodes_cuda ; i++)\n-    {\n-        for(int j = 0; j<_nodes_cuda ; j++)\n-        {\n-            weight0 >> weights2[i*_nodes_cuda + j];\n-        }\n-    }\n-    weight0.close();\n-\n-    weight0.open(filename_NN[3].str());\n-    for(int i = 0; i<_nodes_cuda ; i++)\n-    {\n-        weight0 >> weights3[i];\n-    }\n-    weight0.close();\n-\n-    weight0.open(filename_NN[4].str());\n-    for(int i = 0; i<_nodes_cuda ; i++)\n-    {\n-        weight0 >> weights4[i];\n-    }\n-    weight0.close();\n-    weight0.open(filename_NN[5].str());\n-    weight0 >> weights5[0];\n-    weight0.close();\n-}\n-\n-void CudaTest::cpu_memory_save()\n-{\n-    // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n-    memset(cost_jointlimit, 0, N * sizeof(double));\n-    memset(_mean_matrix, 0, N * sizeof(double));\n-    memset(d, 0, N * sizeof(double));\n-    memset(e, 0, N * sizeof(double));\n-    memset(f, 0, N * sizeof(double));\n-    memset(_matrix_for_cuda, 0, N * sizeof(double));\n-\n-    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n-\n-    memset(FK_d, 0, 9 * sizeof(double));\n-    memset(FK_a, 0, 9 * sizeof(double));\n-    memset(FK_alpha, 0, 9 * sizeof(double));\n-    \n-    memset(_return_cost, 0, _sampling_num * sizeof(double));\n-    memset(_cost, 0, _sampling_num * sizeof(double));\n-\n-    memset(_max_joint_position, 0, _JDOF * sizeof(double));\n-    memset(_min_joint_position, 0, _JDOF * sizeof(double));\n-    memset(_q_des, 0, _JDOF * sizeof(double));\n-    memset(_qdot_des, 0, _JDOF * sizeof(double));\n-    memset(_A, 0, _JDOF * sizeof(double));\n-    memset(_weighted_A, 0, _JDOF * sizeof(double));\n-    memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n-    memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n-    \n-    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n-    memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n-    memset(weights1, 0, _nodes_cuda * sizeof(double));\n-    memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n-    memset(weights3, 0, _nodes_cuda * sizeof(double));\n-    memset(weights4, 0, _nodes_cuda * sizeof(double));\n-    // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n-    memset(outputs, 0, _sampling_num * sizeof(double));\n-    memset(returnArray, 0, _JDOF*3 * sizeof(double));\n-\n-    memset(_prev_x, 0, 3 * sizeof(double));\n-    memset(_prev_r, 0, 3 * sizeof(double));\n-\n-    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n-    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n-\n-    \n-    weights5[0] = 0.0;\n-    position_sec1[0] = 0.0;\n-    position_sec2[0] = 0.0;\n-    velocity_lim[0] = 0.0;\n-}\n-\n-void CudaTest::cuda_memory_save()\n-{\n-    // cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n-    cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n-    cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n-    cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n-    // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n-    cudaMalloc((void**)&dev_states, N*sizeof(double));\n-\n-    // cudaMalloc((void**)&dev_a, N * sizeof(double));\n-    cudaMalloc((void**)&dev_b, _JDOF*sizeof(double));\n-    cudaMalloc((void**)&dev_c, _JDOF*sizeof(double));\n-    cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n-    cudaMalloc((void**)&dev_d, N * sizeof(double));\n-    cudaMalloc((void**)&dev_e, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost, N * sizeof(double));\n-    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n-    cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n-    cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n-    cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n-\n-    cudaMalloc((void**)&d_weights0, _JDOF * _nodes_cuda * sizeof(double));\n-    cudaMalloc((void**)&d_weights1, _nodes_cuda * sizeof(double));\n-    cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n-    cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n-    cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n-    cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n-    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n-\n-    cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n-    cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n-    cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n-    cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n-    cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n-    cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n-    cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n-\n-    // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n-    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n-    cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n-    cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n-    cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n-    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n-    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n-    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double));\n-    cudaMalloc((void**)&dev_now_pos_gap_all, sizeof(double));\n-    cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n-    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n-\n-    cudaMalloc((void**)&dev_alpha, sizeof(double));\n-    cudaMalloc((void**)&dev_beta, sizeof(double));   \n-}\n-\n-void CudaTest::cuda_memory_free()\n-{    \n-    // cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n-    cudaFree(dev__A);\n-    cudaFree(dev__mean_matrix);\n-    cudaFree(dev__matrix_for_cuda);\n-    // cudaFree(dev__prev_matrix_for_cuda);\n-    cudaFree(dev_states);\n-\n-    cudaFree(dev_b);\n-    cudaFree(dev_c);\n-    cudaFree(dev_d);\n-    cudaFree(dev_e);\n-    cudaFree(dev_cost);\n-    cudaFree(dev_cost_x);\n-    \n-    cudaFree(dev_q_goal);\n-    cudaFree(dev_x_goal);\n-    cudaFree(dev_rot_goal);\n-    cudaFree(dev_rot_goal_T);\n-\n-    cudaFree(d_weights0);\n-    cudaFree(d_weights1);\n-    cudaFree(d_weights2);\n-    cudaFree(d_weights3);\n-    cudaFree(d_weights4);\n-    cudaFree(d_weights5);\n-    cudaFree(d_outputs);\n-\n-    cudaFree(hidden0);\n-    cudaFree(hidden1);\n-\n-    cudaFree(dev_inputs);\n-    cudaFree(dev_min_joint_position_for_NN);\n-    cudaFree(dev_max_joint_position_for_NN);\n-\n-    cudaFree(dev_joint_min_limit_for_cost);\n-    cudaFree(dev_joint_max_limit_for_cost);\n-    cudaFree(dev_cen_joint_position);\n-\n-    cudaFree(dev_position_sec1);\n-    cudaFree(dev_position_sec2);\n-    cudaFree(dev_velocity_lim);\n-\n-    // cudaFree(_dev_jacobian);\n-    cudaFree(dev_position_EE);\n-    cudaFree(dev_orientation_EE);\n-\n-    cudaFree(dev_FK_a);\n-    cudaFree(dev_FK_d);\n-    cudaFree(dev_FK_alpha);\n-\n-    cudaFree(dev_jacobian);\n-    cudaFree(dev_jacobian_transpose);\n-\n-    cudaFree(dev_alpha);\n-    cudaFree(dev_beta);\n-\n-    cudaError_t error = cudaGetLastError();\n-    if (error != cudaSuccess) {\n-        printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n-        // 에러 처리 로직을 추가해야 합니다.\n-    }\n-}\n-\n-void CudaTest::initialize()\n-{\n-    // cout<<endl;\n-    // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n-    // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n-    // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n-    // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n-\n-    // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n-    _sol_cost = 0.0;\n-\n-    position_sec1[0] = 0.03125;\n-    position_sec2[0] = 0.005;\n-    velocity_lim[0] = 0.8;\n-\n-    // position_sec1[0] = 0.03125;\n-    // position_sec2[0] = 0.00625;\n-    // velocity_lim[0] = 1.0;\n-\t\n-    // numBlocks = N / THREADS_PER_BLOCK;\n-    // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n-\n-\n-    // panda_arm_hand.urdf // panda_arm_hand.xml model\n-\t// _min_joint_position[0] = -2.9671;\n-\t// _min_joint_position[1] = -1.8326;\n-\t// _min_joint_position[2] = -2.9671;\n-\t// _min_joint_position[3] = -3.1416;\n-\t// _min_joint_position[4] = -2.9671;\n-\t// _min_joint_position[5] = -0.0873;\n-\t// _min_joint_position[6] = -2.9671;\n-\n-\t// _max_joint_position[0] = 2.9671;\n-\t// _max_joint_position[1] = 1.8326;\n-\t// _max_joint_position[2] = 2.9671;\n-\t// _max_joint_position[3] = 0.0;\n-\t// _max_joint_position[4] = 2.9671;\n-\t// _max_joint_position[5] = 3.8223;\n-\t// _max_joint_position[6] = 2.9671;\n-\n-\n-\n-    // fr3.urdf // fr3.xml model\n-    _min_joint_position[0] = -2.8973;\n-\t_min_joint_position[1] = -1.7628;\n-\t_min_joint_position[2] = -2.8973;\n-\t_min_joint_position[3] = -3.0718;\n-\t_min_joint_position[4] = -2.8973;\n-\t_min_joint_position[5] = -0.0175;\n-\t_min_joint_position[6] = -2.8973;\n-\n-\t_max_joint_position[0] = 2.8973;\n-\t_max_joint_position[1] = 1.7628;\n-\t_max_joint_position[2] = 2.8973;\n-\t_max_joint_position[3] = -0.0698;\n-\t_max_joint_position[4] = 2.8973;\n-\t_max_joint_position[5] = 3.7525;\n-\t_max_joint_position[6] = 2.8973;\n-\n-\n-\n-    //k = 0.1\n-    // _hat_min_joint_position[0] = -2.37368;\n-    // _hat_max_joint_position[0] = 2.37368;\n-\n-    // _hat_min_joint_position[1] = -1.46608;\n-    // _hat_max_joint_position[1] = 1.46608;\n-\n-    // _hat_min_joint_position[2] = -2.37368;\n-    // _hat_max_joint_position[2] = 2.37368;\n-\n-    // _hat_min_joint_position[3] = −2.82744;\n-    // _hat_max_joint_position[3] = -0.31416;\n-\n-    // _hat_min_joint_position[4] = -2.37368;\n-    // _hat_max_joint_position[4] = 2.37368;\n-\n-    // _hat_min_joint_position[5] = 0.30366;\n-    // _hat_max_joint_position[5] = 3.43134;\n-\n-    // _hat_min_joint_position[6] = -2.37368;\n-    // _hat_max_joint_position[6] = 2.37368;\n-\n-\n-\n-    for(int i = 0; i<_JDOF; i++)\n-    {\n-        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n-        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n-    }\n-\n-    FK_a[0] = 0.0;\n-    FK_d[0] = 0.343;\n-    FK_alpha[0] = 0.0;\n-\n-    FK_a[1] = 0.0;\n-    FK_d[1] = 0.0;\n-    FK_alpha[1] = -PI_CUDA/2.0;\n-\n-    FK_a[2] = 0.0;\n-    FK_d[2] = 0.316;\n-    FK_alpha[2] = PI_CUDA/2.0;\n-\n-    FK_a[3] = 0.0825;\n-    FK_d[3] = 0.0;\n-    FK_alpha[3] = PI_CUDA/2.0;\n-\n-    FK_a[4] = -0.0825;\n-    FK_d[4] = 0.384;\n-    FK_alpha[4] = -PI_CUDA/2.0;\n-\n-    FK_a[5] = 0.0;\n-    FK_d[5] = 0.0;\n-    FK_alpha[5] = PI_CUDA/2.0;\n-\n-    FK_a[6] = 0.088;\n-    FK_d[6] = 0.0;\n-    FK_alpha[6] = PI_CUDA/2.0;\n-\n-    FK_a[7] = 0.0;\n-    FK_d[7] = 0.107;\n-    FK_alpha[7] = 0.0;\n-\n-    FK_a[8] = 0.0;\n-    FK_d[8] = 0.1034;\n-    FK_alpha[8] = 0.0;\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1692853422979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -374,9 +374,8 @@\n     {\n         vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n     }\n     \n-\n     cost_joint_limit[index]=0.0;\n \n     // if(index2 >= _time_window-5)\n     // {   \n"
                },
                {
                    "date": 1692859978887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -364,9 +364,9 @@\n     int index3 = index % (_time_window*7);\n     int joint_num = index3 / _time_window;\n \n     double constraint_gain = 500000.0;//pow(10,6)\n-    double vel_gain = 300.0;//pow(10,6)\n+    double vel_gain = 1000.0;//pow(10,6)\n     if(now_gap[0] > 0.05 )\n     {\n         vel_gain =  0.0;\n     }\n"
                },
                {
                    "date": 1693468548197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2056 @@\n+#include <cuda_runtime.h>\n+#include <device_launch_parameters.h>\n+#include \"cuda.cuh\"\n+\n+#define THREADS_PER_BLOCK _sampling_num\n+#define THREADS_PER_BLOCK2 _sampling_num\n+\n+// device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\");\n+\n+\n+CudaTest::CudaTest(void)\n+{   \n+}\n+\n+CudaTest::~CudaTest(void)\n+{    \n+    \n+}\n+\n+__device__ double sigmoid(double x) {\n+    return 1.0 / (1.0 + expf(-x));\n+}\n+\n+__device__ double abs_cuda1(double x) {\n+    if(x<0)\n+    {\n+        return -x;\n+    }\n+    else\n+    {\n+        return x;\n+    }\n+}\n+\n+__device__ double abs_cuda2(double x, double y) {\n+    if(x-y<0)\n+    {\n+        return -x+y;\n+    }\n+    else\n+    {\n+        return x-y;\n+    }\n+}\n+\n+__device__ double pow2_cuda(double x) {\n+    return x*x;\n+}\n+\n+\n+__device__ double norm2_vector3(double *x)\n+{\n+    double _norm2 = 0.0;\n+    for(int i = 0; i<3; i++)\n+    {\n+        _norm2 = _norm2 + (x[i] * x[i]);\n+    }\n+    _norm2 = sqrt(_norm2);\n+    return _norm2;\n+}\n+\n+__device__ double calculateSingularValue(double* matrix) \n+{\n+    int row = threadIdx.y;\n+    int col = threadIdx.x;\n+    \n+    // 3x3 행렬의 크기를 정의\n+    int matrixSize = 3;\n+    \n+    // 행렬의 요소를 읽음\n+    double element = matrix[row * matrixSize + col];\n+    double singularValue = 0.0;\n+    \n+    // 행렬의 특잇값은 고유값의 제곱근이므로 제곱을 계산\n+    element *= element;\n+    \n+    // 각 스레드마다 계산한 제곱된 특잇값을 공유 메모리에 저장\n+    __shared__ double sharedData[9];\n+    sharedData[row * matrixSize + col] = element;\n+    \n+    // 동기화\n+    __syncthreads();\n+    \n+    // 공유 메모리의 값을 최대값으로 업데이트\n+    if (threadIdx.x == 0 && threadIdx.y == 0) {\n+        double maxVal = 0.0;\n+        for (int i = 0; i < 9; i++) {\n+            if (sharedData[i] > maxVal) {\n+                maxVal = sharedData[i];\n+            }\n+        }\n+        singularValue = sqrt(maxVal);\n+    }\n+    return singularValue;\n+}\n+\n+__device__ void computeTransformationMatrix(double alpha, double a, double d, double theta, double* matrix) \n+{\n+    double cosTheta = cos(theta);\n+    double sinTheta = sin(theta);\n+    double cosAlpha = cos(alpha);\n+    double sinAlpha = sin(alpha);\n+\n+    matrix[0] = cosTheta;\n+    matrix[1] = -sinTheta;\n+    matrix[2] = 0;\n+    matrix[3] = a;\n+\n+    matrix[4] = sinTheta * cosAlpha;\n+    matrix[5] = cosTheta * cosAlpha;\n+    matrix[6] = -sinAlpha;\n+    matrix[7] = -d * sinAlpha;\n+\n+    matrix[8] = sinTheta * sinAlpha;\n+    matrix[9] = cosTheta * sinAlpha;\n+    matrix[10] = cosAlpha;\n+    matrix[11] = d * cosAlpha;\n+    \n+    matrix[12] = 0.0;\n+    matrix[13] = 0.0;\n+    matrix[14] = 0.0;\n+    matrix[15] = 1.0;\n+}\n+\n+__device__ void matrixMultiply_4x4(double *mat1, double *mat2, double *mat3)\n+{\n+    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[4] + mat1[2] * mat2[8] + mat1[3] * mat2[12];\n+    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[5] + mat1[2] * mat2[9] + mat1[3] * mat2[13];\n+    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[6] + mat1[2] * mat2[10] + mat1[3] * mat2[14];\n+    mat3[3] = mat1[0] * mat2[3] + mat1[1] * mat2[7] + mat1[2] * mat2[11] + mat1[3] * mat2[15];\n+\n+    mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[4] + mat1[6] * mat2[8] + mat1[7] * mat2[12];\n+    mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[5] + mat1[6] * mat2[9] + mat1[7] * mat2[13];\n+    mat3[6] = mat1[4] * mat2[2] + mat1[5] * mat2[6] + mat1[6] * mat2[10] + mat1[7] * mat2[14];\n+    mat3[7] = mat1[4] * mat2[3] + mat1[5] * mat2[7] + mat1[6] * mat2[11] + mat1[7] * mat2[15];\n+\n+    mat3[8] = mat1[8] * mat2[0] + mat1[9] * mat2[4] + mat1[10] * mat2[8] + mat1[11] * mat2[12];\n+    mat3[9] = mat1[8] * mat2[1] + mat1[9] * mat2[5] + mat1[10] * mat2[9] + mat1[11] * mat2[13];\n+    mat3[10] = mat1[8] * mat2[2] + mat1[9] * mat2[6] + mat1[10] * mat2[10] + mat1[11] * mat2[14];\n+    mat3[11] = mat1[8] * mat2[3] + mat1[9] * mat2[7] + mat1[10] * mat2[11] + mat1[11] * mat2[15];\n+\n+    mat3[12] = mat1[12] * mat2[0] + mat1[13] * mat2[4] + mat1[14] * mat2[8] + mat1[15] * mat2[12];\n+    mat3[13] = mat1[12] * mat2[1] + mat1[13] * mat2[5] + mat1[14] * mat2[9] + mat1[15] * mat2[13];\n+    mat3[14] = mat1[12] * mat2[2] + mat1[13] * mat2[6] + mat1[14] * mat2[10] + mat1[15] * mat2[14];\n+    mat3[15] = mat1[12] * mat2[3] + mat1[13] * mat2[7] + mat1[14] * mat2[11] + mat1[15] * mat2[15];\n+}\n+\n+__device__ void matrixMultiply_3x3(double *mat1, double *mat2, double *mat3)\n+{\n+    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[3] + mat1[2] * mat2[6];\n+    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[4] + mat1[2] * mat2[7];\n+    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[5] + mat1[2] * mat2[8];\n+\n+    mat3[3] = mat1[3] * mat2[0] + mat1[4] * mat2[3] + mat1[5] * mat2[6];\n+    mat3[4] = mat1[3] * mat2[1] + mat1[4] * mat2[4] + mat1[5] * mat2[7];\n+    mat3[5] = mat1[3] * mat2[2] + mat1[4] * mat2[5] + mat1[5] * mat2[8];\n+\n+    mat3[6] = mat1[6] * mat2[0] + mat1[7] * mat2[3] + mat1[8] * mat2[6];\n+    mat3[7] = mat1[6] * mat2[1] + mat1[7] * mat2[4] + mat1[8] * mat2[7];\n+    mat3[8] = mat1[6] * mat2[2] + mat1[7] * mat2[5] + mat1[8] * mat2[8];\n+}\n+\n+__device__ void rpy_from_transformationmatrix(double *RotMat, double *rpy)\n+{\n+    // rpy[1] = RotMat[8];\n+    rpy[1] = -asin(RotMat[8]);\n+    if(RotMat[8] > 1.0 - _threshold_cuda && RotMat[8] < 1.0 + _threshold_cuda)\n+    {\n+        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else if (RotMat[8] < -1.0 + _threshold_cuda && RotMat[8] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n+    {//Gimbal lock, pitch = 90deg\n+        rpy[0] = atan2(RotMat[1], RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else //general solution\n+    {\n+        rpy[0] = atan2(RotMat[9], RotMat[10]);\n+        rpy[2] = atan2(RotMat[4], RotMat[0]);\n+    }\n+}\n+\n+__device__ void rpy_from_rotationmatrix(double *RotMat, double *rpy)\n+{\n+    // rpy[1] = RotMat[8];\n+    rpy[1] = -asin(RotMat[6]);\n+    if(RotMat[6] > 1.0 - _threshold_cuda && RotMat[6] < 1.0 + _threshold_cuda)\n+    {\n+        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else if (RotMat[6] < -1.0 + _threshold_cuda && RotMat[6] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n+    {//Gimbal lock, pitch = 90deg\n+        rpy[0] = atan2(RotMat[1], RotMat[2]);\n+        rpy[2] = 0.0;\n+    }\n+    else //general solution\n+    {\n+        rpy[0] = atan2(RotMat[7], RotMat[8]);\n+        rpy[2] = atan2(RotMat[3], RotMat[0]);\n+    }\n+}\n+\n+__device__ void determinant_6x6(double *matrix, double result)\n+{\n+    int tid = threadIdx.x;\n+    int stride = blockDim.x;\n+\n+    double temp[6][6];\n+    for (int i = 0; i < 6; i++) {\n+        for (int j = 0; j < 6; j++) {\n+            temp[i][j] = matrix[i * 6 + j];\n+        }\n+    }\n+\n+    for (int k = 0; k < 6 - 1; k++) {\n+        for (int i = k + 1 + tid; i < 6; i += stride) {\n+            double ratio = temp[i][k] / temp[k][k];\n+            for (int j = k; j < 6; j++) {\n+                temp[i][j] -= ratio * temp[k][j];\n+            }\n+        }\n+        __syncthreads();\n+    }\n+\n+    if (tid == 0) {\n+        result = 1.0;\n+        for (int i = 0; i < 6; i++) {\n+            result *= temp[i][i];\n+        }\n+    }\n+}\n+\n+__global__ void cal_jacobian(double *theta_table, double *_jacobian)\n+{\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index/_time_window;\n+    int index3 = index*6*_JDOF;\n+    // double theta[7];\n+\n+    if(index<_sampling_num )\n+    {\n+        \n+        // for(int i = 0; i<_JDOF;)\n+        // {\n+        //     theta[i]= theta_table[(index*_JDOF*_time_window)+(_time_window*i)+(_time_window-1)];\n+        // }\n+\n+        double cash = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_1 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_2 = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash_3 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        double cash0 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        double cash0_1 = (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        double cash1 = (sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n+        double cash2 = ((-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]));\n+        double cash2_2 = (cash2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        double cash3 = ((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + cash*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        double cash4 = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);    \n+\n+        _jacobian[index3 + 0] = ((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+(((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+((-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))-768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-632)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n+        _jacobian[index3 + 1] = (176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cash+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+632)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n+        _jacobian[index3 + 2] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 3] = (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*cash;\n+        _jacobian[index3 + 4] = -cash0_1*cash1 + (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n+        _jacobian[index3 + 5] = -cash0_1*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        _jacobian[index3 + 6] = 0.0;\n+\n+        _jacobian[index3 + 7] = 11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400;\n+        _jacobian[index3 + 8] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 9] = -(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) + (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 10] =  -(sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125)*cash;\n+        _jacobian[index3 + 11] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*cash1 - (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n+        _jacobian[index3 + 12] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) - (cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n+        _jacobian[index3 + 13] = 0.0;\n+\n+        _jacobian[index3 + 14] = 0.0;\n+        _jacobian[index3 + 15] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 16] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 17] = (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125);\n+        _jacobian[index3 + 18] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])) + cash0_1*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n+        _jacobian[index3 + 19] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + cash0_1*(cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n+        _jacobian[index3 + 20] = 0.0;\n+\n+        _jacobian[index3 + 21] = 0.0;\n+        _jacobian[index3 + 22] = -sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 23] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 24] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 25] = -(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4;\n+        _jacobian[index3 + 26] = cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 27] = cash2_2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+\n+        _jacobian[index3 + 28] = 0.0;\n+        _jacobian[index3 + 29] = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n+        _jacobian[index3 + 30] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 31] = cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n+        _jacobian[index3 + 32] = -(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n+        _jacobian[index3 + 33] = ((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 34] = (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+\n+        _jacobian[index3 + 35] = 1.0;\n+        _jacobian[index3 + 36] = 0.0;\n+        _jacobian[index3 + 37] = cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n+        _jacobian[index3 + 38] = -cash;\n+        _jacobian[index3 + 39] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n+        _jacobian[index3 + 40] = (-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n+        _jacobian[index3 + 41] = cash3*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - cash1*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n+    }\n+    //  __syncthreads();\n+}\n+\n+__global__ void Transpose_Matrix_3x3(double *input, double *output)\n+{\n+    // printf(\"Transpose_Matrix_3x3 OK \\n\");\n+    output[0] = input[0];\n+    output[1] = input[3];\n+    output[2] = input[6];\n+\n+    output[3] = input[1];\n+    output[4] = input[4];\n+    output[5] = input[7];\n+\n+    output[6] = input[2];\n+    output[7] = input[5];\n+    output[8] = input[8];\n+}\n+\n+__global__ void state_update(double *a, double *b, double *c, double *d, double *e, double *_dt_cuda2){\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index2 = index % _time_window;\n+    int index3 = index % (_time_window * _JDOF);\n+    int joint_num = index3 / _time_window;\n+\n+    if (index2 == 0)\n+    {\n+        d[index] = b[joint_num] + (_dt_cuda * a[index]); // 속도\n+        e[index] = c[joint_num] + (_dt_cuda * d[index]); // 위치\n+    }\n+    else\n+    {\n+        if(index2 >= _time_window-_dt2_window)\n+        {\n+            d[index] = _dt_cuda2[0] * a[index];\n+            e[index] = 0.0;\n+        }\n+        else\n+        {\n+            d[index] = _dt_cuda * a[index];\n+            e[index] = 0.0;\n+        }\n+        \n+    }\n+    // printf(\"state_update OK \\n\");\n+    __syncthreads();\n+}\n+\n+__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n+{ \n+    // printf(\"joint_limit_cost OK \\n\");\n+    // vel pos cost goal\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index % _time_window ;\n+    int index3 = index % (_time_window*7);\n+    int joint_num = index3 / _time_window;\n+\n+    double constraint_gain = 500000.0;//pow(10,6)\n+    double vel_gain = 500.0;//pow(10,6)\n+    if(now_gap[0] > 0.05 )\n+    {\n+        vel_gain =  0.0;\n+    }\n+    else\n+    {\n+        vel_gain =  abs_cuda1(1-now_gap[0]/gap_limit) * vel_gain;\n+    }\n+    \n+    cost_joint_limit[index]=0.0;\n+\n+    // if(index2 >= _time_window-5)\n+    // {   \n+        // if(now_gap[0] > 0.3)\n+        // {\n+        //     if(position[index] < min_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        //     }\n+\n+        //     else if(position[index] > max_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        //     }\n+        // }\n+        // else\n+        // {\n+        //     if(position[index] < min_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        //     }\n+\n+        //     else if(position[index] > max_joint_limit[joint_num])\n+        //     {\n+        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        //     }\n+        // }\n+\n+    // }\n+    // else\n+    // {\n+        if(position[index] <= min_joint_limit[joint_num])\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],min_joint_limit[joint_num]);\n+        }\n+\n+        else if(position[index] >= max_joint_limit[joint_num])\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain;// * abs_cuda2(position[index],max_joint_limit[joint_num]);\n+            // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n+        }\n+        else\n+        {\n+            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n+        }\n+        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n+        {\n+            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n+        }\n+        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n+        // {\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }  \n+\n+        // if(joint_num == 4)\n+        // {\n+            cost_joint_limit[index] = cost_joint_limit[index] + 2000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }\n+        // else\n+        // {\n+        //     // cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        //     cost_joint_limit[index] = cost_joint_limit[index] + 6000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+        // }        \n+        // cost_joint_limit[index] = cost_joint_limit[index] + 3000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n+    // }\n+    __syncthreads();\n+}\n+\n+__global__ void cost_function_joint_control(double *d, double *e, double *f, double *g, double *position_sec1, double *position_sec2, double *velocity_lim, double *acc, double *prev_acc, double *min_joint_limit, double *max_joint_limit)\n+{\n+    // vel pos cost goal\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index3 = index % (_time_window*7);\n+    int joint_num = index3 / _time_window;\n+\n+    double cost_pos =  abs_cuda2(e[index],g[joint_num]);// + pow(10,2);// * abs(_vel_state(i,j));// + abs(_acc_state(i,j));\n+\tdouble cost_vel =  abs_cuda1(d[index]);\n+    double cost_acc =  abs_cuda2(acc[index],prev_acc[index]);\n+    double pos_gain = 10000.0;//pow(10,4)\n+    double vel_gain = 100.0;//pow(10,1)\n+    double constraint_gain = 10000000.0;//pow(10,6)\n+\n+    if(abs_cuda1(cost_pos) >  position_sec1[0])\n+    {\n+        f[index] = 10000.0 + pos_gain * cost_pos + vel_gain * cost_vel;// + 1.0 * cost_acc;\n+        // printf(\"sec1\\n\");\n+        // printf(\"sec1 : cost[%d] : %f \\n\", index,f[index]);\n+        // printf(\"sec1 : pos[%d] : %f \\n\", index,e[index]);\n+        // printf(\"sec1 : vel[%d] : %f \\n\", index,d[index]);\n+        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n+    }\n+\t///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+\telse if(abs_cuda1(cost_pos) <= position_sec1[0] && abs_cuda1(cost_pos) > position_sec2[0])\n+\t{\n+\t\tf[index] = 1000.0 + pos_gain * cost_pos + vel_gain * cost_vel;\n+        // printf(\"sec2\\n\");\n+        // printf(\"sec2 : cost[%d] : %f \\n\", index,f[index]);\n+        // printf(\"sec2 : pos[%d] : %f \\n\", index,e[index]);\n+        // printf(\"sec2 : vel[%d] : %f \\n\", index,d[index]);\n+        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n+    }\n+\t///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+\telse\n+\t{\n+\t\tf[index] = pos_gain * cost_pos + vel_gain * cost_vel;\n+    }\n+\n+\t///////////////////// Velocity Limit Constraint ///////////////////////////////////////////////////\n+\tif(abs_cuda1(cost_vel) > velocity_lim[0]) // 0.8\n+\t{\n+\t\tf[index] = f[index] + constraint_gain * cost_vel;\n+\t}\n+\n+    ///////////////////// Joint Limit Constraint   ///////////////////////////////////////////////////\n+    if(e[index] < min_joint_limit[joint_num])\n+    {\n+        f[index] = f[index] + constraint_gain * (e[index] - min_joint_limit[joint_num]) * (e[index] - min_joint_limit[joint_num]);\n+    }\n+\n+    else if(e[index] > max_joint_limit[joint_num])\n+    {\n+        f[index] = f[index] + constraint_gain * (e[index] - max_joint_limit[joint_num]) * (e[index] - max_joint_limit[joint_num]);\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n+{\n+    // printf(\"cost_function_task_space_control OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index2 = index % _time_window ;\n+    double weight1 =  100000.0; // 10000.0 (10.0) // rot\n+    double weight2 =  300000.0; // 50000.0 (10.0) // pos\n+    // double weight_manipul = 100.0;\n+\n+    if(index < _sampling_num * _time_window)\n+    {\n+        double rotation_EE_index[9];\n+        for(int i = 0; i<9; i++)\n+        {\n+            rotation_EE_index[i] = rotation_EE[index*9+i];    \n+        }\n+\n+        double PosEE_index[3];\n+        for(int i = 0; i<3; i++)\n+        {\n+            PosEE_index[i] = position[index*3+i];\n+        }\n+        PosEE_index[2] = PosEE_index[2] - 0.01;\n+\n+        double RotGoalT_x_RotEE[9];\n+        double RotGap[3];\n+\n+\n+        // double RotGoalT_x_PosEE[3];\n+        // double RotGoalT_x_PosGoal[3];\n+        double PosGap[3];\n+        double PosGap_2 = 0.0;\n+\n+        matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n+        rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+\n+        double cost1 = 0.0;\n+        double cost2 = 0.0;\n+        double cost1_2 = 0.0;        \n+        double cost2_2 = 0.0;\n+        double cost3 = 0.0;\n+        // double cost2 = 0.0;\n+\n+        for(int i = 0;i<3; i++)\n+        {\n+            PosGap[i] = abs(PosEE_index[i]-g[i]);\n+            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n+            // cost1_2 = cost1_2 + abs_cuda1(RotGap[i]) + pow2_cuda(RotGap[i]);\n+\n+            PosGap_2 += abs(PosGap[i]);\n+\n+            // if(PosGap[i] > 1)\n+            // {\n+            //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n+            // }\n+            // else\n+            // {\n+            //     cost2_2 = cost2_2 + PosGap[i];\n+            // }\n+            cost2_2 += pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n+        }\n+\n+        if(PosGap_2 > gap_limit )\n+        {\n+            cost3 = weight1 * 3.14 * 3 * 2;\n+            weight1 =  0.0;            \n+        }\n+        // else\n+        // {\n+        //     // weight1 =  abs_cuda1(gap_limit-PosGap_2) * weight1;\n+        // }\n+\n+        // if(cost1_2 > 1)\n+        // {\n+        //     cost1_2 = pow2_cuda(cost1_2);\n+        // }\n+        // cost1 = cost1_2 + cost2_2;\n+        // if(cost1 > 2.0)\n+        // {\n+        //     f[index] = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+        // else if(cost1 <= 2.0 && cost1 > 1.0)\n+        // {\n+        //     f[index] = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+        // else\n+        // {\n+        //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n+        // }\n+\n+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+        if(cost2_2 >  position_sec1[0])\n+        {\n+            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n+        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n+        {\n+            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n+            // cost2 = weight_manipul * (1-_manipulability[index]);\n+        }\n+        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n+        else\n+        {\n+            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n+            // cost2 = (1-_manipulability[index]);\n+        }\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n+        if(sqrt(_manipulability[index])<= 0.1)\n+        {\n+            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n+        }\n+        // f[index] = cost1 + cost2 + cost3;\n+        f[index] = cost1 + cost3;\n+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+\n+\n+        // if(now_gap[0] > 1.0)\n+        // {\n+        //     if(index2 < _time_window-5)\n+        //     {\n+        //         f[index] = 0.0;\n+        //     }\n+        // }\n+        // else\n+        // {\n+        //     if(index2 >= _time_window-5)\n+        //     {\n+        //         f[index] = 0.0;\n+        //     }\n+        // }\n+    }    \n+    __syncthreads();\n+}\n+\n+__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n+{\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    int index3 = index % (_time_window*_JDOF);\n+    int joint_num = index3 / _time_window;\n+    // curandState localState = state[index%_time_window];\n+    curandState state;\n+    \n+    // 현재 스레드의 인덱스로 상태 정보 초기화\n+    curand_init(0, index, 0, &state);\n+    // double rand_val;\n+\n+    // rand_val = curand_normal(&localState) * 1.0 + _A[joint_num];\n+    // _matrix_for_cuda[index] = rand_val;\n+    if (index % _time_window == 0)\n+    {\n+        // if(index == 0)\n+        // {\n+        //     _matrix_for_cuda[index] = 0.0;\n+        // }\n+        // else\n+        // {\n+            // _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];\n+            // printf(\"_matrix_for_cuda[index] : %f\\n\",_matrix_for_cuda[index]);\n+            if(joint_num>=4)\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n+            }\n+            else\n+            {\n+                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n+            }            \n+        // }\n+        if(abs_cuda1(_matrix_for_cuda[index])>100)\n+        {\n+            _matrix_for_cuda[index] = 0.0;   \n+        }\n+    }\n+    // printf(\"generate_random2 OK \\n\");\n+    __syncthreads();\n+}\n+\n+__global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n+{\n+    // printf(\"GetBodyRotationMatrix OK \\n\");\n+    double Roll = xyzrpy_goal[3];\n+    double Pitch = xyzrpy_goal[4];\n+    double Yaw = xyzrpy_goal[5];\n+\n+    double R_yaw[9];\n+    R_yaw[0] = cos(Yaw);\n+    R_yaw[1] = -sin(Yaw);\n+    R_yaw[2] = 0.0;\n+    R_yaw[3] = sin(Yaw);\n+    R_yaw[4] = cos(Yaw);\n+    R_yaw[5] = 0.0;\n+    R_yaw[6] = 0.0;\n+    R_yaw[7] = 0.0;\n+    R_yaw[8] = 1.0;\n+\n+    double R_pitch[9];\n+    R_pitch[0] = cos(Pitch);\n+    R_pitch[1] = 0.0;\n+    R_pitch[2] = sin(Pitch);\n+    R_pitch[3] = 0.0;\n+    R_pitch[4] = 1.0;\n+    R_pitch[5] = 0.0;\n+    R_pitch[6] = -sin(Pitch);\n+    R_pitch[7] = 0.0;\n+    R_pitch[8] = cos(Pitch);\n+\n+    double R_roll[9];\n+    R_roll[0] = 1.0;\n+    R_roll[1] = 0.0;\n+    R_roll[2] = 0.0;\n+    R_roll[3] = 0.0;\n+    R_roll[4] = cos(Roll);\n+    R_roll[5] = -sin(Roll);\n+    R_roll[6] = 0.0;\n+    R_roll[7] = sin(Roll);\n+    R_roll[8] = cos(Roll);\n+    \n+    double tmp_mat3x3[9];\n+    matrixMultiply_3x3(R_yaw, R_pitch, tmp_mat3x3);\n+    matrixMultiply_3x3(tmp_mat3x3, R_roll, RGyro);\n+}\n+\n+__global__ void prev_computeForwardKinematics(double* FK_a, double* FK_d, double* FK_alpha, double* prev_q, double* position_EE, double* orientation_EE) \n+{\n+    double transformationMatrix[16];\n+    double transformationMatrix2[16];\n+    double tempMatrix[16];\n+    double tempMatrix2[16];\n+    \n+    computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], prev_q[0], transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], prev_q[1], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], prev_q[2], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], prev_q[3], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], prev_q[4], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], prev_q[5], tempMatrix);\n+    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+    computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], prev_q[6], tempMatrix2);\n+    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+    // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n+    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n+    // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n+    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n+    position_EE[0] = transformationMatrix[3];\n+    position_EE[1] = transformationMatrix[7];\n+    position_EE[2] = transformationMatrix[11];\n+    //rpy\n+    double tempVec[3];\n+    rpy_from_transformationmatrix(transformationMatrix, tempVec);\n+    orientation_EE[0] = tempVec[0];\n+    orientation_EE[1] = tempVec[1];\n+    orientation_EE[2] = tempVec[2];\n+    // printf(\"prev_computeForwardKinematics OK \\n\");\n+}\n+\n+__global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n+{\n+    // printf(\"computeForwardKinematics OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    // int index3 = index % (_time_window*7);\n+    // int joint_num = index3 / _time_window;\n+    // 각 변환 행렬 계산\n+\n+    if(index < _sampling_num)\n+    {\n+        for(int i = 0; i<_time_window; i++)\n+        {\n+            double transformationMatrix[16];\n+            double transformationMatrix2[16];\n+\n+            double tempMatrix[16];\n+            double tempMatrix2[16];\n+            double man_6x6[36];\n+\n+            double p0[3];\n+            double p1[3];\n+            double p2[3];\n+            double p3[3];\n+            double p4[3];\n+            double p5[3];\n+            double p6[3];\n+\n+            double z0[3];\n+            double z1[3];\n+            double z2[3];\n+            double z3[3];\n+            double z4[3];\n+            double z5[3];\n+            double z6[3];\n+\n+            double t0[3];\n+            double t1[3];\n+            double t2[3];\n+            double t3[3];\n+            double t4[3];\n+            double t5[3];\n+\n+            p0[0] = 0.0;\n+            p0[1] = 0.0;\n+            p0[2] = FK_d[0];\n+\n+            z0[0] = 0.0;\n+            z0[1] = 0.0;\n+            z0[2] = 1.0;      \n+            \n+            computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], jointAngles[index*_time_window*_JDOF+i], transformationMatrix);\n+\n+            computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], jointAngles[index*_time_window*_JDOF+_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p1[0] = transformationMatrix2[3];\n+            p1[1] = transformationMatrix2[7];\n+            p1[2] = transformationMatrix2[11];\n+            z1[0] = transformationMatrix2[2];\n+            z1[1] = transformationMatrix2[6];\n+            z1[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], jointAngles[index*_time_window*_JDOF+2*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p2[0] = transformationMatrix[3];\n+            p2[1] = transformationMatrix[7];\n+            p2[2] = transformationMatrix[11];\n+            z2[0] = transformationMatrix[2];\n+            z2[1] = transformationMatrix[6];\n+            z2[2] = transformationMatrix[10];\n+\n+            computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], jointAngles[index*_time_window*_JDOF+3*_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p3[0] = transformationMatrix2[3];\n+            p3[1] = transformationMatrix2[7];\n+            p3[2] = transformationMatrix2[11];\n+            z3[0] = transformationMatrix2[2];\n+            z3[1] = transformationMatrix2[6];\n+            z3[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], jointAngles[index*_time_window*_JDOF+4*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p4[0] = transformationMatrix[3];\n+            p4[1] = transformationMatrix[7];\n+            p4[2] = transformationMatrix[11];\n+            z4[0] = transformationMatrix[2];\n+            z4[1] = transformationMatrix[6];\n+            z4[2] = transformationMatrix[10];\n+\n+            computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], jointAngles[index*_time_window*_JDOF+5*_time_window+i], tempMatrix);\n+            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n+            p5[0] = transformationMatrix2[3];\n+            p5[1] = transformationMatrix2[7];\n+            p5[2] = transformationMatrix2[11];\n+            z5[0] = transformationMatrix2[2];\n+            z5[1] = transformationMatrix2[6];\n+            z5[2] = transformationMatrix2[10];\n+\n+            computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], jointAngles[index*_time_window*_JDOF+6*_time_window+i], tempMatrix2);\n+            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+            p6[0] = transformationMatrix[3];\n+            p6[1] = transformationMatrix[7];\n+            p6[2] = transformationMatrix[11];\n+            z6[0] = transformationMatrix[2];\n+            z6[1] = transformationMatrix[6];\n+            z6[2] = transformationMatrix[10];\n+\n+            t0[0] =  p6[0]-p0[0];\n+            t0[1] =  p6[1]-p0[1];\n+            t0[2] =  p6[2]-p0[2];\n+\n+            t1[0] =  p6[0]-p1[0];\n+            t1[1] =  p6[1]-p1[1];\n+            t1[2] =  p6[2]-p1[2];\n+\n+            t2[0] =  p6[0]-p2[0];\n+            t2[1] =  p6[1]-p2[1];\n+            t2[2] =  p6[2]-p2[2];\n+\n+            t3[0] =  p6[0]-p3[0];\n+            t3[1] =  p6[1]-p3[1];\n+            t3[2] =  p6[2]-p3[2];\n+\n+            t4[0] =  p6[0]-p4[0];\n+            t4[1] =  p6[1]-p4[1];\n+            t4[2] =  p6[2]-p4[2];\n+\n+            t5[0] =  p6[0]-p5[0];\n+            t5[1] =  p6[1]-p5[1];\n+            t5[2] =  p6[2]-p5[2];            \n+\n+            jacobian_matrix[index*_time_window*42+i*42+0] = z0[1]*t0[2]-z0[2]*t0[1];\n+            jacobian_matrix[index*_time_window*42+i*42+7] = z0[2]*t0[0]-z0[0]*t0[2];\n+            jacobian_matrix[index*_time_window*42+i*42+14] = z0[0]*t0[1]-z0[1]*t0[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+1] = z1[1]*t1[2]-z1[2]*t1[1];\n+            jacobian_matrix[index*_time_window*42+i*42+8] = z1[2]*t1[0]-z1[0]*t1[2];\n+            jacobian_matrix[index*_time_window*42+i*42+15] = z1[0]*t1[1]-z1[1]*t1[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+2] = z2[1]*t2[2]-z2[2]*t2[1];\n+            jacobian_matrix[index*_time_window*42+i*42+9] = z2[2]*t2[0]-z2[0]*t2[2];\n+            jacobian_matrix[index*_time_window*42+i*42+16] = z2[0]*t2[1]-z2[1]*t2[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+3] = z3[1]*t3[2]-z3[2]*t3[1];\n+            jacobian_matrix[index*_time_window*42+i*42+10] = z3[2]*t3[0]-z3[0]*t3[2];\n+            jacobian_matrix[index*_time_window*42+i*42+17] = z3[0]*t3[1]-z3[1]*t3[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+4] = z4[1]*t4[2]-z4[2]*t4[1];\n+            jacobian_matrix[index*_time_window*42+i*42+11] = z4[2]*t4[0]-z4[0]*t4[2];\n+            jacobian_matrix[index*_time_window*42+i*42+18] = z4[0]*t4[1]-z4[1]*t4[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+5] = z5[1]*t5[2]-z5[2]*t5[1];\n+            jacobian_matrix[index*_time_window*42+i*42+12] = z5[2]*t5[0]-z5[0]*t5[2];\n+            jacobian_matrix[index*_time_window*42+i*42+19] = z5[0]*t5[1]-z5[1]*t5[0];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+6] = 0.0;\n+            jacobian_matrix[index*_time_window*42+i*42+13] = 0.0;\n+            jacobian_matrix[index*_time_window*42+i*42+20] = 0.0;\n+\n+            jacobian_matrix[index*_time_window*42+i*42+21] = z0[0];\n+            jacobian_matrix[index*_time_window*42+i*42+28] = z0[1];\n+            jacobian_matrix[index*_time_window*42+i*42+35] = z0[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+22] = z1[0];\n+            jacobian_matrix[index*_time_window*42+i*42+29] = z1[1];\n+            jacobian_matrix[index*_time_window*42+i*42+36] = z1[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+23] = z2[0];\n+            jacobian_matrix[index*_time_window*42+i*42+30] = z2[1];\n+            jacobian_matrix[index*_time_window*42+i*42+37] = z2[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+24] = z3[0];\n+            jacobian_matrix[index*_time_window*42+i*42+31] = z3[1];\n+            jacobian_matrix[index*_time_window*42+i*42+38] = z3[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+25] = z4[0];\n+            jacobian_matrix[index*_time_window*42+i*42+32] = z4[1];\n+            jacobian_matrix[index*_time_window*42+i*42+39] = z4[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+26] = z5[0];\n+            jacobian_matrix[index*_time_window*42+i*42+33] = z5[1];\n+            jacobian_matrix[index*_time_window*42+i*42+40] = z5[2];\n+\n+            jacobian_matrix[index*_time_window*42+i*42+27] = z6[0];\n+            jacobian_matrix[index*_time_window*42+i*42+34] = z6[1];\n+            jacobian_matrix[index*_time_window*42+i*42+41] = z6[2];\n+            \n+            for(int l = 0; l<6; l++)\n+            {\n+                for(int j = 0; j<6; j++)\n+                {\n+                    man_6x6[l*6+j] = 0.0;\n+                    for(int k = 0; k<7; k++)\n+                    {\n+                        man_6x6[l*6+j] = man_6x6[l*6+j] + (jacobian_matrix[index*_time_window*42+i*42+l*7+k] * jacobian_matrix[index*_time_window*42+i*42+j*7+k]);\n+                    }                \n+                }\n+            }\n+            determinant_6x6(man_6x6,_manipulability[index*_time_window+i]);\n+            // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n+            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+\n+            // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n+            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9] = transformationMatrix[0];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+1] = transformationMatrix[1];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+2] = transformationMatrix[2];\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9+3] = transformationMatrix[4];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+4] = transformationMatrix[5];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+5] = transformationMatrix[6];\n+\n+            transformationMatrix_3x3[index*_time_window*9+i*9+6] = transformationMatrix[8];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+7] = transformationMatrix[9];\n+            transformationMatrix_3x3[index*_time_window*9+i*9+8] = transformationMatrix[10];\n+\n+            position_EE[index*_time_window*3+i*3] = transformationMatrix[3];\n+            position_EE[index*_time_window*3+i*3+1] = transformationMatrix[7];\n+            position_EE[index*_time_window*3+i*3+2] = transformationMatrix[11];\n+\n+            //rpy\n+            double tempVec[3];\n+            rpy_from_transformationmatrix(transformationMatrix, tempVec);\n+            orientation_EE[index*_time_window*3+i*3] = tempVec[0];\n+            orientation_EE[index*_time_window*3+i*3+1] = tempVec[1];\n+            orientation_EE[index*_time_window*3+i*3+2] = tempVec[2];\n+            \n+            if(i == 0)\n+            {\n+                velocity_EE[index*_time_window*3+i*3] = (transformationMatrix[3] - prev_x[0]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - prev_x[1]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - prev_x[2]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3] = (tempVec[0] - prev_r[0]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - prev_r[1]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - prev_r[2]) / _dt_cuda;\n+            }\n+            else\n+            {\n+                velocity_EE[index*_time_window*3+i*3+0] = (transformationMatrix[3] - position_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - position_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n+                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - position_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+0] = (tempVec[0] - orientation_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - orientation_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n+                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - orientation_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n+            }            \n+        }    \n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) \n+{\n+    // printf(\"forwardPropagation OK \\n\");\n+    int tid = threadIdx.x + blockIdx.x * blockDim.x;\n+    \n+    double hidden0[_nodes_cuda];\n+    double hidden1[_nodes_cuda];\n+    \n+    if (tid < _sampling_num) {\n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            hidden0[j] = 0.0;\n+        }\n+    \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            hidden1[j] = 0.0;\n+        }\n+        \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            for (int i = 0; i < _JDOF; i++) {\n+                hidden0[j] += inputs[tid * _JDOF + i] * weights0[i * _nodes_cuda + j];\n+            }\n+            \n+            hidden0[j] += weights1[j];\n+            \n+            if (hidden0[j] <= 0) {\n+                hidden0[j] = 0.0;\n+            }\n+        }\n+        \n+        for (int j = 0; j < _nodes_cuda; j++) {\n+            for (int i = 0; i < _nodes_cuda; i++) {\n+                hidden1[j] += hidden0[i] * weights2[i * _nodes_cuda + j];\n+            }\n+            \n+            hidden1[j] += weights3[j];\n+            \n+            if (hidden1[j] <= 0) {\n+                hidden1[j] = 0.0;\n+            }\n+        }\n+    \n+        double output1 = 0.0;\n+    \n+        for (int i = 0; i < _nodes_cuda; i++) {\n+            output1 += hidden1[i] * weights4[i];\n+        }\n+    \n+        output1 += weights5[0];\n+        output1 = sigmoid(output1);\n+    \n+        outputs[tid] = output1;\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n+{\n+    // printf(\"calculate_inputs OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+\n+    if (index < _JDOF * _sampling_num)\n+    {\n+        inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n+\n+        if (inputs[index] > 1)\n+        {\n+            inputs[index] = 1;\n+        }\n+        else if (inputs[index] < -1)\n+        {\n+            inputs[index] = -1;\n+        }\n+    }\n+    __syncthreads();\n+}\n+\n+__global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n+{\n+    // printf(\"if_find_solution OK \\n\");\n+    int index = threadIdx.x + blockIdx.x * blockDim.x;\n+    if(index < _sampling_num)\n+    {\n+        for(int i = 0; i<_time_window; i++)\n+        {\n+            double tmp_p = 0.0;\n+            tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n+            tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n+            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n+\n+            double rotation_EE_index[9];\n+            for(int j = 0; j<9; j++)\n+            {\n+                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n+            }\n+\n+            double RotGoalT_x_RotEE[9];\n+            double RotGap[3];\n+\n+            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n+            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n+\n+            double tmp_p2 = 0.0;\n+            tmp_p2 = abs_cuda1(RotGap[0]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n+            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n+\n+            find_sol[index] = 0;\n+            if(tmp_p <= 0.03);// && tmp_p2 <= 0.2)\n+            {\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n+                    {\n+                        break;\n+                    }\n+                    else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n+                    {\n+                        break;\n+                    }\n+                    else\n+                    {\n+                        find_sol[index] = 1;\n+                        // break;\n+                    }\n+                }\n+                if(find_sol[index] == 1)\n+                {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n+{ \n+    // cout<<\"cuda code start\"<<endl;\n+    // _dt_cuda2[0] = 0.5;\n+    // for(int i = 0; i<6; i++)\n+    // {\n+    //     cout<<_goal_pos_cuda[i]<<endl;    \n+    // }\n+    \n+    prev_x_cost = 0.0;\n+    now_pos_gap[0] = 0.0;\n+    now_pos_gap_all[0] = 0.0;\n+    for(int i = 0; i<3; i++)\n+    {\n+        now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n+        now_pos_gap_all[0] = now_pos_gap_all[0] + now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n+    }\n+    // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n+    // {\n+    //     _dt_cuda2[0] = now_pos_gap[0];\n+    // }\n+    ////////////////////////////////////////////////////////////////\n+    // if(found_goal == 1)\n+    // {\n+    //     if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n+    //     {\n+    //         // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+    //         _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+    //     }\n+    //     else if(now_pos_gap[0] <= position_sec2[0])\n+    //     {\n+    //         _dt_cuda2[0] = _dt_cuda;\n+    //     }\n+    //     else if(now_pos_gap[0] >= 1.0)\n+    //     {\n+    //         _dt_cuda2[0] = 0.7;\n+    //     }\n+    // }\n+    // else\n+    // {\n+    //     _dt_cuda2[0] = 0.7;\n+    // }\n+    // found_goal = 0;\n+    // if(_dt_cuda2[0] != 0.7)\n+    // {\n+    //     // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+    // }\n+    //////////////////////////////////////////////////////////////\n+    _sol_cost = _sol_cost / 5000;\n+    // 200/\n+\n+    if(_sol_cost > 700)\n+    {\n+        _dt_cuda2[0] = 0.5;\n+    }\n+    else if(_sol_cost <= 700 && _sol_cost > 1)\n+    {\n+        _dt_cuda2[0] = -1 * ((0.5-_dt_cuda) / pow(1-700,2))*pow(_sol_cost-700,2)+0.5;\n+            //     _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n+            // _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n+        // _dt_cuda2[0] = 0.003;\n+    }\n+    else\n+    {\n+        _dt_cuda2[0] = _dt_cuda;\n+    }\n+    // cout<<\"_sol_cost : \"<<_sol_cost<<endl;\n+    // cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n+\n+    reset_check = 0;\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n+        {            \n+            reset_check = 1;\n+            break;\n+        }\n+    }\n+    if(reset_check == 1)\n+    {\n+        for(int i = 0; i<_JDOF; i++)\n+        {        \n+            _q_des[i] = _init_pos[i];\n+            _qdot_des[i] = _init_vel[i];\n+            _A[i] = 0.0;\n+        }\n+    }\n+    // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n+    \n+    dim3 blockDim(N/_time_window, 1, 1);\n+    dim3 gridDim(_time_window, 1, 1);\n+    dim3 gridDim2(_sampling_num, 1);\n+    dim3 blockDim2(1, 1);\n+    dim3 blockSize(1, 1);\n+    dim3 gridSize(1, 1);\n+    dim3 blockSize2(1, 1);\n+    dim3 gridSize2(_sampling_num * _time_window, 1);\n+\n+    if(control_mode == 0)\n+    {\n+        cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n+        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        for(int i = 0; i<N; i++)\n+        {\n+            int index222 = i / _time_window;\n+            if((i%_time_window) != 0)\n+            {\n+                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n+            }\n+        }\n+\n+        // _dt_cuda2\n+        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n+        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n+        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        \n+        for(int i = 0; i<N; i++)\n+        {\n+            if((i%_time_window) != 0)\n+            {\n+                d[i] = d[i-1] + d[i];\n+                e[i] = e[i-1] + d[i] * _dt_cuda;\n+            }\n+        }\n+\n+        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_q_goal, _goal_pos_cuda, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cost_function_joint_control <<< gridDim, blockDim>>> (dev_d, dev_e, dev_cost, dev_q_goal, dev_position_sec1, dev_position_sec2, dev_velocity_lim, dev__matrix_for_cuda, dev__prev_matrix_for_cuda, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost);\n+        \n+        cudaMemcpy(f, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n+        // cudaDeviceSynchronize();\n+\n+        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        \n+        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();    \n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _return_cost[i] = 0.0;\n+            for(int j = 0; j<_JDOF; j++)\n+            {\n+                for(int k = 0; k<_time_window; k++)\n+                {\n+                    _return_cost[i] = _return_cost[i] + f[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                }\n+            }\n+            if(outputs[i] > 0.5)\n+            {\n+                _return_cost[i] = _return_cost[i] + outputs[i] * pow(10,6);\n+            }\n+            _return_cost[i] = _return_cost[i] / _JDOF;\n+        }\n+\n+        _min_cost = 1000000000000000.0;\n+        weight_sum = 0.0;\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _return_cost[i];\n+            if(_min_cost > _cost[i])\n+            {\n+                _min_cost = _cost[i];\n+            }\n+        }\n+        memset(_weighted_A, 0, _JDOF * sizeof(double));\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _cost[i] - _min_cost;\n+            if(_cost[i]<100)\n+            {\n+                _cost[i] = exp(-_cost[i]);\t\t\n+                weight_sum = weight_sum + _cost[i];\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n+                }\n+            }\n+        }\n+        for(int j = 0; j<_JDOF; j++)\n+        {\n+            _weighted_A[j] /=  weight_sum;\n+            _A[j] = _weighted_A[j];\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n+        }\n+        \n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i];\n+            returnArray[_JDOF+i] = _qdot_des[i] + (_weighted_A[i] * _dt_cuda);\n+            returnArray[i] = _q_des[i] + (_qdot_des[i] * _dt_cuda);\n+\n+            _q_des[i] = returnArray[i];\n+            _qdot_des[i] = returnArray[_JDOF+i];\n+        }\n+    }\n+\n+    else if(control_mode == 1)\n+    {\n+        // for(int i= 0; i<7; i++)\n+        // {\n+        //     cout<<\"_A[\"<<i<<\"] : \"<<_A[i]<<endl;\n+        // }\n+        \n+        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n+        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        for(int i = 0; i<N; i++)\n+        {\n+            int index222 = i / _time_window;\n+            if((i%_time_window) != 0)\n+            {   \n+                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n+                if((i%_time_window) >= _time_window-_dt2_window)\n+                {\n+                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n+                }                \n+            }\n+            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n+        }\n+\n+        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev__matrix_for_cuda, _matrix_for_cuda, N*sizeof(double), cudaMemcpyHostToDevice);\n+        \n+        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n+        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n+        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n+\n+        cudaDeviceSynchronize();\n+        for(int i = 0; i<N; i++)\n+        {\n+            if((i%_time_window) != 0)\n+            {\n+                if((i%_time_window) >= _time_window-_dt2_window)\n+                {\n+                    d[i] = d[i-1] + d[i];\n+                    e[i] = e[i-1] + d[i] * _dt_cuda2[0];\n+                }\n+                else\n+                {\n+                    d[i] = d[i-1] + d[i];\n+                    e[i] = e[i-1] + d[i] * _dt_cuda;\n+                }\n+            }\n+        }\n+\n+        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaDeviceSynchronize();\n+\n+        // cout<<\"222222222222222222222222\"<<endl;\n+        // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaDeviceSynchronize();\n+        // for(int k = 0 ;k <_sampling_num; k++)\n+        // {\n+        //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n+        //     for(int i = 0; i<42; i++)\n+        //     {\n+        //         if(i%7 == 6)\n+        //         {\n+        //             cout<<jacobian[i+42*k]<<endl;    \n+        //         }\n+        //         else\n+        //         {\n+        //             cout<<jacobian[i+42*k]<<\" \";\n+        //         }            \n+        //     }\n+        // }        \n+        \n+        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n+        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+\n+\n+        // cout<<\"CUDA manipulability\"<<endl;\n+        // for(int i = 0; i<N/_JDOF; i++)\n+        // {\n+        //     cout<<\"manipulability ith : \"<<i<<manipulability[i]<<endl;\n+        // }\n+        cudaMemcpy(dev_FK_a, FK_a, 9*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n+        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n+        cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n+\n+        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n+        cudaDeviceSynchronize();\n+        \n+        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n+\n+        cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n+        // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n+        Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n+\n+        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n+        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaMemcpy(dev_now_pos_gap_all, now_pos_gap_all, sizeof(double), cudaMemcpyHostToDevice);        \n+        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap_all);\n+        cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        \n+\n+        // cudaMemcpy(dev_alpha, alpha, sizeof(double), cudaMemcpyHostToDevice);\n+        // cudaMemcpy(dev_beta, beta, sizeof(double), cudaMemcpyHostToDevice);\n+        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n+        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+        // for(int i = 0; i<_sampling_num * _time_window; i++)\n+        // {\n+        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n+        // }\n+\n+        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n+\n+        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n+        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n+        // {\n+        //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n+        // }\n+        cudaDeviceSynchronize();\n+\n+        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n+        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n+        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n+        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n+        cudaDeviceSynchronize();\n+\n+        // for(int i = 0; i<_sampling_num; i++)\n+        // {\n+        //     if(outputs[i]>0.5)\n+        //     {\n+        //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n+        //     }\n+        // }\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _return_cost[i] = 0.0;\n+            for(int j = 0; j<_JDOF; j++)\n+            {\n+                for(int k = 0; k<_time_window; k++)\n+                {\n+                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n+                }\n+                // if(j == _JDOF-1)\n+                // {\n+                //     _return_cost[i] = _return_cost[i] / _JDOF;\n+                // }\n+            }\n+            // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n+\n+            for(int j = 0 ; j<_time_window; j++)\n+            {\n+                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n+            }\n+            if(found_goal_list[i] == 1)\n+            {\n+                if(outputs[i] >= 0.5)\n+                {\n+                    found_goal_list[i] = 0;\n+                }\n+            }\n+            if(outputs[i] > 0.5)\n+            {\n+                _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n+            }\n+            _return_cost[i] = _return_cost[i] / _JDOF;\n+            // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n+            if(found_goal_list[i] == 1)\n+            {\n+                found_goal = 1;\n+                // cout<<\"??\"<<endl;\n+                // _return_cost[i] = _return_cost[i];\n+            }\n+            // else\n+            // {\n+            //     _return_cost[i] = _return_cost[i] + 100.0;\n+            // }\n+        }\n+\n+        _min_cost = 1000000000000000.0;\n+        weight_sum = 0.0;\n+        // _sol_cost = 0.0;\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _return_cost[i];\n+            if(_min_cost > _cost[i])\n+            {\n+                _min_cost = _cost[i];\n+            }\n+        }\n+        _sol_cost = _min_cost;\n+        memset(_weighted_A, 0, _JDOF * sizeof(double));\n+\n+        for(int i = 0; i<_sampling_num; i++)\n+        {\n+            _cost[i] = _cost[i] - _min_cost;\n+            if(_cost[i]<100)\n+            {\n+                _cost[i] = exp(-_cost[i]);\t\t\n+                weight_sum = weight_sum + _cost[i];\n+                for(int j = 0; j<_JDOF; j++)\n+                {\n+                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n+                }\n+            }\n+        }\n+        for(int j = 0; j<_JDOF; j++)\n+        {\n+            _weighted_A[j] /=  weight_sum;\n+            _A[j] = _weighted_A[j];\n+            // if(_A[j] > 10.0)\n+            // {\n+            //     _A[j] = 10.0;\n+            // }\n+            // else if(_A[j] < -10.0)\n+            // {\n+            //     _A[j] = -10.0;\n+            // }\n+        }\n+\n+        // for(int i = 0; i<_JDOF; i++)\n+        // {\n+        //     cout<<_weighted_A[i]<<endl;    \n+        // }\n+        \n+        for(int i = 0; i<_JDOF; i++)\n+        {\n+            returnArray[(_JDOF*2)+i] = _weighted_A[i] ;//* (1+_dt_cuda2[0]-_dt_cuda);\n+            returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n+            returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n+\n+            _q_des[i] = returnArray[i];\n+            _qdot_des[i] = returnArray[_JDOF+i];\n+        }\n+    }\n+}\n+\n+void CudaTest::load_weight()\n+{\n+    ostringstream filename_NN[6];\n+    ifstream weight0;\n+    #if _nodes_cuda == 32\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n+        }\n+    }\n+    #elif _nodes_cuda == 64\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n+        } \n+    }\n+    #elif _nodes_cuda == 100\n+    {\n+        for(int i = 0; i<6; i++)\n+        {\n+            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n+        } \n+    }\n+    #else\n+    #endif\n+    \n+    weight0.open(filename_NN[0].str());\n+    for(int i = 0; i<_JDOF ; i++)\n+    {\n+        for(int j = 0; j<_nodes_cuda ; j++)\n+        {\n+            weight0 >> weights0[i*_nodes_cuda + j];\n+        }\n+    }\n+    weight0.close();\n+    \n+    weight0.open(filename_NN[1].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights1[i];\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[2].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        for(int j = 0; j<_nodes_cuda ; j++)\n+        {\n+            weight0 >> weights2[i*_nodes_cuda + j];\n+        }\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[3].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights3[i];\n+    }\n+    weight0.close();\n+\n+    weight0.open(filename_NN[4].str());\n+    for(int i = 0; i<_nodes_cuda ; i++)\n+    {\n+        weight0 >> weights4[i];\n+    }\n+    weight0.close();\n+    weight0.open(filename_NN[5].str());\n+    weight0 >> weights5[0];\n+    weight0.close();\n+}\n+\n+void CudaTest::cpu_memory_save()\n+{\n+    // cout<<\":::::::::::::CUDA <CPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    memset(cost_jointlimit, 0, N * sizeof(double));\n+    memset(_mean_matrix, 0, N * sizeof(double));\n+    memset(d, 0, N * sizeof(double));\n+    memset(e, 0, N * sizeof(double));\n+    memset(f, 0, N * sizeof(double));\n+    memset(_matrix_for_cuda, 0, N * sizeof(double));\n+\n+    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    memset(FK_d, 0, 9 * sizeof(double));\n+    memset(FK_a, 0, 9 * sizeof(double));\n+    memset(FK_alpha, 0, 9 * sizeof(double));\n+    \n+    memset(_return_cost, 0, _sampling_num * sizeof(double));\n+    memset(_cost, 0, _sampling_num * sizeof(double));\n+\n+    memset(_max_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_min_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_q_des, 0, _JDOF * sizeof(double));\n+    memset(_qdot_des, 0, _JDOF * sizeof(double));\n+    memset(_A, 0, _JDOF * sizeof(double));\n+    memset(_weighted_A, 0, _JDOF * sizeof(double));\n+    memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n+    memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n+    \n+    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n+    memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n+    memset(weights1, 0, _nodes_cuda * sizeof(double));\n+    memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n+    memset(weights3, 0, _nodes_cuda * sizeof(double));\n+    memset(weights4, 0, _nodes_cuda * sizeof(double));\n+    // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n+    memset(outputs, 0, _sampling_num * sizeof(double));\n+    memset(returnArray, 0, _JDOF*3 * sizeof(double));\n+\n+    memset(_prev_x, 0, 3 * sizeof(double));\n+    memset(_prev_r, 0, 3 * sizeof(double));\n+\n+    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n+    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n+\n+    \n+    weights5[0] = 0.0;\n+    position_sec1[0] = 0.0;\n+    position_sec2[0] = 0.0;\n+    velocity_lim[0] = 0.0;\n+}\n+\n+void CudaTest::cuda_memory_save()\n+{\n+    // cout<<\":::::::::::::CUDA <GPU> Memory Save:::::::::::::\"<<endl<<endl;\n+    cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n+    cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n+    // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n+    cudaMalloc((void**)&dev_states, N*sizeof(double));\n+\n+    // cudaMalloc((void**)&dev_a, N * sizeof(double));\n+    cudaMalloc((void**)&dev_b, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_c, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_d, N * sizeof(double));\n+    cudaMalloc((void**)&dev_e, N * sizeof(double));\n+    cudaMalloc((void**)&dev_cost, N * sizeof(double));\n+    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n+    cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n+    cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n+    cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n+\n+    cudaMalloc((void**)&d_weights0, _JDOF * _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights1, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n+    cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n+    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n+\n+    cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n+    cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n+    cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n+    cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n+\n+    // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n+    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n+    cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n+    cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n+    cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n+    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n+    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n+    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double));\n+    cudaMalloc((void**)&dev_now_pos_gap_all, sizeof(double));\n+    cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n+    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n+\n+    cudaMalloc((void**)&dev_alpha, sizeof(double));\n+    cudaMalloc((void**)&dev_beta, sizeof(double));   \n+}\n+\n+void CudaTest::cuda_memory_free()\n+{    \n+    // cout<<\":::::::::::::CUDA Memory Free:::::::::::::\"<<endl<<endl;\n+    cudaFree(dev__A);\n+    cudaFree(dev__mean_matrix);\n+    cudaFree(dev__matrix_for_cuda);\n+    // cudaFree(dev__prev_matrix_for_cuda);\n+    cudaFree(dev_states);\n+\n+    cudaFree(dev_b);\n+    cudaFree(dev_c);\n+    cudaFree(dev_d);\n+    cudaFree(dev_e);\n+    cudaFree(dev_cost);\n+    cudaFree(dev_cost_x);\n+    \n+    cudaFree(dev_q_goal);\n+    cudaFree(dev_x_goal);\n+    cudaFree(dev_rot_goal);\n+    cudaFree(dev_rot_goal_T);\n+\n+    cudaFree(d_weights0);\n+    cudaFree(d_weights1);\n+    cudaFree(d_weights2);\n+    cudaFree(d_weights3);\n+    cudaFree(d_weights4);\n+    cudaFree(d_weights5);\n+    cudaFree(d_outputs);\n+\n+    cudaFree(hidden0);\n+    cudaFree(hidden1);\n+\n+    cudaFree(dev_inputs);\n+    cudaFree(dev_min_joint_position_for_NN);\n+    cudaFree(dev_max_joint_position_for_NN);\n+\n+    cudaFree(dev_joint_min_limit_for_cost);\n+    cudaFree(dev_joint_max_limit_for_cost);\n+    cudaFree(dev_cen_joint_position);\n+\n+    cudaFree(dev_position_sec1);\n+    cudaFree(dev_position_sec2);\n+    cudaFree(dev_velocity_lim);\n+\n+    // cudaFree(_dev_jacobian);\n+    cudaFree(dev_position_EE);\n+    cudaFree(dev_orientation_EE);\n+\n+    cudaFree(dev_FK_a);\n+    cudaFree(dev_FK_d);\n+    cudaFree(dev_FK_alpha);\n+\n+    cudaFree(dev_jacobian);\n+    cudaFree(dev_jacobian_transpose);\n+\n+    cudaFree(dev_alpha);\n+    cudaFree(dev_beta);\n+\n+    cudaError_t error = cudaGetLastError();\n+    if (error != cudaSuccess) {\n+        printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n+        // 에러 처리 로직을 추가해야 합니다.\n+    }\n+}\n+\n+void CudaTest::initialize()\n+{\n+    // cout<<endl;\n+    // cout<<\":::::::::::::CUDA Initialize:::::::::::::\"<<endl<<endl;\n+    // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n+    // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n+    // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n+\n+    // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n+    _sol_cost = 0.0;\n+\n+    position_sec1[0] = 0.03125;\n+    position_sec2[0] = 0.005;\n+    velocity_lim[0] = 0.4;\n+\n+    // position_sec1[0] = 0.03125;\n+    // position_sec2[0] = 0.00625;\n+    // velocity_lim[0] = 1.0;\n+\t\n+    // numBlocks = N / THREADS_PER_BLOCK;\n+    // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n+\n+\n+    // panda_arm_hand.urdf // panda_arm_hand.xml model\n+\t// _min_joint_position[0] = -2.9671;\n+\t// _min_joint_position[1] = -1.8326;\n+\t// _min_joint_position[2] = -2.9671;\n+\t// _min_joint_position[3] = -3.1416;\n+\t// _min_joint_position[4] = -2.9671;\n+\t// _min_joint_position[5] = -0.0873;\n+\t// _min_joint_position[6] = -2.9671;\n+\n+\t// _max_joint_position[0] = 2.9671;\n+\t// _max_joint_position[1] = 1.8326;\n+\t// _max_joint_position[2] = 2.9671;\n+\t// _max_joint_position[3] = 0.0;\n+\t// _max_joint_position[4] = 2.9671;\n+\t// _max_joint_position[5] = 3.8223;\n+\t// _max_joint_position[6] = 2.9671;\n+\n+\n+\n+    // fr3.urdf // fr3.xml model\n+    _min_joint_position[0] = -2.8973;\n+\t_min_joint_position[1] = -1.7628;\n+\t_min_joint_position[2] = -2.8973;\n+\t_min_joint_position[3] = -3.0718;\n+\t_min_joint_position[4] = -2.8973;\n+\t_min_joint_position[5] = -0.0175;\n+\t_min_joint_position[6] = -2.8973;\n+\n+\t_max_joint_position[0] = 2.8973;\n+\t_max_joint_position[1] = 1.7628;\n+\t_max_joint_position[2] = 2.8973;\n+\t_max_joint_position[3] = -0.0698;\n+\t_max_joint_position[4] = 2.8973;\n+\t_max_joint_position[5] = 3.7525;\n+\t_max_joint_position[6] = 2.8973;\n+\n+\n+\n+    //k = 0.1\n+    // _hat_min_joint_position[0] = -2.37368;\n+    // _hat_max_joint_position[0] = 2.37368;\n+\n+    // _hat_min_joint_position[1] = -1.46608;\n+    // _hat_max_joint_position[1] = 1.46608;\n+\n+    // _hat_min_joint_position[2] = -2.37368;\n+    // _hat_max_joint_position[2] = 2.37368;\n+\n+    // _hat_min_joint_position[3] = −2.82744;\n+    // _hat_max_joint_position[3] = -0.31416;\n+\n+    // _hat_min_joint_position[4] = -2.37368;\n+    // _hat_max_joint_position[4] = 2.37368;\n+\n+    // _hat_min_joint_position[5] = 0.30366;\n+    // _hat_max_joint_position[5] = 3.43134;\n+\n+    // _hat_min_joint_position[6] = -2.37368;\n+    // _hat_max_joint_position[6] = 2.37368;\n+\n+\n+\n+    for(int i = 0; i<_JDOF; i++)\n+    {\n+        // _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        // _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n+        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n+    }\n+\n+    FK_a[0] = 0.0;\n+    FK_d[0] = 0.343;\n+    FK_alpha[0] = 0.0;\n+\n+    FK_a[1] = 0.0;\n+    FK_d[1] = 0.0;\n+    FK_alpha[1] = -PI_CUDA/2.0;\n+\n+    FK_a[2] = 0.0;\n+    FK_d[2] = 0.316;\n+    FK_alpha[2] = PI_CUDA/2.0;\n+\n+    FK_a[3] = 0.0825;\n+    FK_d[3] = 0.0;\n+    FK_alpha[3] = PI_CUDA/2.0;\n+\n+    FK_a[4] = -0.0825;\n+    FK_d[4] = 0.384;\n+    FK_alpha[4] = -PI_CUDA/2.0;\n+\n+    FK_a[5] = 0.0;\n+    FK_d[5] = 0.0;\n+    FK_alpha[5] = PI_CUDA/2.0;\n+\n+    FK_a[6] = 0.088;\n+    FK_d[6] = 0.0;\n+    FK_alpha[6] = PI_CUDA/2.0;\n+\n+    FK_a[7] = 0.0;\n+    FK_d[7] = 0.107;\n+    FK_alpha[7] = 0.0;\n+\n+    FK_a[8] = 0.0;\n+    FK_d[8] = 0.1034;\n+    FK_alpha[8] = 0.0;\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1689671333300,
            "name": "Commit-0",
            "content": "#include <cuda_runtime.h>\n#include <device_launch_parameters.h>\n#include \"cuda.cuh\"\n\n#define THREADS_PER_BLOCK _sampling_num\n#define THREADS_PER_BLOCK2 _sampling_num\n\n\nCudaTest::CudaTest(void)\n{   \n    cpu_memory_save();\n    cuda_memory_save();\n    load_weight();\n    initialize();\n}\n\nCudaTest::~CudaTest(void)\n{    \n    \n}\n\n__device__ double sigmoid(double x) {\n    return 1.0 / (1.0 + expf(-x));\n}\n\n__device__ double abs_cuda1(double x) {\n    if(x<0)\n    {\n        return -x;\n    }\n    else\n    {\n        return x;\n    }\n}\n\n__device__ double abs_cuda2(double x, double y) {\n    if(x-y<0)\n    {\n        return -x+y;\n    }\n    else\n    {\n        return x-y;\n    }\n}\n\n__device__ double pow2_cuda(double x) {\n    return x*x;\n}\n\n\n__device__ double norm2_vector3(double *x)\n{\n    double _norm2 = 0.0;\n    for(int i = 0; i<3; i++)\n    {\n        _norm2 = _norm2 + (x[i] * x[i]);\n    }\n    _norm2 = sqrt(_norm2);\n    return _norm2;\n}\n\n__device__ double calculateSingularValue(double* matrix) \n{\n    int row = threadIdx.y;\n    int col = threadIdx.x;\n    \n    // 3x3 행렬의 크기를 정의\n    int matrixSize = 3;\n    \n    // 행렬의 요소를 읽음\n    double element = matrix[row * matrixSize + col];\n    double singularValue = 0.0;\n    \n    // 행렬의 특잇값은 고유값의 제곱근이므로 제곱을 계산\n    element *= element;\n    \n    // 각 스레드마다 계산한 제곱된 특잇값을 공유 메모리에 저장\n    __shared__ double sharedData[9];\n    sharedData[row * matrixSize + col] = element;\n    \n    // 동기화\n    __syncthreads();\n    \n    // 공유 메모리의 값을 최대값으로 업데이트\n    if (threadIdx.x == 0 && threadIdx.y == 0) {\n        double maxVal = 0.0;\n        for (int i = 0; i < 9; i++) {\n            if (sharedData[i] > maxVal) {\n                maxVal = sharedData[i];\n            }\n        }\n        singularValue = sqrt(maxVal);\n    }\n    return singularValue;\n}\n\n__device__ void computeTransformationMatrix(double alpha, double a, double d, double theta, double* matrix) \n{\n    double cosTheta = cos(theta);\n    double sinTheta = sin(theta);\n    double cosAlpha = cos(alpha);\n    double sinAlpha = sin(alpha);\n\n    matrix[0] = cosTheta;\n    matrix[1] = -sinTheta;\n    matrix[2] = 0;\n    matrix[3] = a;\n\n    matrix[4] = sinTheta * cosAlpha;\n    matrix[5] = cosTheta * cosAlpha;\n    matrix[6] = -sinAlpha;\n    matrix[7] = -d * sinAlpha;\n\n    matrix[8] = sinTheta * sinAlpha;\n    matrix[9] = cosTheta * sinAlpha;\n    matrix[10] = cosAlpha;\n    matrix[11] = d * cosAlpha;\n    \n    matrix[12] = 0.0;\n    matrix[13] = 0.0;\n    matrix[14] = 0.0;\n    matrix[15] = 1.0;\n}\n\n__device__ void matrixMultiply_4x4(double *mat1, double *mat2, double *mat3)\n{\n    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[4] + mat1[2] * mat2[8] + mat1[3] * mat2[12];\n    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[5] + mat1[2] * mat2[9] + mat1[3] * mat2[13];\n    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[6] + mat1[2] * mat2[10] + mat1[3] * mat2[14];\n    mat3[3] = mat1[0] * mat2[3] + mat1[1] * mat2[7] + mat1[2] * mat2[11] + mat1[3] * mat2[15];\n\n    mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[4] + mat1[6] * mat2[8] + mat1[7] * mat2[12];\n    mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[5] + mat1[6] * mat2[9] + mat1[7] * mat2[13];\n    mat3[6] = mat1[4] * mat2[2] + mat1[5] * mat2[6] + mat1[6] * mat2[10] + mat1[7] * mat2[14];\n    mat3[7] = mat1[4] * mat2[3] + mat1[5] * mat2[7] + mat1[6] * mat2[11] + mat1[7] * mat2[15];\n\n    mat3[8] = mat1[8] * mat2[0] + mat1[9] * mat2[4] + mat1[10] * mat2[8] + mat1[11] * mat2[12];\n    mat3[9] = mat1[8] * mat2[1] + mat1[9] * mat2[5] + mat1[10] * mat2[9] + mat1[11] * mat2[13];\n    mat3[10] = mat1[8] * mat2[2] + mat1[9] * mat2[6] + mat1[10] * mat2[10] + mat1[11] * mat2[14];\n    mat3[11] = mat1[8] * mat2[3] + mat1[9] * mat2[7] + mat1[10] * mat2[11] + mat1[11] * mat2[15];\n\n    mat3[12] = mat1[12] * mat2[0] + mat1[13] * mat2[4] + mat1[14] * mat2[8] + mat1[15] * mat2[12];\n    mat3[13] = mat1[12] * mat2[1] + mat1[13] * mat2[5] + mat1[14] * mat2[9] + mat1[15] * mat2[13];\n    mat3[14] = mat1[12] * mat2[2] + mat1[13] * mat2[6] + mat1[14] * mat2[10] + mat1[15] * mat2[14];\n    mat3[15] = mat1[12] * mat2[3] + mat1[13] * mat2[7] + mat1[14] * mat2[11] + mat1[15] * mat2[15];\n}\n\n__device__ void matrixMultiply_3x3(double *mat1, double *mat2, double *mat3)\n{\n    mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[3] + mat1[2] * mat2[6];\n    mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[4] + mat1[2] * mat2[7];\n    mat3[2] = mat1[0] * mat2[2] + mat1[1] * mat2[5] + mat1[2] * mat2[8];\n\n    mat3[3] = mat1[3] * mat2[0] + mat1[4] * mat2[3] + mat1[5] * mat2[6];\n    mat3[4] = mat1[3] * mat2[1] + mat1[4] * mat2[4] + mat1[5] * mat2[7];\n    mat3[5] = mat1[3] * mat2[2] + mat1[4] * mat2[5] + mat1[5] * mat2[8];\n\n    mat3[6] = mat1[6] * mat2[0] + mat1[7] * mat2[3] + mat1[8] * mat2[6];\n    mat3[7] = mat1[6] * mat2[1] + mat1[7] * mat2[4] + mat1[8] * mat2[7];\n    mat3[8] = mat1[6] * mat2[2] + mat1[7] * mat2[5] + mat1[8] * mat2[8];\n}\n\n__device__ void rpy_from_transformationmatrix(double *RotMat, double *rpy)\n{\n    // rpy[1] = RotMat[8];\n    rpy[1] = -asin(RotMat[8]);\n    if(RotMat[8] > 1.0 - _threshold_cuda && RotMat[8] < 1.0 + _threshold_cuda)\n    {\n        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else if (RotMat[8] < -1.0 + _threshold_cuda && RotMat[8] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n    {//Gimbal lock, pitch = 90deg\n        rpy[0] = atan2(RotMat[1], RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else //general solution\n    {\n        rpy[0] = atan2(RotMat[9], RotMat[10]);\n        rpy[2] = atan2(RotMat[4], RotMat[0]);\n    }\n}\n\n__device__ void rpy_from_rotationmatrix(double *RotMat, double *rpy)\n{\n    // rpy[1] = RotMat[8];\n    rpy[1] = -asin(RotMat[6]);\n    if(RotMat[6] > 1.0 - _threshold_cuda && RotMat[6] < 1.0 + _threshold_cuda)\n    {\n        rpy[0] = atan2(-RotMat[1], -RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else if (RotMat[6] < -1.0 + _threshold_cuda && RotMat[6] > -1.0 - _threshold_cuda) //when RotMat(2,0) == -1\n    {//Gimbal lock, pitch = 90deg\n        rpy[0] = atan2(RotMat[1], RotMat[2]);\n        rpy[2] = 0.0;\n    }\n    else //general solution\n    {\n        rpy[0] = atan2(RotMat[7], RotMat[8]);\n        rpy[2] = atan2(RotMat[3], RotMat[0]);\n    }\n}\n\n__device__ void determinant_6x6(double *matrix, double result)\n{\n    int tid = threadIdx.x;\n    int stride = blockDim.x;\n\n    double temp[6][6];\n    for (int i = 0; i < 6; i++) {\n        for (int j = 0; j < 6; j++) {\n            temp[i][j] = matrix[i * 6 + j];\n        }\n    }\n\n    for (int k = 0; k < 6 - 1; k++) {\n        for (int i = k + 1 + tid; i < 6; i += stride) {\n            double ratio = temp[i][k] / temp[k][k];\n            for (int j = k; j < 6; j++) {\n                temp[i][j] -= ratio * temp[k][j];\n            }\n        }\n        __syncthreads();\n    }\n\n    if (tid == 0) {\n        result = 1.0;\n        for (int i = 0; i < 6; i++) {\n            result *= temp[i][i];\n        }\n    }\n}\n\n__global__ void cal_jacobian(double *theta_table, double *_jacobian)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index/_time_window;\n    int index3 = index*6*_JDOF;\n    // double theta[7];\n\n    if(index<_sampling_num )\n    {\n        \n        // for(int i = 0; i<_JDOF;)\n        // {\n        //     theta[i]= theta_table[(index*_JDOF*_time_window)+(_time_window*i)+(_time_window-1)];\n        // }\n\n        double cash = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_1 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_2 = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash_3 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        double cash0 = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        double cash0_1 = (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        double cash1 = (sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n        double cash2 = ((-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]));\n        double cash2_2 = (cash2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        double cash3 = ((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + cash*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        double cash4 = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);    \n\n        _jacobian[index3 + 0] = ((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+(((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+((-176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]))-768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-632)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n        _jacobian[index3 + 1] = (176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cash+((176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(165-176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])-165)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])+((176*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])-165)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+(176*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])+768)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])+632)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))/2000;\n        _jacobian[index3 + 2] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 3] = (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*cash;\n        _jacobian[index3 + 4] = -cash0_1*cash1 + (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]));\n        _jacobian[index3 + 5] = -cash0_1*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        _jacobian[index3 + 6] = 0.0;\n\n        _jacobian[index3 + 7] = 11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400;\n        _jacobian[index3 + 8] = (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 9] = -(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) + (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 10] =  -(sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 48*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])/125 + 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/400 + 48*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125)*cash;\n        _jacobian[index3 + 11] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*cash1 - (11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n        _jacobian[index3 + 12] = (11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*((-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) - (cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*(11*cash3*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*cash1*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125);\n        _jacobian[index3 + 13] = 0.0;\n\n        _jacobian[index3 + 14] = 0.0;\n        _jacobian[index3 + 15] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/250 + 33*cash_2/400)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]) - (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 79*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])/250 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 16] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*cash_1/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125 + 33*cash_2/400)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) + (11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 + 33*cash0/400 + 33*cash_3/400)*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 17] = (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*(11*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 + 48*sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 - 48*(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/125 - 33*(-cash_1 + cash_2)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])/400 - 33*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])/400 + 48*cash4/125);\n        _jacobian[index3 + 18] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])) + cash0_1*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4);\n        _jacobian[index3 + 19] = -(11*cash2_2*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125 + 11*(-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)])/125)*(((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)])) + cash0_1*(cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]));\n        _jacobian[index3 + 20] = 0.0;\n\n        _jacobian[index3 + 21] = 0.0;\n        _jacobian[index3 + 22] = -sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 23] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 24] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 25] = -(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4;\n        _jacobian[index3 + 26] = cash2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cash_3*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 27] = cash2_2*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(-cash_1 + cash_2)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + cash4)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n\n        _jacobian[index3 + 28] = 0.0;\n        _jacobian[index3 + 29] = cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)]);\n        _jacobian[index3 + 30] = sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 31] = cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]);\n        _jacobian[index3 + 32] = -(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n        _jacobian[index3 + 33] = ((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) + (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 34] = (((cash0 + cash_3)*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - (cash_1*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]) - cos(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - (-(cash0 + cash_3)*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]))*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n\n        _jacobian[index3 + 35] = 1.0;\n        _jacobian[index3 + 36] = 0.0;\n        _jacobian[index3 + 37] = cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]);\n        _jacobian[index3 + 38] = -cash;\n        _jacobian[index3 + 39] = sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)]) + cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]);\n        _jacobian[index3 + 40] = (-sin(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*2)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)]) + sin(theta_table[(index*_JDOF*_time_window)+(_time_window*3)+(_time_window-1)])*cos(theta_table[(index*_JDOF*_time_window)+_time_window+(_time_window-1)]))*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]) - cash*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*4)+(_time_window-1)]);\n        _jacobian[index3 + 41] = cash3*sin(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]) - cash1*cos(theta_table[(index*_JDOF*_time_window)+(_time_window*5)+(_time_window-1)]);\n    }\n    //  __syncthreads();\n}\n\n__global__ void Transpose_Matrix_3x3(double *input, double *output)\n{\n    output[0] = input[0];\n    output[1] = input[3];\n    output[2] = input[6];\n\n    output[3] = input[1];\n    output[4] = input[4];\n    output[5] = input[7];\n\n    output[6] = input[2];\n    output[7] = input[5];\n    output[8] = input[8];\n}\n\n__global__ void state_update(double *a, double *b, double *c, double *d, double *e, double *_dt_cuda2){\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index2 = index % _time_window;\n    int index3 = index % (_time_window * _JDOF);\n    int joint_num = index3 / _time_window;\n\n    if (index2 == 0)\n    {\n        d[index] = b[joint_num] + (_dt_cuda * a[index]); // 속도\n        e[index] = c[joint_num] + (_dt_cuda * d[index]); // 위치\n    }\n    else\n    {\n        if(index2 >= _time_window-_dt2_window)\n        {\n            d[index] = _dt_cuda2[0] * a[index];\n            e[index] = 0.0;\n        }\n        else\n        {\n            d[index] = _dt_cuda * a[index];\n            e[index] = 0.0;\n        }\n        \n    }\n    __syncthreads();\n}\n\n__global__ void joint_limit_cost(double *position,double *velocity, double *cost_joint_limit, double *min_joint_limit, double *max_joint_limit, double *velocity_lim, double *cen_joint_position, double *now_gap)\n{ \n    // vel pos cost goal\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index % _time_window ;\n    int index3 = index % (_time_window*7);\n    int joint_num = index3 / _time_window;\n\n    double constraint_gain = 100000.0;//pow(10,6)\n    double vel_gain = 300.0;//pow(10,6)\n    if(now_gap[0] > 1 )\n    {\n        vel_gain =  0.0;\n    }\n    else\n    {\n        vel_gain =  abs_cuda1(1-now_gap[0]) * vel_gain;\n    }\n    \n\n    cost_joint_limit[index]=0.0;\n\n    // if(index2 >= _time_window-5)\n    // {   \n        // if(now_gap[0] > 0.3)\n        // {\n        //     if(position[index] < min_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        //     }\n\n        //     else if(position[index] > max_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        //     }\n        // }\n        // else\n        // {\n        //     if(position[index] < min_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        //     }\n\n        //     else if(position[index] > max_joint_limit[joint_num])\n        //     {\n        //         cost_joint_limit[index] = 1000.0 * abs_cuda2(position[index],max_joint_limit[joint_num]);\n        //         // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        //     }\n        // }\n\n    // }\n    // else\n    // {\n        if(position[index] < min_joint_limit[joint_num])\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],min_joint_limit[joint_num]);\n        }\n\n        else if(position[index] > max_joint_limit[joint_num])\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * abs_cuda2(position[index],max_joint_limit[joint_num]);\n            // cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]) + constraint_gain * (position[index] - max_joint_limit[joint_num]) * (position[index] - max_joint_limit[joint_num]);\n        }\n        else\n        {\n            cost_joint_limit[index] = vel_gain * abs_cuda1(velocity[index]);\n        }\n        if(abs_cuda1(velocity[index]) > velocity_lim[0]) // 0.8\n        {\n            cost_joint_limit[index] = cost_joint_limit[index] + constraint_gain;\n        }\n        // if(joint_num == 1 || joint_num == 4 || joint_num == 5 || joint_num == 6)\n        // {\n        //     cost_joint_limit[index] = cost_joint_limit[index] + 1000.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        // }\n        // else\n        // {\n        //     cost_joint_limit[index] = cost_joint_limit[index] + 50.0 * pow2_cuda(abs_cuda2(cen_joint_position[joint_num] , position[index]));\n        // }        \n    // }\n    __syncthreads();\n}\n\n__global__ void cost_function_joint_control(double *d, double *e, double *f, double *g, double *position_sec1, double *position_sec2, double *velocity_lim, double *acc, double *prev_acc, double *min_joint_limit, double *max_joint_limit)\n{\n    // vel pos cost goal\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index3 = index % (_time_window*7);\n    int joint_num = index3 / _time_window;\n\n    double cost_pos =  abs_cuda2(e[index],g[joint_num]);// + pow(10,2);// * abs(_vel_state(i,j));// + abs(_acc_state(i,j));\n\tdouble cost_vel =  abs_cuda1(d[index]);\n    double cost_acc =  abs_cuda2(acc[index],prev_acc[index]);\n    double pos_gain = 10000.0;//pow(10,4)\n    double vel_gain = 100.0;//pow(10,1)\n    double constraint_gain = 10000000.0;//pow(10,6)\n\n    if(abs_cuda1(cost_pos) >  position_sec1[0])\n    {\n        f[index] = 10000.0 + pos_gain * cost_pos + vel_gain * cost_vel;// + 1.0 * cost_acc;\n        // printf(\"sec1\\n\");\n        // printf(\"sec1 : cost[%d] : %f \\n\", index,f[index]);\n        // printf(\"sec1 : pos[%d] : %f \\n\", index,e[index]);\n        // printf(\"sec1 : vel[%d] : %f \\n\", index,d[index]);\n        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n    }\n\t///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n\telse if(abs_cuda1(cost_pos) <= position_sec1[0] && abs_cuda1(cost_pos) > position_sec2[0])\n\t{\n\t\tf[index] = 1000.0 + pos_gain * cost_pos + vel_gain * cost_vel;\n        // printf(\"sec2\\n\");\n        // printf(\"sec2 : cost[%d] : %f \\n\", index,f[index]);\n        // printf(\"sec2 : pos[%d] : %f \\n\", index,e[index]);\n        // printf(\"sec2 : vel[%d] : %f \\n\", index,d[index]);\n        // printf(\"sec1 : goal[%d] : %f \\n\", joint_num, g[joint_num]);\n    }\n\t///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n\telse\n\t{\n\t\tf[index] = pos_gain * cost_pos + vel_gain * cost_vel;\n    }\n\n\t///////////////////// Velocity Limit Constraint ///////////////////////////////////////////////////\n\tif(abs_cuda1(cost_vel) > velocity_lim[0]) // 0.8\n\t{\n\t\tf[index] = f[index] + constraint_gain * cost_vel;\n\t}\n\n    ///////////////////// Joint Limit Constraint   ///////////////////////////////////////////////////\n    if(e[index] < min_joint_limit[joint_num])\n    {\n        f[index] = f[index] + constraint_gain * (e[index] - min_joint_limit[joint_num]) * (e[index] - min_joint_limit[joint_num]);\n    }\n\n    else if(e[index] > max_joint_limit[joint_num])\n    {\n        f[index] = f[index] + constraint_gain * (e[index] - max_joint_limit[joint_num]) * (e[index] - max_joint_limit[joint_num]);\n    }\n    __syncthreads();\n}\n\n__global__ void cost_function_task_space_control(double *rotation_EE, double *rotation_goal_T, double *position, double *rotaiton, double *f, double *g, double *position_sec1, double *position_sec2, double *_manipulability, double *now_gap)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index2 = index % _time_window ;\n    double weight1 = 60000.0; // 10000.0 (10.0) // rot\n    double weight2 = 300000.0; // 50000.0 (10.0) // pos\n    // double weight_manipul = 100.0;\n\n    if(index < _sampling_num * _time_window)\n    {\n        double rotation_EE_index[9];\n        for(int i = 0; i<9; i++)\n        {\n            rotation_EE_index[i] = rotation_EE[index*9+i];    \n        }\n\n        double PosEE_index[3];\n        for(int i = 0; i<3; i++)\n        {\n            PosEE_index[i] = position[index*3+i];    \n        }\n\n        double RotGoalT_x_RotEE[9];\n        double RotGap[3];\n\n\n        // double RotGoalT_x_PosEE[3];\n        // double RotGoalT_x_PosGoal[3];\n        double PosGap[3];\n\n        matrixMultiply_3x3(rotation_goal_T, rotation_EE_index, RotGoalT_x_RotEE);\n        rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n\n        double cost1 = 0.0;\n        double cost2 = 0.0;\n        double cost1_2 = 0.0;        \n        double cost2_2 = 0.0;\n        // double cost2 = 0.0;\n\n        for(int i = 0;i<3; i++)\n        {\n            PosGap[i] = abs(PosEE_index[i]-g[i]);\n            cost1_2 = cost1_2 + abs_cuda1(RotGap[i]);\n\n            // if(PosGap[i] > 1)\n            // {\n            //     cost2_2 = cost2_2 + pow2_cuda(PosGap[i]);\n            // }\n            // else\n            // {\n            //     cost2_2 = cost2_2 + PosGap[i];\n            // }\n            cost2_2 = cost2_2 + pow2_cuda(PosGap[i]) + abs_cuda1(PosGap[i]);\n        }\n        // if(cost1_2 > 1)\n        // {\n        //     cost1_2 = pow2_cuda(cost1_2);\n        // }\n        // cost1 = cost1_2 + cost2_2;\n        // if(cost1 > 2.0)\n        // {\n        //     f[index] = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n        // else if(cost1 <= 2.0 && cost1 > 1.0)\n        // {\n        //     f[index] = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n        // else\n        // {\n        //     f[index] = weight2 * cost2_2 + weight1 * cost1_2;\n        // }\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        if(cost2_2 >  position_sec1[0])\n        {\n            cost1 = _time_window*_time_window + weight2 * cost2_2 + weight1 * cost1_2;\n            // cost2 = weight_manipul * (1-_manipulability[index]);\n        }\n        ///////////////////// Position Error Section2 (cost : position error + velocity) ///////////////////////////////////////////////////\n        else if(cost2_2 <= position_sec1[0] && cost2_2 > position_sec2[0])\n        {\n            cost1 = _time_window + weight2 * cost2_2 + weight1 * cost1_2;\n            // cost2 = weight_manipul * (1-_manipulability[index]);\n        }\n        ///////////////////// Position Error Section3 (cost : position error + velocity + acceleration) ///////////////////////////////////////////////////\n        else\n        {\n            cost1 = weight2 * cost2_2 * 0.3 + weight1 * cost1_2;\n            // cost2 = (1-_manipulability[index]);\n        }\n        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n        // cost1 = weight2 * cost2_2 + weight1 * cost1_2;\n        if(sqrt(_manipulability[index])<= 0.1)\n        {\n            cost2 = 100.0 * (1-sqrt(_manipulability[index]));\n        }\n        f[index] = cost1 + cost2;\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n        // if(now_gap[0] > 1.0)\n        // {\n        //     if(index2 < _time_window-5)\n        //     {\n        //         f[index] = 0.0;\n        //     }\n        // }\n        // else\n        // {\n        //     if(index2 >= _time_window-5)\n        //     {\n        //         f[index] = 0.0;\n        //     }\n        // }\n    }    \n    __syncthreads();\n}\n\n__global__ void generate_random2(double* _A, double* _mean_matrix, double* _matrix_for_cuda)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    int index3 = index % (_time_window*_JDOF);\n    int joint_num = index3 / _time_window;\n    // curandState localState = state[index%_time_window];\n    curandState state;\n    \n    // 현재 스레드의 인덱스로 상태 정보 초기화\n    curand_init(0, index, 0, &state);\n    // double rand_val;\n\n    // rand_val = curand_normal(&localState) * 1.0 + _A[joint_num];\n    // _matrix_for_cuda[index] = rand_val;\n    if (index % _time_window == 0)\n    {\n        // if(index == 0)\n        // {\n        //     _matrix_for_cuda[index] = 0.0;\n        // }\n        // else\n        // {\n            if(joint_num>=4)\n            {\n                _matrix_for_cuda[index] = curand_normal(&state) * 1.5 + _A[joint_num];    \n            }\n            else\n            {\n                _matrix_for_cuda[index] = curand_normal(&state) * 1.0 + _A[joint_num];\n            }            \n        // }\n        if(abs_cuda1(_matrix_for_cuda[index])>100)\n        {\n            _matrix_for_cuda[index] = 0.0;   \n        }\n    }\n    __syncthreads();\n}\n\n__global__ void GetBodyRotationMatrix(double *xyzrpy_goal, double *RGyro)\n{\n    double Roll = xyzrpy_goal[3];\n    double Pitch = xyzrpy_goal[4];\n    double Yaw = xyzrpy_goal[5];\n\n    double R_yaw[9];\n    R_yaw[0] = cos(Yaw);\n    R_yaw[1] = -sin(Yaw);\n    R_yaw[2] = 0.0;\n    R_yaw[3] = sin(Yaw);\n    R_yaw[4] = cos(Yaw);\n    R_yaw[5] = 0.0;\n    R_yaw[6] = 0.0;\n    R_yaw[7] = 0.0;\n    R_yaw[8] = 1.0;\n\n    double R_pitch[9];\n    R_pitch[0] = cos(Pitch);\n    R_pitch[1] = 0.0;\n    R_pitch[2] = sin(Pitch);\n    R_pitch[3] = 0.0;\n    R_pitch[4] = 1.0;\n    R_pitch[5] = 0.0;\n    R_pitch[6] = -sin(Pitch);\n    R_pitch[7] = 0.0;\n    R_pitch[8] = cos(Pitch);\n\n    double R_roll[9];\n    R_roll[0] = 1.0;\n    R_roll[1] = 0.0;\n    R_roll[2] = 0.0;\n    R_roll[3] = 0.0;\n    R_roll[4] = cos(Roll);\n    R_roll[5] = -sin(Roll);\n    R_roll[6] = 0.0;\n    R_roll[7] = sin(Roll);\n    R_roll[8] = cos(Roll);\n    \n    double tmp_mat3x3[9];\n    matrixMultiply_3x3(R_yaw, R_pitch, tmp_mat3x3);\n    matrixMultiply_3x3(tmp_mat3x3, R_roll, RGyro);\n}\n\n__global__ void prev_computeForwardKinematics(double* FK_a, double* FK_d, double* FK_alpha, double* prev_q, double* position_EE, double* orientation_EE) \n{\n    double transformationMatrix[16];\n    double transformationMatrix2[16];\n    double tempMatrix[16];\n    double tempMatrix2[16];\n    \n    computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], prev_q[0], transformationMatrix);\n    computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], prev_q[1], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], prev_q[2], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], prev_q[3], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], prev_q[4], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], prev_q[5], tempMatrix);\n    matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n    computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], prev_q[6], tempMatrix2);\n    matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n    // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n    // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n    // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix)\n    position_EE[0] = transformationMatrix[3];\n    position_EE[1] = transformationMatrix[7];\n    position_EE[2] = transformationMatrix[11];\n    //rpy\n    double tempVec[3];\n    rpy_from_transformationmatrix(transformationMatrix, tempVec);\n    orientation_EE[0] = tempVec[0];\n    orientation_EE[1] = tempVec[1];\n    orientation_EE[2] = tempVec[2];\n}\n\n__global__ void computeForwardKinematics(double* prev_x, double* prev_r, double* FK_a, double* FK_d, double* FK_alpha, double* jointAngles, double* position_EE, double* orientation_EE, double* velocity_EE, double* velocity_ori_EE, double* transformationMatrix_3x3, double *jacobian_matrix, double *_manipulability) \n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    // int index3 = index % (_time_window*7);\n    // int joint_num = index3 / _time_window;\n    // 각 변환 행렬 계산\n\n    if(index < _sampling_num)\n    {\n        for(int i = 0; i<_time_window; i++)\n        {\n            double transformationMatrix[16];\n            double transformationMatrix2[16];\n\n            double tempMatrix[16];\n            double tempMatrix2[16];\n            double man_6x6[36];\n\n            double p0[3];\n            double p1[3];\n            double p2[3];\n            double p3[3];\n            double p4[3];\n            double p5[3];\n            double p6[3];\n\n            double z0[3];\n            double z1[3];\n            double z2[3];\n            double z3[3];\n            double z4[3];\n            double z5[3];\n            double z6[3];\n\n            double t0[3];\n            double t1[3];\n            double t2[3];\n            double t3[3];\n            double t4[3];\n            double t5[3];\n\n            p0[0] = 0.0;\n            p0[1] = 0.0;\n            p0[2] = FK_d[0];\n\n            z0[0] = 0.0;\n            z0[1] = 0.0;\n            z0[2] = 1.0;      \n            \n            computeTransformationMatrix(FK_alpha[0], FK_a[0], FK_d[0], jointAngles[index*_time_window*_JDOF+i], transformationMatrix);\n\n            computeTransformationMatrix(FK_alpha[1], FK_a[1], FK_d[1], jointAngles[index*_time_window*_JDOF+_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p1[0] = transformationMatrix2[3];\n            p1[1] = transformationMatrix2[7];\n            p1[2] = transformationMatrix2[11];\n            z1[0] = transformationMatrix2[2];\n            z1[1] = transformationMatrix2[6];\n            z1[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[2], FK_a[2], FK_d[2], jointAngles[index*_time_window*_JDOF+2*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p2[0] = transformationMatrix[3];\n            p2[1] = transformationMatrix[7];\n            p2[2] = transformationMatrix[11];\n            z2[0] = transformationMatrix[2];\n            z2[1] = transformationMatrix[6];\n            z2[2] = transformationMatrix[10];\n\n            computeTransformationMatrix(FK_alpha[3], FK_a[3], FK_d[3], jointAngles[index*_time_window*_JDOF+3*_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p3[0] = transformationMatrix2[3];\n            p3[1] = transformationMatrix2[7];\n            p3[2] = transformationMatrix2[11];\n            z3[0] = transformationMatrix2[2];\n            z3[1] = transformationMatrix2[6];\n            z3[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[4], FK_a[4], FK_d[4], jointAngles[index*_time_window*_JDOF+4*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p4[0] = transformationMatrix[3];\n            p4[1] = transformationMatrix[7];\n            p4[2] = transformationMatrix[11];\n            z4[0] = transformationMatrix[2];\n            z4[1] = transformationMatrix[6];\n            z4[2] = transformationMatrix[10];\n\n            computeTransformationMatrix(FK_alpha[5], FK_a[5], FK_d[5], jointAngles[index*_time_window*_JDOF+5*_time_window+i], tempMatrix);\n            matrixMultiply_4x4(transformationMatrix, tempMatrix, transformationMatrix2);\n            p5[0] = transformationMatrix2[3];\n            p5[1] = transformationMatrix2[7];\n            p5[2] = transformationMatrix2[11];\n            z5[0] = transformationMatrix2[2];\n            z5[1] = transformationMatrix2[6];\n            z5[2] = transformationMatrix2[10];\n\n            computeTransformationMatrix(FK_alpha[6], FK_a[6], FK_d[6], jointAngles[index*_time_window*_JDOF+6*_time_window+i], tempMatrix2);\n            matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n            p6[0] = transformationMatrix[3];\n            p6[1] = transformationMatrix[7];\n            p6[2] = transformationMatrix[11];\n            z6[0] = transformationMatrix[2];\n            z6[1] = transformationMatrix[6];\n            z6[2] = transformationMatrix[10];\n\n            t0[0] =  p6[0]-p0[0];\n            t0[1] =  p6[1]-p0[1];\n            t0[2] =  p6[2]-p0[2];\n\n            t1[0] =  p6[0]-p1[0];\n            t1[1] =  p6[1]-p1[1];\n            t1[2] =  p6[2]-p1[2];\n\n            t2[0] =  p6[0]-p2[0];\n            t2[1] =  p6[1]-p2[1];\n            t2[2] =  p6[2]-p2[2];\n\n            t3[0] =  p6[0]-p3[0];\n            t3[1] =  p6[1]-p3[1];\n            t3[2] =  p6[2]-p3[2];\n\n            t4[0] =  p6[0]-p4[0];\n            t4[1] =  p6[1]-p4[1];\n            t4[2] =  p6[2]-p4[2];\n\n            t5[0] =  p6[0]-p5[0];\n            t5[1] =  p6[1]-p5[1];\n            t5[2] =  p6[2]-p5[2];            \n\n            jacobian_matrix[index*_time_window*42+i*42+0] = z0[1]*t0[2]-z0[2]*t0[1];\n            jacobian_matrix[index*_time_window*42+i*42+7] = z0[2]*t0[0]-z0[0]*t0[2];\n            jacobian_matrix[index*_time_window*42+i*42+14] = z0[0]*t0[1]-z0[1]*t0[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+1] = z1[1]*t1[2]-z1[2]*t1[1];\n            jacobian_matrix[index*_time_window*42+i*42+8] = z1[2]*t1[0]-z1[0]*t1[2];\n            jacobian_matrix[index*_time_window*42+i*42+15] = z1[0]*t1[1]-z1[1]*t1[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+2] = z2[1]*t2[2]-z2[2]*t2[1];\n            jacobian_matrix[index*_time_window*42+i*42+9] = z2[2]*t2[0]-z2[0]*t2[2];\n            jacobian_matrix[index*_time_window*42+i*42+16] = z2[0]*t2[1]-z2[1]*t2[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+3] = z3[1]*t3[2]-z3[2]*t3[1];\n            jacobian_matrix[index*_time_window*42+i*42+10] = z3[2]*t3[0]-z3[0]*t3[2];\n            jacobian_matrix[index*_time_window*42+i*42+17] = z3[0]*t3[1]-z3[1]*t3[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+4] = z4[1]*t4[2]-z4[2]*t4[1];\n            jacobian_matrix[index*_time_window*42+i*42+11] = z4[2]*t4[0]-z4[0]*t4[2];\n            jacobian_matrix[index*_time_window*42+i*42+18] = z4[0]*t4[1]-z4[1]*t4[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+5] = z5[1]*t5[2]-z5[2]*t5[1];\n            jacobian_matrix[index*_time_window*42+i*42+12] = z5[2]*t5[0]-z5[0]*t5[2];\n            jacobian_matrix[index*_time_window*42+i*42+19] = z5[0]*t5[1]-z5[1]*t5[0];\n\n            jacobian_matrix[index*_time_window*42+i*42+6] = 0.0;\n            jacobian_matrix[index*_time_window*42+i*42+13] = 0.0;\n            jacobian_matrix[index*_time_window*42+i*42+20] = 0.0;\n\n            jacobian_matrix[index*_time_window*42+i*42+21] = z0[0];\n            jacobian_matrix[index*_time_window*42+i*42+28] = z0[1];\n            jacobian_matrix[index*_time_window*42+i*42+35] = z0[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+22] = z1[0];\n            jacobian_matrix[index*_time_window*42+i*42+29] = z1[1];\n            jacobian_matrix[index*_time_window*42+i*42+36] = z1[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+23] = z2[0];\n            jacobian_matrix[index*_time_window*42+i*42+30] = z2[1];\n            jacobian_matrix[index*_time_window*42+i*42+37] = z2[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+24] = z3[0];\n            jacobian_matrix[index*_time_window*42+i*42+31] = z3[1];\n            jacobian_matrix[index*_time_window*42+i*42+38] = z3[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+25] = z4[0];\n            jacobian_matrix[index*_time_window*42+i*42+32] = z4[1];\n            jacobian_matrix[index*_time_window*42+i*42+39] = z4[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+26] = z5[0];\n            jacobian_matrix[index*_time_window*42+i*42+33] = z5[1];\n            jacobian_matrix[index*_time_window*42+i*42+40] = z5[2];\n\n            jacobian_matrix[index*_time_window*42+i*42+27] = z6[0];\n            jacobian_matrix[index*_time_window*42+i*42+34] = z6[1];\n            jacobian_matrix[index*_time_window*42+i*42+41] = z6[2];\n            \n            for(int l = 0; l<6; l++)\n            {\n                for(int j = 0; j<6; j++)\n                {\n                    man_6x6[l*6+j] = 0.0;\n                    for(int k = 0; k<7; k++)\n                    {\n                        man_6x6[l*6+j] = man_6x6[l*6+j] + (jacobian_matrix[index*_time_window*42+i*42+l*7+k] * jacobian_matrix[index*_time_window*42+i*42+j*7+k]);\n                    }                \n                }\n            }\n            determinant_6x6(man_6x6,_manipulability[index*_time_window+i]);\n            // computeTransformationMatrix(FK_alpha[7], FK_a[7], FK_d[7], 0.0, tempMatrix2);\n            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n\n            // computeTransformationMatrix(FK_alpha[8], FK_a[8], FK_d[8], PI_CUDA/4.0, tempMatrix2);\n            // matrixMultiply_4x4(transformationMatrix2, tempMatrix2, transformationMatrix);\n\n            transformationMatrix_3x3[index*_time_window*9+i*9] = transformationMatrix[0];\n            transformationMatrix_3x3[index*_time_window*9+i*9+1] = transformationMatrix[1];\n            transformationMatrix_3x3[index*_time_window*9+i*9+2] = transformationMatrix[2];\n\n            transformationMatrix_3x3[index*_time_window*9+i*9+3] = transformationMatrix[4];\n            transformationMatrix_3x3[index*_time_window*9+i*9+4] = transformationMatrix[5];\n            transformationMatrix_3x3[index*_time_window*9+i*9+5] = transformationMatrix[6];\n\n            transformationMatrix_3x3[index*_time_window*9+i*9+6] = transformationMatrix[8];\n            transformationMatrix_3x3[index*_time_window*9+i*9+7] = transformationMatrix[9];\n            transformationMatrix_3x3[index*_time_window*9+i*9+8] = transformationMatrix[10];\n\n            position_EE[index*_time_window*3+i*3] = transformationMatrix[3];\n            position_EE[index*_time_window*3+i*3+1] = transformationMatrix[7];\n            position_EE[index*_time_window*3+i*3+2] = transformationMatrix[11];\n\n            //rpy\n            double tempVec[3];\n            rpy_from_transformationmatrix(transformationMatrix, tempVec);\n            orientation_EE[index*_time_window*3+i*3] = tempVec[0];\n            orientation_EE[index*_time_window*3+i*3+1] = tempVec[1];\n            orientation_EE[index*_time_window*3+i*3+2] = tempVec[2];\n            \n            if(i == 0)\n            {\n                velocity_EE[index*_time_window*3+i*3] = (transformationMatrix[3] - prev_x[0]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - prev_x[1]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - prev_x[2]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3] = (tempVec[0] - prev_r[0]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - prev_r[1]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - prev_r[2]) / _dt_cuda;\n            }\n            else\n            {\n                velocity_EE[index*_time_window*3+i*3+0] = (transformationMatrix[3] - position_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+1] = (transformationMatrix[7] - position_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n                velocity_EE[index*_time_window*3+i*3+2] = (transformationMatrix[11] - position_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+0] = (tempVec[0] - orientation_EE[index*_time_window*3+(i-1)*3]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+1] = (tempVec[1] - orientation_EE[index*_time_window*3+(i-1)*3+1]) / _dt_cuda;\n                velocity_ori_EE[index*_time_window*3+i*3+2] = (tempVec[2] - orientation_EE[index*_time_window*3+(i-1)*3+2]) / _dt_cuda;\n            }            \n        }    \n    }\n    __syncthreads();\n}\n\n__global__ void forwardPropagation(double *inputs, double *weights0, double *weights1, double *weights2, double *weights3, double *weights4, double *weights5, double *outputs) {\n    int tid = threadIdx.x + blockIdx.x * blockDim.x;\n    \n    double hidden0[_nodes_cuda];\n    double hidden1[_nodes_cuda];\n    \n    if (tid < _sampling_num) {\n        for (int j = 0; j < _nodes_cuda; j++) {\n            hidden0[j] = 0.0;\n        }\n    \n        for (int j = 0; j < _nodes_cuda; j++) {\n            hidden1[j] = 0.0;\n        }\n        \n        for (int j = 0; j < _nodes_cuda; j++) {\n            for (int i = 0; i < _JDOF; i++) {\n                hidden0[j] += inputs[tid * _JDOF + i] * weights0[i * _nodes_cuda + j];\n            }\n            \n            hidden0[j] += weights1[j];\n            \n            if (hidden0[j] <= 0) {\n                hidden0[j] = 0.0;\n            }\n        }\n        \n        for (int j = 0; j < _nodes_cuda; j++) {\n            for (int i = 0; i < _nodes_cuda; i++) {\n                hidden1[j] += hidden0[i] * weights2[i * _nodes_cuda + j];\n            }\n            \n            hidden1[j] += weights3[j];\n            \n            if (hidden1[j] <= 0) {\n                hidden1[j] = 0.0;\n            }\n        }\n    \n        double output1 = 0.0;\n    \n        for (int i = 0; i < _nodes_cuda; i++) {\n            output1 += hidden1[i] * weights4[i];\n        }\n    \n        output1 += weights5[0];\n        output1 = sigmoid(output1);\n    \n        outputs[tid] = output1;\n    }\n    __syncthreads();\n}\n\n__global__ void calculate_inputs(double* e, double* _min_joint_position, double* _max_joint_position, double* inputs)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n\n    if (index < _JDOF * _sampling_num)\n    {\n        inputs[index] = (e[index * _time_window + _time_window-1] - _min_joint_position[index % _JDOF]) / (abs_cuda1(_max_joint_position[index % _JDOF] - _min_joint_position[index % _JDOF]) / 2) - 1;\n\n        if (inputs[index] > 1)\n        {\n            inputs[index] = 1;\n        }\n        else if (inputs[index] < -1)\n        {\n            inputs[index] = -1;\n        }\n    }\n    __syncthreads();\n}\n\n__global__ void if_find_solution(double *Joint_pos, double* rotation_mat_EE, double *min_joint_limit, double *max_joint_limit, double *position_EE, double *rotation_EE, double *goal, double *goal_mat_T, double *find_sol)\n{\n    int index = threadIdx.x + blockIdx.x * blockDim.x;\n    if(index < _sampling_num)\n    {\n        for(int i = 0; i<_time_window; i++)\n        {\n            double tmp_p = 0.0;\n            tmp_p = abs_cuda2(goal[0],position_EE[index*_time_window*3+i*3]);\n            tmp_p = tmp_p + abs_cuda2(goal[1],position_EE[index*_time_window*3+i*3+1]);\n            tmp_p = tmp_p + abs_cuda2(goal[2],position_EE[index*_time_window*3+i*3+2]);\n\n            double rotation_EE_index[9];\n            for(int j = 0; j<9; j++)\n            {\n                rotation_EE_index[i] = rotation_mat_EE[index*_time_window*3+i*3+j];\n            }\n\n            double RotGoalT_x_RotEE[9];\n            double RotGap[3];\n\n            matrixMultiply_3x3(goal_mat_T, rotation_EE_index, RotGoalT_x_RotEE);\n            rpy_from_rotationmatrix(RotGoalT_x_RotEE, RotGap);\n\n            double tmp_p2 = 0.0;\n            tmp_p2 = abs_cuda1(RotGap[0]);\n            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[1]);\n            tmp_p2 = tmp_p2 + abs_cuda1(RotGap[2]);\n\n            find_sol[index] = 0;\n            if(tmp_p <= 0.1 && tmp_p2 <= 0.1)\n            {\n                for(int j = 0; j<_JDOF; j++)\n                {\n                    if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] <= min_joint_limit[j])\n                    {\n                        find_sol[index] = 0;\n                        break;\n                    }\n                    else if(Joint_pos[j*_time_window+index*_time_window*_JDOF+i] >= max_joint_limit[j])\n                    {\n                        find_sol[index] = 0;\n                        break;\n                    }\n                    else\n                    {\n                        if(j == _JDOF-1)\n                        {\n                            find_sol[index] = 1;\n                        }                        \n                        // break;\n                    }\n                }\n            }\n            if(find_sol[index] == 1)\n            {\n                break;\n            }\n        }\n    }\n}\n\nvoid CudaTest::cuda_cal(double *_init_pos,double *_init_vel, double *_goal_pos_cuda, int control_mode, double *returnArray)\n{ \n    // _dt_cuda2[0] = 0.5;\n    prev_x_cost = 0.0;\n    now_pos_gap[0] = 0.0;\n    for(int i = 0; i<3; i++)\n    {\n        now_pos_gap[0] = now_pos_gap[0] + abs(prev_position_EE[i]-_goal_pos_cuda[i]);\n        // now_pos_gap[0] = now_pos_gap[0] + abs(prev_orientation_EE[i]-_goal_pos_cuda[i+3]) * 0.1;\n    }\n    // if(now_pos_gap[0] >= 0.1 && now_pos_gap[0] < 0.3)\n    // {\n    //     _dt_cuda2[0] = now_pos_gap[0];\n    // }\n    if(found_goal == 1)\n    {\n        if(now_pos_gap[0] > position_sec2[0] && now_pos_gap[0] < 1.0)\n        {\n            // _dt_cuda2[0] = ((now_pos_gap[0]-0.03) * 497 / 990) + 0.003;\n            _dt_cuda2[0] = -1 * ((0.7-_dt_cuda) / pow(position_sec2[0]-1,2))*pow(now_pos_gap[0]-1,2)+0.7;\n        }\n        else if(now_pos_gap[0] <= position_sec2[0])\n        {\n            _dt_cuda2[0] = _dt_cuda;\n        }\n        else if(now_pos_gap[0] >= 1.0)\n        {\n            _dt_cuda2[0] = 0.7;\n        }\n    }\n    else\n    {\n        _dt_cuda2[0] = 0.7;\n    }\n    found_goal = 0;\n    if(_dt_cuda2[0] != 0.7)\n    {\n        cout<<\"_dt_cuda2 : \"<<_dt_cuda2[0]<<endl;\n    }    \n\n    for(int i = 0; i<_JDOF; i++)\n    {\n        if( abs(_q_des[i]-_init_pos[i]) >= 0.1)\n        {            \n            _q_des[i] = _init_pos[i];\n            _qdot_des[i] = _init_vel[i];\n        }\n    }\n    // x간의 거리가 너무 멀고 특정 관절의 _q_des가 Joint Limit 근처이며 평균값(_A)이 특정값 이하 = 평균에 특정 배수만큼 곱해주기?\n    \n    dim3 blockDim(N/_time_window, 1, 1);\n    dim3 gridDim(_time_window, 1, 1);\n    dim3 gridDim2(_sampling_num, 1);\n    dim3 blockDim2(1, 1);\n    dim3 blockSize(1, 1);\n    dim3 gridSize(1, 1);\n    dim3 blockSize2(1, 1);\n    dim3 gridSize2(_sampling_num * _time_window, 1);\n\n    if(control_mode == 0)\n    {\n        cudaMemcpy(dev__prev_matrix_for_cuda, dev__matrix_for_cuda, N * sizeof(double), cudaMemcpyDeviceToDevice);\n        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        for(int i = 0; i<N; i++)\n        {\n            int index222 = i / _time_window;\n            if((i%_time_window) != 0)\n            {\n                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n            }\n        }\n\n        // _dt_cuda2\n        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        \n        for(int i = 0; i<N; i++)\n        {\n            if((i%_time_window) != 0)\n            {\n                d[i] = d[i-1] + d[i];\n                e[i] = e[i-1] + d[i] * _dt_cuda;\n            }\n        }\n\n        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_q_goal, _goal_pos_cuda, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n\n        cost_function_joint_control <<< gridDim, blockDim>>> (dev_d, dev_e, dev_cost, dev_q_goal, dev_position_sec1, dev_position_sec2, dev_velocity_lim, dev__matrix_for_cuda, dev__prev_matrix_for_cuda, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost);\n        \n        cudaMemcpy(f, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n        // cudaDeviceSynchronize();\n\n        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);\n\n        \n        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();    \n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _return_cost[i] = 0.0;\n            for(int j = 0; j<_JDOF; j++)\n            {\n                for(int k = 0; k<_time_window; k++)\n                {\n                    _return_cost[i] = _return_cost[i] + f[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                }\n            }\n            if(outputs[i] > 0.5)\n            {\n                _return_cost[i] = _return_cost[i] + outputs[i] * pow(10,6);\n            }\n            _return_cost[i] = _return_cost[i] / _JDOF;\n        }\n\n        _min_cost = 1000000000000000.0;\n        weight_sum = 0.0;\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _return_cost[i];\n            if(_min_cost > _cost[i])\n            {\n                _min_cost = _cost[i];\n            }\n        }\n        memset(_weighted_A, 0, _JDOF * sizeof(double));\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _cost[i] = _cost[i] - _min_cost;\n            if(_cost[i]<100)\n            {\n                _cost[i] = exp(-_cost[i]);\t\t\n                weight_sum = weight_sum + _cost[i];\n                for(int j = 0; j<_JDOF; j++)\n                {\n                    _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n                }\n            }\n        }\n        for(int j = 0; j<_JDOF; j++)\n        {\n            _weighted_A[j] /=  weight_sum;\n            _A[j] = _weighted_A[j];\n            // if(_A[j] > 10.0)\n            // {\n            //     _A[j] = 10.0;\n            // }\n            // else if(_A[j] < -10.0)\n            // {\n            //     _A[j] = -10.0;\n            // }\n        }\n        \n        for(int i = 0; i<_JDOF; i++)\n        {\n            returnArray[(_JDOF*2)+i] = _weighted_A[i];\n            returnArray[_JDOF+i] = _qdot_des[i] + (_weighted_A[i] * _dt_cuda);\n            returnArray[i] = _q_des[i] + (_qdot_des[i] * _dt_cuda);\n\n            _q_des[i] = returnArray[i];\n            _qdot_des[i] = returnArray[_JDOF+i];\n        }\n    }\n\n    else if(control_mode == 1)\n    {\n        cudaMemcpy(dev__A, _A, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        generate_random2<<<gridDim, blockDim>>>(dev__A, dev__mean_matrix, dev__matrix_for_cuda);\n        cudaMemcpy(_matrix_for_cuda, dev__matrix_for_cuda, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        for(int i = 0; i<N; i++)\n        {\n            int index222 = i / _time_window;\n            if((i%_time_window) != 0)\n            {   \n                _matrix_for_cuda[i] = _matrix_for_cuda[_time_window*index222];\n                if((i%_time_window) >= _time_window-_dt2_window)\n                {\n                    _matrix_for_cuda[i] = _matrix_for_cuda[i]/3.0;\n                }                \n            }\n            // cout<<\"_matrix_for_cuda[\"<<i<<\"] : \"<<_matrix_for_cuda[i]<<endl;\n        }\n\n        cudaMemcpy(dev_b, _qdot_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_c, _q_des, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev__matrix_for_cuda, _matrix_for_cuda, N*sizeof(double), cudaMemcpyHostToDevice);\n        \n        cudaMemcpy(dev_dt_cuda2, _dt_cuda2, sizeof(double), cudaMemcpyHostToDevice);\n        state_update <<< gridDim, blockDim>>> (dev__matrix_for_cuda, dev_b, dev_c, dev_d, dev_e, dev_dt_cuda2);\n        cudaMemcpy(d, dev_d, N*sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(e, dev_e, N*sizeof(double), cudaMemcpyDeviceToHost);\n\n        cudaDeviceSynchronize();\n        for(int i = 0; i<N; i++)\n        {\n            if((i%_time_window) != 0)\n            {\n                if((i%_time_window) >= _time_window-_dt2_window)\n                {\n                    d[i] = d[i-1] + d[i];\n                    e[i] = e[i-1] + d[i] * _dt_cuda2[0];\n                }\n                else\n                {\n                    d[i] = d[i-1] + d[i];\n                    e[i] = e[i-1] + d[i] * _dt_cuda;\n                }\n            }\n        }\n\n        cudaMemcpy(dev_d, d, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_e, e, N*sizeof(double), cudaMemcpyHostToDevice);\n        cudaDeviceSynchronize();\n\n        // cout<<\"222222222222222222222222\"<<endl;\n        // cal_jacobian<<< 1, 1>>>(dev_e,dev_jacobian);\n        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        // cudaDeviceSynchronize();\n        // for(int k = 0 ;k <_sampling_num; k++)\n        // {\n        //     cout<<\"CUDA jacobian sample\"<<k<<\"th\"<<endl;\n        //     for(int i = 0; i<42; i++)\n        //     {\n        //         if(i%7 == 6)\n        //         {\n        //             cout<<jacobian[i+42*k]<<endl;    \n        //         }\n        //         else\n        //         {\n        //             cout<<jacobian[i+42*k]<<\" \";\n        //         }            \n        //     }\n        // }        \n        \n        // cudaMemcpy(jacobian, dev_jacobian, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        // cudaMemcpy(jacobian_transpose, dev_jacobian_transpose, _JDOF * 6 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        // cal_manipulability<<< 1, 1>>>(dev_jacobian,dev_manipulability);\n        // cudaMemcpy(manipulability, dev_manipulability, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n\n\n        // cout<<\"CUDA manipulability\"<<endl;\n        // for(int i = 0; i<N/_JDOF; i++)\n        // {\n        //     cout<<\"manipulability ith : \"<<i<<manipulability[i]<<endl;\n        // }\n        cudaMemcpy(dev_FK_a, FK_a, 9*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_FK_d, FK_d, 9*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_FK_alpha, FK_alpha, 9*sizeof(double), cudaMemcpyHostToDevice);\n\n        prev_computeForwardKinematics<<<gridSize, blockSize>>> (dev_FK_a, dev_FK_d, dev_FK_alpha, dev_c, dev_prev_position_EE, dev_prev_orientation_EE);\n        computeForwardKinematics <<<N/_sampling_num, _sampling_num>>> (dev_prev_position_EE,dev_prev_orientation_EE, dev_FK_a, dev_FK_d, dev_FK_alpha, dev_e, dev_position_EE, dev_orientation_EE, dev_velocity_EE, dev_velocity_ori_EE, dev_rot_EE, dev_jacobian,dev_manipulability);\n        cudaMemcpy(prev_position_EE, dev_prev_position_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(prev_orientation_EE, dev_prev_orientation_EE, 3 * sizeof(double), cudaMemcpyDeviceToHost);\n\n        cudaMemcpy(position_EE, dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(orientation_EE, dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(velocity_EE, dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(velocity_ori_EE, dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);        \n        cudaDeviceSynchronize();\n        \n        cudaMemcpy(dev_position_sec1, position_sec1, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_position_sec2, position_sec2, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_velocity_lim, velocity_lim, sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_max_limit_for_cost, _hat_max_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_joint_min_limit_for_cost, _hat_min_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_cen_joint_position, _cen_joint_position, _JDOF * sizeof(double), cudaMemcpyHostToDevice);\n\n        cudaMemcpy(dev_x_goal, _goal_pos_cuda, 6*sizeof(double), cudaMemcpyHostToDevice);\n\n        GetBodyRotationMatrix<<< gridSize, blockSize>>>(dev_x_goal, dev_rot_goal);\n        // cudaMemcpy(tmp_goal, dev_rot_goal, 9 * sizeof(double), cudaMemcpyDeviceToHost);\n        Transpose_Matrix_3x3<<< gridSize, blockSize>>>(dev_rot_goal, dev_rot_goal_T);\n\n        if_find_solution<<< N/_sampling_num, _sampling_num>>>(dev_e, dev_rot_EE, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_position_EE, dev_orientation_EE, dev_x_goal, dev_rot_goal_T, dev_found_sol);\n        cudaMemcpy(found_goal_list, dev_found_sol, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaMemcpy(dev_now_pos_gap, now_pos_gap, sizeof(double), cudaMemcpyHostToDevice);        \n        joint_limit_cost<<< gridDim, blockDim>>>(dev_e, dev_d, dev_cost, dev_joint_min_limit_for_cost, dev_joint_max_limit_for_cost, dev_velocity_lim, dev_cen_joint_position, dev_now_pos_gap);\n        cudaMemcpy(cost_jointlimit, dev_cost, N * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        \n\n\n\n\n\n        cost_function_task_space_control<<<gridSize2, blockSize2 >>> (dev_rot_EE, dev_rot_goal_T, dev_position_EE, dev_orientation_EE, dev_cost_x, dev_x_goal, dev_position_sec1, dev_position_sec2, dev_manipulability, dev_now_pos_gap);\n        cudaMemcpy(cost_xerr, dev_cost_x, _sampling_num * _time_window * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n        // for(int i = 0; i<_sampling_num * _time_window; i++)\n        // {\n        //     cout<<\"cost_xerr[\"<<i<<\"] : \"<<cost_xerr[i]<<endl;\n        // }\n\n        cudaMemcpy(dev_min_joint_position_for_NN, _min_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(dev_max_joint_position_for_NN, _max_joint_position, _JDOF*sizeof(double), cudaMemcpyHostToDevice);\n\n        calculate_inputs<<<gridDim, blockDim>>>(dev_e, dev_min_joint_position_for_NN, dev_max_joint_position_for_NN, dev_inputs);\n        // cudaMemcpy(tmp_goal, dev_inputs, _JDOF * _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        // for(int i = 0; i<_JDOF * _sampling_num; i++)\n        // {\n        //     cout<<\"tmp_goal[ \"<<i<<\"] : \"<<tmp_goal[i]<<endl;\n        // }\n        cudaDeviceSynchronize();\n\n        cudaMemcpy(d_weights0, weights0, _JDOF * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights1, weights1, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights2, weights2, _nodes_cuda * _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights3, weights3, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights4, weights4, _nodes_cuda * sizeof(double), cudaMemcpyHostToDevice);\n        cudaMemcpy(d_weights5, weights5, OUTPUT_SIZE * sizeof(double), cudaMemcpyHostToDevice);        \n        forwardPropagation<<< gridDim2, blockDim2>>>(dev_inputs, d_weights0, d_weights1, d_weights2, d_weights3, d_weights4, d_weights5, d_outputs);\n        cudaMemcpy(outputs, d_outputs, _sampling_num * sizeof(double), cudaMemcpyDeviceToHost);\n        cudaDeviceSynchronize();\n\n        // for(int i = 0; i<_sampling_num; i++)\n        // {\n        //     if(outputs[i]>0.5)\n        //     {\n        //         cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n        //     }\n        // }\n\n        for(int i = 0; i<_sampling_num; i++)\n        {\n            _return_cost[i] = 0.0;\n            for(int j = 0; j<_JDOF; j++)\n            {\n                for(int k = 0; k<_time_window; k++)\n                {\n                    _return_cost[i] = _return_cost[i] + pow(0.9,k) * cost_jointlimit[k + (_time_window*j) + (_time_window*_JDOF*i)];\n                }\n                // if(j == _JDOF-1)\n                // {\n                //     _return_cost[i] = _return_cost[i] / _JDOF;\n                // }\n            }\n            // cout<<\"_return_cost[\"<<i<<\"] : \"<<_return_cost[i]<<endl;\n\n            for(int j = 0 ; j<_time_window; j++)\n            {\n                _return_cost[i] = _return_cost[i] +  pow(0.9,j) * cost_xerr[i*_time_window + j];\n            }\n            if(found_goal_list[i] == 1)\n            {\n                if(outputs[i] >= 0.5)\n                {\n                    found_goal_list[i] = 0;\n                }\n            }\n            if(outputs[i] > 0.5)\n            {\n                _return_cost[i] = _return_cost[i] + outputs[i] * 100000000.0;\n            }\n            _return_cost[i] = _return_cost[i] / _JDOF;\n            // cout<<\"outputs[\"<<i<<\"] : \"<<outputs[i]<<endl;\n            if(found_goal_list[i] == 1)\n            {\n                found_goal = 1;\n                // cout<<\"??\"<<endl;\n                // _return_cost[i] = _return_cost[i];\n            }\n            // _time_window - _dt2_window\n            // else\n            // {\n            //     _return_cost[i] = _return_cost[i] + 100.0;\n            // }\n        }\n        if(found_goal == 1)\n        {\n            _min_cost = 1000000000000000.0;\n            weight_sum = 0.0;\n            for(int i = 0; i<_sampling_num; i++)\n            {\n                if(found_goal_list[i] == 1)\n                {\n                    if(_min_cost > _cost[i])\n                    {\n                        _min_cost = _cost[i];\n                        _min_sol = i;\n                    }\n                }\n            }\n            for(int i = 0; i<_JDOF; i++)\n            {\n                // d[i] = d[i-1] + d[i]; // 속도\n                // e[i]    // 위치\n                // returnArray[(_JDOF*2)+i] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n                // returnArray[_JDOF+i] = _qdot_des[i] + (returnArray[(_JDOF*2)+i] * _dt_cuda);\n                // returnArray[i] = _q_des[i] + (returnArray[_JDOF+i] * _dt_cuda);\n                for(int j = 0; j<10; j++)\n                {\n                    returnArray[i*10+j+1] = e[_min_sol*_time_window*_JDOF+j+i*_time_window]; // 위치\n                    returnArray[70+i*10+j+1] = d[_min_sol*_time_window*_JDOF+j+i*_time_window]; //속도\n                }\n                // returnArray[]\n                _q_des[i] = e[_min_sol*_time_window*_JDOF+9+i*_time_window];\n                _qdot_des[i] = d[_min_sol*_time_window*_JDOF+9+i*_time_window];\n                cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n            }\n            // cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n            cout<<\"_min_sol : \"<<_min_sol<<endl;\n            returnArray[0] = 1;\n        }\n        else\n        {\n            _min_cost = 1000000000000000.0;\n            weight_sum = 0.0;\n\n            for(int i = 0; i<_sampling_num; i++)\n            {\n                _cost[i] = _return_cost[i];\n                if(_min_cost > _cost[i])\n                {\n                    _min_cost = _cost[i];\n                }\n            }\n            memset(_weighted_A, 0, _JDOF * sizeof(double));\n\n            for(int i = 0; i<_sampling_num; i++)\n            {\n                _cost[i] = _cost[i] - _min_cost;\n                if(_cost[i]<100)\n                {\n                    _cost[i] = exp(-_cost[i]);\t\t\n                    weight_sum = weight_sum + _cost[i];\n                    for(int j = 0; j<_JDOF; j++)\n                    {\n                        _weighted_A[j] = _weighted_A[j] + (_cost[i] * _matrix_for_cuda[_JDOF*_time_window*i + _time_window*j]);\n                    }\n                }\n            }\n            for(int j = 0; j<_JDOF; j++)\n            {\n                _weighted_A[j] /=  weight_sum;\n                _A[j] = _weighted_A[j];\n                // if(_A[j] > 10.0)\n                // {\n                //     _A[j] = 10.0;\n                // }\n                // else if(_A[j] < -10.0)\n                // {\n                //     _A[j] = -10.0;\n                // }\n            }\n            \n            for(int i = 0; i<_JDOF; i++)\n            {\n                returnArray[(_JDOF*2)+i+1] = _weighted_A[i] * (1+_dt_cuda2[0]-_dt_cuda);\n                returnArray[_JDOF+i+1] = _qdot_des[i] + (returnArray[(_JDOF*2)+i+1] * _dt_cuda);\n                returnArray[i+1] = _q_des[i] + (returnArray[_JDOF+i+1] * _dt_cuda);\n\n                _q_des[i] = returnArray[i+1];\n                _qdot_des[i] = returnArray[_JDOF+i+1];\n                cout<<\"_q_des[\"<<i<<\"] : \"<<_q_des[i]<<endl;\n            }\n            returnArray[0] = 0;\n        }\n    }\n}\n\nvoid CudaTest::load_weight()\n{\n    #if _nodes_cuda == 32\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_4[\"<<i<<\"].txt\";\n        }\n    }\n    #elif _nodes_cuda == 64\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_3[\"<<i<<\"].txt\";\n        } \n    }\n    #elif _nodes_cuda == 100\n    {\n        for(int i = 0; i<6; i++)\n        {\n            filename_NN[i] << \"/home/kist/KDH/Backup/franka_panda_2.0.0/weight/best_model_panda_0427_2[\"<<i<<\"].txt\";\n        } \n    }\n    #else\n    #endif\n    \n    weight0.open(filename_NN[0].str());\n    for(int i = 0; i<_JDOF ; i++)\n    {\n        for(int j = 0; j<_nodes_cuda ; j++)\n        {\n            weight0 >> weights0[i*_nodes_cuda + j];\n        }\n    }\n    weight0.close();\n    \n    weight0.open(filename_NN[1].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights1[i];\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[2].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        for(int j = 0; j<_nodes_cuda ; j++)\n        {\n            weight0 >> weights2[i*_nodes_cuda + j];\n        }\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[3].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights3[i];\n    }\n    weight0.close();\n\n    weight0.open(filename_NN[4].str());\n    for(int i = 0; i<_nodes_cuda ; i++)\n    {\n        weight0 >> weights4[i];\n    }\n    weight0.close();\n    weight0.open(filename_NN[5].str());\n    weight0 >> weights5[0];\n    weight0.close();\n}\n\nvoid CudaTest::cpu_memory_save()\n{\n    memset(cost_jointlimit, 0, N * sizeof(double));\n    memset(_mean_matrix, 0, N * sizeof(double));\n    memset(d, 0, N * sizeof(double));\n    memset(e, 0, N * sizeof(double));\n    memset(f, 0, N * sizeof(double));\n    memset(_matrix_for_cuda, 0, N * sizeof(double));\n\n    memset(position_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(orientation_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(velocity_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n    memset(velocity_ori_EE, 0, 3 * _sampling_num * _time_window * sizeof(double));\n\n    memset(FK_d, 0, 9 * sizeof(double));\n    memset(FK_a, 0, 9 * sizeof(double));\n    memset(FK_alpha, 0, 9 * sizeof(double));\n    \n    memset(_return_cost, 0, _sampling_num * sizeof(double));\n    memset(_cost, 0, _sampling_num * sizeof(double));\n\n    memset(_max_joint_position, 0, _JDOF * sizeof(double));\n    memset(_min_joint_position, 0, _JDOF * sizeof(double));\n    memset(_q_des, 0, _JDOF * sizeof(double));\n    memset(_qdot_des, 0, _JDOF * sizeof(double));\n    memset(_A, 0, _JDOF * sizeof(double));\n    memset(_weighted_A, 0, _JDOF * sizeof(double));\n    memset(_hat_min_joint_position, 0, _JDOF * sizeof(double));\n    memset(_hat_max_joint_position, 0, _JDOF * sizeof(double));\n    \n    memset(inputs, 0, _JDOF * _sampling_num * sizeof(double));\n    memset(weights0, 0, _JDOF*_nodes_cuda * sizeof(double));\n    memset(weights1, 0, _nodes_cuda * sizeof(double));\n    memset(weights2, 0, _nodes_cuda*_nodes_cuda * sizeof(double));\n    memset(weights3, 0, _nodes_cuda * sizeof(double));\n    memset(weights4, 0, _nodes_cuda * sizeof(double));\n    // memset(weights5, 0, OUTPUT_SIZE * sizeof(double));\n    memset(outputs, 0, _sampling_num * sizeof(double));\n    memset(returnArray, 0, _JDOF*3 * sizeof(double));\n\n    memset(_prev_x, 0, 3 * sizeof(double));\n    memset(_prev_r, 0, 3 * sizeof(double));\n\n    memset(jacobian, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n    memset(jacobian_transpose, 0, _JDOF * 6 * _sampling_num *sizeof(double));\n    memset(manipulability, 0, _sampling_num * _time_window *sizeof(double));\n\n    \n    weights5[0] = 0.0;\n    position_sec1[0] = 0.0;\n    position_sec2[0] = 0.0;\n    velocity_lim[0] = 0.0;\n}\n\nvoid CudaTest::cuda_memory_save()\n{\n    cudaMalloc((void**)&dev__A, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev__mean_matrix, N*sizeof(double));\n    cudaMalloc((void**)&dev__matrix_for_cuda, N*sizeof(double));\n    // cudaMalloc((void**)&dev__prev_matrix_for_cuda, N*sizeof(double));\n    cudaMalloc((void**)&dev_states, N*sizeof(double));\n\n    // cudaMalloc((void**)&dev_a, N * sizeof(double));\n    cudaMalloc((void**)&dev_b, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_c, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_pos_tmp, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_d, N * sizeof(double));\n    cudaMalloc((void**)&dev_e, N * sizeof(double));\n    cudaMalloc((void**)&dev_cost, N * sizeof(double));\n    cudaMalloc((void**)&dev_cost_x, _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_q_goal, _JDOF*sizeof(double));\n    cudaMalloc((void**)&dev_x_goal, 6*sizeof(double));\n    cudaMalloc((void**)&dev_rot_goal, 9*sizeof(double));\n    cudaMalloc((void**)&dev_rot_goal_T, 9*sizeof(double));\n\n    cudaMalloc((void**)&d_weights0, _JDOF * _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights1, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights2, _nodes_cuda * _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights3, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights4, _nodes_cuda * sizeof(double));\n    cudaMalloc((void**)&d_weights5, OUTPUT_SIZE * sizeof(double));\n    cudaMalloc((void**)&d_outputs, _sampling_num * sizeof(double));\n\n    cudaMalloc((void**)&hidden0, _nodes_cuda * _JDOF * sizeof(double));\n    cudaMalloc((void**)&hidden1, _nodes_cuda * _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_inputs, _JDOF * _sampling_num * sizeof(double));\n    cudaMalloc((void**)&dev_min_joint_position_for_NN, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_max_joint_position_for_NN, _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_joint_min_limit_for_cost, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_joint_max_limit_for_cost, _JDOF * sizeof(double));\n    cudaMalloc((void**)&dev_cen_joint_position, _JDOF * sizeof(double));\n\n    cudaMalloc((void**)&dev_position_sec1, sizeof(double));\n    cudaMalloc((void**)&dev_position_sec2, sizeof(double));\n    cudaMalloc((void**)&dev_velocity_lim, sizeof(double));\n\n    // cudaMalloc((void**)&_dev_jacobian, N * 6 * sizeof(double));\n    // cudaMalloc((void**)&dev_position_EE, _sampling_num * _time_window * 3 * sizeof(double));\n    // cudaMalloc((void**)&dev_orientation_EE, _sampling_num * _time_window * 3 * sizeof(double));\n    cudaMalloc((void**)&dev_position_EE, 3 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_orientation_EE, 3 * _sampling_num * _time_window * sizeof(double));\n\n    cudaMalloc((void**)&dev_velocity_EE, 3 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_velocity_ori_EE, 3 * _sampling_num * _time_window * sizeof(double));\n\n    cudaMalloc((void**)&dev_prev_position_EE, 3 * sizeof(double));\n    cudaMalloc((void**)&dev_prev_orientation_EE, 3 * sizeof(double));\n\n    cudaMalloc((void**)&dev_FK_a, 9 * sizeof(double));\n    cudaMalloc((void**)&dev_FK_d, 9 * sizeof(double));\n    cudaMalloc((void**)&dev_FK_alpha, 9 * sizeof(double));\n\n    cudaMalloc((void**)&dev_rot_EE, 9 * _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_jacobian, _JDOF * 6 * _sampling_num  * sizeof(double));\n    cudaMalloc((void**)&dev_jacobian_transpose, _JDOF * 6 * _sampling_num * sizeof(double));\n    cudaMalloc((void**)&dev_manipulability, _sampling_num * _time_window * sizeof(double));\n    cudaMalloc((void**)&dev_now_pos_gap, sizeof(double)); \n    cudaMalloc((void**)&dev_dt_cuda2, sizeof(double));\n    cudaMalloc((void**)&dev_found_sol, _sampling_num * sizeof(double));\n\n    \n}\n\nvoid CudaTest::cuda_memory_free()\n{    \n    cudaFree(dev__A);\n    cudaFree(dev__mean_matrix);\n    cudaFree(dev__matrix_for_cuda);\n    // cudaFree(dev__prev_matrix_for_cuda);\n    cudaFree(dev_states);\n\n    cudaFree(dev_b);\n    cudaFree(dev_c);\n    cudaFree(dev_d);\n    cudaFree(dev_e);\n    cudaFree(dev_cost);\n    cudaFree(dev_cost_x);\n    \n    cudaFree(dev_q_goal);\n    cudaFree(dev_x_goal);\n    cudaFree(dev_rot_goal);\n    cudaFree(dev_rot_goal_T);\n\n    cudaFree(d_weights0);\n    cudaFree(d_weights1);\n    cudaFree(d_weights2);\n    cudaFree(d_weights3);\n    cudaFree(d_weights4);\n    cudaFree(d_weights5);\n    cudaFree(d_outputs);\n\n    cudaFree(hidden0);\n    cudaFree(hidden1);\n\n    cudaFree(dev_inputs);\n    cudaFree(dev_min_joint_position_for_NN);\n    cudaFree(dev_max_joint_position_for_NN);\n\n    cudaFree(dev_joint_min_limit_for_cost);\n    cudaFree(dev_joint_max_limit_for_cost);\n    cudaFree(dev_cen_joint_position);\n\n    cudaFree(dev_position_sec1);\n    cudaFree(dev_position_sec2);\n    cudaFree(dev_velocity_lim);\n\n    // cudaFree(_dev_jacobian);\n    cudaFree(dev_position_EE);\n    cudaFree(dev_orientation_EE);\n\n    cudaFree(dev_FK_a);\n    cudaFree(dev_FK_d);\n    cudaFree(dev_FK_alpha);\n\n    cudaFree(dev_jacobian);\n    cudaFree(dev_jacobian_transpose);\n\n    cudaError_t error = cudaGetLastError();\n    if (error != cudaSuccess) {\n        printf(\"CUDA error: %s\\n\", cudaGetErrorString(error));\n        // 에러 처리 로직을 추가해야 합니다.\n    }\n}\n\nvoid CudaTest::initialize()\n{\n    // position_sec1[0] = 1.0/_time_window; //(32기준 0.03125)\n    // position_sec2[0] = 0.2/_time_window; //(32기준 0.00625)\n    // velocity_lim[0] = sqrt((double)_time_window)/5.0; //(32기준 0.565685425)\n\n    // velocity_lim[0] = sqrt((double)_time_window)/10.0; //(32기준 0.565685425)\n\n    position_sec1[0] = 0.03125;\n    position_sec2[0] = 0.005;\n    velocity_lim[0] = 0.8;\n\n    // position_sec1[0] = 0.03125;\n    // position_sec2[0] = 0.00625;\n    // velocity_lim[0] = 1.0;\n\t\n    // numBlocks = N / THREADS_PER_BLOCK;\n    // numBlocks2 = (N / _time_window) / THREADS_PER_BLOCK2;\n\n\n    // panda_arm_hand.urdf // panda_arm_hand.xml model\n\t// _min_joint_position[0] = -2.9671;\n\t// _min_joint_position[1] = -1.8326;\n\t// _min_joint_position[2] = -2.9671;\n\t// _min_joint_position[3] = -3.1416;\n\t// _min_joint_position[4] = -2.9671;\n\t// _min_joint_position[5] = -0.0873;\n\t// _min_joint_position[6] = -2.9671;\n\n\t// _max_joint_position[0] = 2.9671;\n\t// _max_joint_position[1] = 1.8326;\n\t// _max_joint_position[2] = 2.9671;\n\t// _max_joint_position[3] = 0.0;\n\t// _max_joint_position[4] = 2.9671;\n\t// _max_joint_position[5] = 3.8223;\n\t// _max_joint_position[6] = 2.9671;\n\n\n\n    // fr3.urdf // fr3.xml model\n    _min_joint_position[0] = -2.8973;\n\t_min_joint_position[1] = -1.7628;\n\t_min_joint_position[2] = -2.8973;\n\t_min_joint_position[3] = -3.0718;\n\t_min_joint_position[4] = -2.8973;\n\t_min_joint_position[5] = -0.0175;\n\t_min_joint_position[6] = -2.8973;\n\n\t_max_joint_position[0] = 2.8973;\n\t_max_joint_position[1] = 1.7628;\n\t_max_joint_position[2] = 2.8973;\n\t_max_joint_position[3] = -0.0698;\n\t_max_joint_position[4] = 2.8973;\n\t_max_joint_position[5] = 3.7525;\n\t_max_joint_position[6] = 2.8973;\n\n\n\n    //k = 0.1\n    // _hat_min_joint_position[0] = -2.37368;\n    // _hat_max_joint_position[0] = 2.37368;\n\n    // _hat_min_joint_position[1] = -1.46608;\n    // _hat_max_joint_position[1] = 1.46608;\n\n    // _hat_min_joint_position[2] = -2.37368;\n    // _hat_max_joint_position[2] = 2.37368;\n\n    // _hat_min_joint_position[3] = −2.82744;\n    // _hat_max_joint_position[3] = -0.31416;\n\n    // _hat_min_joint_position[4] = -2.37368;\n    // _hat_max_joint_position[4] = 2.37368;\n\n    // _hat_min_joint_position[5] = 0.30366;\n    // _hat_max_joint_position[5] = 3.43134;\n\n    // _hat_min_joint_position[6] = -2.37368;\n    // _hat_max_joint_position[6] = 2.37368;\n\n\n\n    for(int i = 0; i<_JDOF; i++)\n    {\n        _hat_min_joint_position[i] = _min_joint_position[i] + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        _hat_max_joint_position[i] = _max_joint_position[i] - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        // _hat_min_joint_position[i] = _min_joint_position[i];// + 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        // _hat_max_joint_position[i] = _max_joint_position[i];// - 0.1 * (_max_joint_position[i] - _min_joint_position[i]);\n        _cen_joint_position[i] = (_max_joint_position[i] + _min_joint_position[i]) / 2.0;\n    }\n\n    FK_a[0] = 0.0;\n    FK_d[0] = 0.343;\n    FK_alpha[0] = 0.0;\n\n    FK_a[1] = 0.0;\n    FK_d[1] = 0.0;\n    FK_alpha[1] = -PI_CUDA/2.0;\n\n    FK_a[2] = 0.0;\n    FK_d[2] = 0.316;\n    FK_alpha[2] = PI_CUDA/2.0;\n\n    FK_a[3] = 0.0825;\n    FK_d[3] = 0.0;\n    FK_alpha[3] = PI_CUDA/2.0;\n\n    FK_a[4] = -0.0825;\n    FK_d[4] = 0.384;\n    FK_alpha[4] = -PI_CUDA/2.0;\n\n    FK_a[5] = 0.0;\n    FK_d[5] = 0.0;\n    FK_alpha[5] = PI_CUDA/2.0;\n\n    FK_a[6] = 0.088;\n    FK_d[6] = 0.0;\n    FK_alpha[6] = PI_CUDA/2.0;\n\n    FK_a[7] = 0.0;\n    FK_d[7] = 0.107;\n    FK_alpha[7] = 0.0;\n\n    FK_a[8] = 0.0;\n    FK_d[8] = 0.1034;\n    FK_alpha[8] = 0.0;\n}"
        }
    ]
}
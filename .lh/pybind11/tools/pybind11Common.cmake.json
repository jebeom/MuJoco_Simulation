{
    "sourceFile": "pybind11/tools/pybind11Common.cmake",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1691477793683,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1691477801675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,13 +165,13 @@\n \n # Check to see which Python mode we are in, new, old, or no python\n if(PYBIND11_NOPYTHON)\n   set(_pybind11_nopython ON)\n-# elseif(\n-#   PYBIND11_FINDPYTHON\n-#   OR Python_FOUND\n-#   OR Python2_FOUND\n-#   OR Python3_FOUND)\n+elseif(\n+  PYBIND11_FINDPYTHON\n+  OR Python_FOUND\n+  OR Python2_FOUND\n+  OR Python3_FOUND)\n   # New mode\n   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n \n else()\n"
                },
                {
                    "date": 1691477809636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,385 @@\n+#[======================================================[.rst\n+\n+Adds the following targets::\n+\n+    pybind11::pybind11 - link to headers and pybind11\n+    pybind11::module - Adds module links\n+    pybind11::embed - Adds embed links\n+    pybind11::lto - Link time optimizations (manual selection)\n+    pybind11::thin_lto - Link time optimizations (manual selection)\n+    pybind11::python_link_helper - Adds link to Python libraries\n+    pybind11::windows_extras - MSVC bigobj and mp for building multithreaded\n+    pybind11::opt_size - avoid optimizations that increase code size\n+\n+Adds the following functions::\n+\n+    pybind11_strip(target) - strip target after building on linux/macOS\n+    pybind11_find_import(module) - See if a module is installed.\n+\n+#]======================================================]\n+\n+# CMake 3.10 has an include_guard command, but we can't use that yet\n+# include_guard(global) (pre-CMake 3.10)\n+if(TARGET pybind11::lto)\n+  return()\n+endif()\n+\n+# If we are in subdirectory mode, all IMPORTED targets must be GLOBAL. If we\n+# are in CONFIG mode, they should be \"normal\" targets instead.\n+# In CMake 3.11+ you can promote a target to global after you create it,\n+# which might be simpler than this check.\n+get_property(\n+  is_config\n+  TARGET pybind11::headers\n+  PROPERTY IMPORTED)\n+if(NOT is_config)\n+  set(optional_global GLOBAL)\n+endif()\n+\n+# If not run in Python mode, we still would like this to at least\n+# include pybind11's include directory:\n+set(pybind11_INCLUDE_DIRS\n+    \"${pybind11_INCLUDE_DIR}\"\n+    CACHE INTERNAL \"Include directory for pybind11 (Python not requested)\")\n+\n+# --------------------- Shared targets ----------------------------\n+\n+# Build an interface library target:\n+add_library(pybind11::pybind11 IMPORTED INTERFACE ${optional_global})\n+set_property(\n+  TARGET pybind11::pybind11\n+  APPEND\n+  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::headers)\n+\n+# Build a module target:\n+add_library(pybind11::module IMPORTED INTERFACE ${optional_global})\n+set_property(\n+  TARGET pybind11::module\n+  APPEND\n+  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n+\n+# Build an embed library target:\n+add_library(pybind11::embed IMPORTED INTERFACE ${optional_global})\n+set_property(\n+  TARGET pybind11::embed\n+  APPEND\n+  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n+\n+# --------------------------- link helper ---------------------------\n+\n+add_library(pybind11::python_link_helper IMPORTED INTERFACE ${optional_global})\n+\n+if(CMAKE_VERSION VERSION_LESS 3.13)\n+  # In CMake 3.11+, you can set INTERFACE properties via the normal methods, and\n+  # this would be simpler.\n+  set_property(\n+    TARGET pybind11::python_link_helper\n+    APPEND\n+    PROPERTY INTERFACE_LINK_LIBRARIES \"$<$<PLATFORM_ID:Darwin>:-undefined dynamic_lookup>\")\n+else()\n+  # link_options was added in 3.13+\n+  # This is safer, because you are ensured the deduplication pass in CMake will not consider\n+  # these separate and remove one but not the other.\n+  set_property(\n+    TARGET pybind11::python_link_helper\n+    APPEND\n+    PROPERTY INTERFACE_LINK_OPTIONS \"$<$<PLATFORM_ID:Darwin>:LINKER:-undefined,dynamic_lookup>\")\n+endif()\n+\n+# ------------------------ Windows extras -------------------------\n+\n+add_library(pybind11::windows_extras IMPORTED INTERFACE ${optional_global})\n+\n+if(MSVC) # That's also clang-cl\n+  # /bigobj is needed for bigger binding projects due to the limit to 64k\n+  # addressable sections\n+  set_property(\n+    TARGET pybind11::windows_extras\n+    APPEND\n+    PROPERTY INTERFACE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:/bigobj>)\n+\n+  # /MP enables multithreaded builds (relevant when there are many files) for MSVC\n+  if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"MSVC\") # no Clang no Intel\n+    if(CMAKE_VERSION VERSION_LESS 3.11)\n+      set_property(\n+        TARGET pybind11::windows_extras\n+        APPEND\n+        PROPERTY INTERFACE_COMPILE_OPTIONS $<$<NOT:$<CONFIG:Debug>>:/MP>)\n+    else()\n+      # Only set these options for C++ files.  This is important so that, for\n+      # instance, projects that include other types of source files like CUDA\n+      # .cu files don't get these options propagated to nvcc since that would\n+      # cause the build to fail.\n+      set_property(\n+        TARGET pybind11::windows_extras\n+        APPEND\n+        PROPERTY INTERFACE_COMPILE_OPTIONS\n+                 $<$<NOT:$<CONFIG:Debug>>:$<$<COMPILE_LANGUAGE:CXX>:/MP>>)\n+    endif()\n+  endif()\n+endif()\n+\n+# ----------------------- Optimize binary size --------------------------\n+\n+add_library(pybind11::opt_size IMPORTED INTERFACE ${optional_global})\n+\n+if(MSVC)\n+  set(PYBIND11_OPT_SIZE /Os)\n+else()\n+  set(PYBIND11_OPT_SIZE -Os)\n+endif()\n+\n+set_property(\n+  TARGET pybind11::opt_size\n+  APPEND\n+  PROPERTY INTERFACE_COMPILE_OPTIONS $<$<CONFIG:Release>:${PYBIND11_OPT_SIZE}>\n+           $<$<CONFIG:MinSizeRel>:${PYBIND11_OPT_SIZE}>\n+           $<$<CONFIG:RelWithDebInfo>:${PYBIND11_OPT_SIZE}>)\n+\n+# ----------------------- Legacy option --------------------------\n+\n+# Warn or error if old variable name used\n+if(PYBIND11_CPP_STANDARD)\n+  string(REGEX MATCH [[..$]] VAL \"${PYBIND11_CPP_STANDARD}\")\n+  if(CMAKE_CXX_STANDARD)\n+    if(NOT CMAKE_CXX_STANDARD STREQUAL VAL)\n+      message(WARNING \"CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} does not match \"\n+                      \"PYBIND11_CPP_STANDARD=${PYBIND11_CPP_STANDARD}, \"\n+                      \"please remove PYBIND11_CPP_STANDARD from your cache\")\n+    endif()\n+  else()\n+    set(supported_standards 11 14 17 20)\n+    if(\"${VAL}\" IN_LIST supported_standards)\n+      message(WARNING \"USE -DCMAKE_CXX_STANDARD=${VAL} instead of PYBIND11_CPP_STANDARD\")\n+      set(CMAKE_CXX_STANDARD\n+          ${VAL}\n+          CACHE STRING \"From PYBIND11_CPP_STANDARD\")\n+    else()\n+      message(FATAL_ERROR \"PYBIND11_CPP_STANDARD should be replaced with CMAKE_CXX_STANDARD \"\n+                          \"(last two chars: ${VAL} not understood as a valid CXX std)\")\n+    endif()\n+  endif()\n+endif()\n+\n+# --------------------- Python specifics -------------------------\n+\n+# Check to see which Python mode we are in, new, old, or no python\n+# if(PYBIND11_NOPYTHON)\n+#   set(_pybind11_nopython ON)\n+# elseif(\n+#   PYBIND11_FINDPYTHON\n+#   OR Python_FOUND\n+#   OR Python2_FOUND\n+#   OR Python3_FOUND)\n+#   # New mode\n+#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n+\n+# else()\n+\n+#   # Classic mode\n+#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n+\n+# endif()\n+\n+# --------------------- pybind11_find_import -------------------------------\n+\n+if(NOT _pybind11_nopython)\n+  # Check to see if modules are importable. Use REQUIRED to force an error if\n+  # one of the modules is not found. <package_name>_FOUND will be set if the\n+  # package was found (underscores replace dashes if present). QUIET will hide\n+  # the found message, and VERSION will require a minimum version. A successful\n+  # find will cache the result.\n+  function(pybind11_find_import PYPI_NAME)\n+    # CMake variables need underscores (PyPI doesn't care)\n+    string(REPLACE \"-\" \"_\" NORM_PYPI_NAME \"${PYPI_NAME}\")\n+\n+    # Return if found previously\n+    if(${NORM_PYPI_NAME}_FOUND)\n+      return()\n+    endif()\n+\n+    set(options \"REQUIRED;QUIET\")\n+    set(oneValueArgs \"VERSION\")\n+    cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"\" ${ARGN})\n+\n+    if(ARG_REQUIRED)\n+      set(status_level FATAL_ERROR)\n+    else()\n+      set(status_level WARNING)\n+    endif()\n+\n+    execute_process(\n+      COMMAND\n+        ${${_Python}_EXECUTABLE} -c\n+        \"from pkg_resources import get_distribution; print(get_distribution('${PYPI_NAME}').version)\"\n+      RESULT_VARIABLE RESULT_PRESENT\n+      OUTPUT_VARIABLE PKG_VERSION\n+      ERROR_QUIET)\n+\n+    string(STRIP \"${PKG_VERSION}\" PKG_VERSION)\n+\n+    # If a result is present, this failed\n+    if(RESULT_PRESENT)\n+      set(${NORM_PYPI_NAME}_FOUND\n+          ${NORM_PYPI_NAME}-NOTFOUND\n+          CACHE INTERNAL \"\")\n+      # Always warn or error\n+      message(\n+        ${status_level}\n+        \"Missing: ${PYPI_NAME} ${ARG_VERSION}\\nTry: ${${_Python}_EXECUTABLE} -m pip install ${PYPI_NAME}\"\n+      )\n+    else()\n+      if(ARG_VERSION AND PKG_VERSION VERSION_LESS ARG_VERSION)\n+        message(\n+          ${status_level}\n+          \"Version incorrect: ${PYPI_NAME} ${PKG_VERSION} found, ${ARG_VERSION} required - try upgrading\"\n+        )\n+      else()\n+        set(${NORM_PYPI_NAME}_FOUND\n+            YES\n+            CACHE INTERNAL \"\")\n+        set(${NORM_PYPI_NAME}_VERSION\n+            ${PKG_VERSION}\n+            CACHE INTERNAL \"\")\n+      endif()\n+      if(NOT ARG_QUIET)\n+        message(STATUS \"Found ${PYPI_NAME} ${PKG_VERSION}\")\n+      endif()\n+    endif()\n+    if(NOT ARG_VERSION OR (NOT PKG_VERSION VERSION_LESS ARG_VERSION))\n+      # We have successfully found a good version, cache to avoid calling again.\n+    endif()\n+  endfunction()\n+endif()\n+\n+# --------------------- LTO -------------------------------\n+\n+include(CheckCXXCompilerFlag)\n+\n+# Checks whether the given CXX/linker flags can compile and link a cxx file.\n+# cxxflags and linkerflags are lists of flags to use.  The result variable is a\n+# unique variable name for each set of flags: the compilation result will be\n+# cached base on the result variable.  If the flags work, sets them in\n+# cxxflags_out/linkerflags_out internal cache variables (in addition to\n+# ${result}).\n+function(_pybind11_return_if_cxx_and_linker_flags_work result cxxflags linkerflags cxxflags_out\n+         linkerflags_out)\n+  set(CMAKE_REQUIRED_LIBRARIES ${linkerflags})\n+  check_cxx_compiler_flag(\"${cxxflags}\" ${result})\n+  if(${result})\n+    set(${cxxflags_out}\n+        \"${cxxflags}\"\n+        PARENT_SCOPE)\n+    set(${linkerflags_out}\n+        \"${linkerflags}\"\n+        PARENT_SCOPE)\n+  endif()\n+endfunction()\n+\n+function(_pybind11_generate_lto target prefer_thin_lto)\n+  if(MINGW)\n+    message(STATUS \"${target} disabled (problems with undefined symbols for MinGW for now)\")\n+    return()\n+  endif()\n+\n+  if(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n+    set(cxx_append \"\")\n+    set(linker_append \"\")\n+    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND NOT APPLE)\n+      # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it\n+      set(linker_append \";$<$<CONFIG:MinSizeRel>:-O3>\")\n+    elseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\" AND NOT MINGW)\n+      set(cxx_append \";-fno-fat-lto-objects\")\n+    endif()\n+\n+    if(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc64le\" OR CMAKE_SYSTEM_PROCESSOR MATCHES \"mips64\")\n+      set(NO_FLTO_ARCH TRUE)\n+    else()\n+      set(NO_FLTO_ARCH FALSE)\n+    endif()\n+\n+    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"\n+       AND prefer_thin_lto\n+       AND NOT NO_FLTO_ARCH)\n+      _pybind11_return_if_cxx_and_linker_flags_work(\n+        HAS_FLTO_THIN \"-flto=thin${cxx_append}\" \"-flto=thin${linker_append}\"\n+        PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n+    endif()\n+\n+    if(NOT HAS_FLTO_THIN AND NOT NO_FLTO_ARCH)\n+      _pybind11_return_if_cxx_and_linker_flags_work(\n+        HAS_FLTO \"-flto${cxx_append}\" \"-flto${linker_append}\" PYBIND11_LTO_CXX_FLAGS\n+        PYBIND11_LTO_LINKER_FLAGS)\n+    endif()\n+  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n+    # Intel equivalent to LTO is called IPO\n+    _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO \"-ipo\" \"-ipo\"\n+                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n+  elseif(MSVC)\n+    # cmake only interprets libraries as linker flags when they start with a - (otherwise it\n+    # converts /LTCG to \\LTCG as if it was a Windows path).  Luckily MSVC supports passing flags\n+    # with - instead of /, even if it is a bit non-standard:\n+    _pybind11_return_if_cxx_and_linker_flags_work(HAS_MSVC_GL_LTCG \"/GL\" \"-LTCG\"\n+                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n+  endif()\n+\n+  # Enable LTO flags if found, except for Debug builds\n+  if(PYBIND11_LTO_CXX_FLAGS)\n+    # CONFIG takes multiple values in CMake 3.19+, until then we have to use OR\n+    set(is_debug \"$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>\")\n+    set(not_debug \"$<NOT:${is_debug}>\")\n+    set(cxx_lang \"$<COMPILE_LANGUAGE:CXX>\")\n+    if(MSVC AND CMAKE_VERSION VERSION_LESS 3.11)\n+      set(genex \"${not_debug}\")\n+    else()\n+      set(genex \"$<AND:${not_debug},${cxx_lang}>\")\n+    endif()\n+    set_property(\n+      TARGET ${target}\n+      APPEND\n+      PROPERTY INTERFACE_COMPILE_OPTIONS \"$<${genex}:${PYBIND11_LTO_CXX_FLAGS}>\")\n+    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n+      message(STATUS \"${target} enabled\")\n+    endif()\n+  else()\n+    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n+      message(STATUS \"${target} disabled (not supported by the compiler and/or linker)\")\n+    endif()\n+  endif()\n+\n+  if(PYBIND11_LTO_LINKER_FLAGS)\n+    if(CMAKE_VERSION VERSION_LESS 3.11)\n+      set_property(\n+        TARGET ${target}\n+        APPEND\n+        PROPERTY INTERFACE_LINK_LIBRARIES \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n+    else()\n+      set_property(\n+        TARGET ${target}\n+        APPEND\n+        PROPERTY INTERFACE_LINK_OPTIONS \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n+    endif()\n+  endif()\n+endfunction()\n+\n+add_library(pybind11::lto IMPORTED INTERFACE ${optional_global})\n+_pybind11_generate_lto(pybind11::lto FALSE)\n+\n+add_library(pybind11::thin_lto IMPORTED INTERFACE ${optional_global})\n+_pybind11_generate_lto(pybind11::thin_lto TRUE)\n+\n+# ---------------------- pybind11_strip -----------------------------\n+\n+function(pybind11_strip target_name)\n+  # Strip unnecessary sections of the binary on Linux/macOS\n+  if(CMAKE_STRIP)\n+    if(APPLE)\n+      set(x_opt -x)\n+    endif()\n+\n+    add_custom_command(\n+      TARGET ${target_name}\n+      POST_BUILD\n+      COMMAND ${CMAKE_STRIP} ${x_opt} $<TARGET_FILE:${target_name}>)\n+  endif()\n+endfunction()\n"
                },
                {
                    "date": 1691477819586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,405 +163,20 @@\n \n # --------------------- Python specifics -------------------------\n \n # Check to see which Python mode we are in, new, old, or no python\n-# if(PYBIND11_NOPYTHON)\n-#   set(_pybind11_nopython ON)\n+if(PYBIND11_NOPYTHON)\n+  set(_pybind11_nopython ON)\n # elseif(\n #   PYBIND11_FINDPYTHON\n #   OR Python_FOUND\n #   OR Python2_FOUND\n #   OR Python3_FOUND)\n #   # New mode\n #   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n \n-# else()\n-\n-#   # Classic mode\n-#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n-\n-# endif()\n-\n-# --------------------- pybind11_find_import -------------------------------\n-\n-if(NOT _pybind11_nopython)\n-  # Check to see if modules are importable. Use REQUIRED to force an error if\n-  # one of the modules is not found. <package_name>_FOUND will be set if the\n-  # package was found (underscores replace dashes if present). QUIET will hide\n-  # the found message, and VERSION will require a minimum version. A successful\n-  # find will cache the result.\n-  function(pybind11_find_import PYPI_NAME)\n-    # CMake variables need underscores (PyPI doesn't care)\n-    string(REPLACE \"-\" \"_\" NORM_PYPI_NAME \"${PYPI_NAME}\")\n-\n-    # Return if found previously\n-    if(${NORM_PYPI_NAME}_FOUND)\n-      return()\n-    endif()\n-\n-    set(options \"REQUIRED;QUIET\")\n-    set(oneValueArgs \"VERSION\")\n-    cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"\" ${ARGN})\n-\n-    if(ARG_REQUIRED)\n-      set(status_level FATAL_ERROR)\n-    else()\n-      set(status_level WARNING)\n-    endif()\n-\n-    execute_process(\n-      COMMAND\n-        ${${_Python}_EXECUTABLE} -c\n-        \"from pkg_resources import get_distribution; print(get_distribution('${PYPI_NAME}').version)\"\n-      RESULT_VARIABLE RESULT_PRESENT\n-      OUTPUT_VARIABLE PKG_VERSION\n-      ERROR_QUIET)\n-\n-    string(STRIP \"${PKG_VERSION}\" PKG_VERSION)\n-\n-    # If a result is present, this failed\n-    if(RESULT_PRESENT)\n-      set(${NORM_PYPI_NAME}_FOUND\n-          ${NORM_PYPI_NAME}-NOTFOUND\n-          CACHE INTERNAL \"\")\n-      # Always warn or error\n-      message(\n-        ${status_level}\n-        \"Missing: ${PYPI_NAME} ${ARG_VERSION}\\nTry: ${${_Python}_EXECUTABLE} -m pip install ${PYPI_NAME}\"\n-      )\n-    else()\n-      if(ARG_VERSION AND PKG_VERSION VERSION_LESS ARG_VERSION)\n-        message(\n-          ${status_level}\n-          \"Version incorrect: ${PYPI_NAME} ${PKG_VERSION} found, ${ARG_VERSION} required - try upgrading\"\n-        )\n-      else()\n-        set(${NORM_PYPI_NAME}_FOUND\n-            YES\n-            CACHE INTERNAL \"\")\n-        set(${NORM_PYPI_NAME}_VERSION\n-            ${PKG_VERSION}\n-            CACHE INTERNAL \"\")\n-      endif()\n-      if(NOT ARG_QUIET)\n-        message(STATUS \"Found ${PYPI_NAME} ${PKG_VERSION}\")\n-      endif()\n-    endif()\n-    if(NOT ARG_VERSION OR (NOT PKG_VERSION VERSION_LESS ARG_VERSION))\n-      # We have successfully found a good version, cache to avoid calling again.\n-    endif()\n-  endfunction()\n-endif()\n-\n-# --------------------- LTO -------------------------------\n-\n-include(CheckCXXCompilerFlag)\n-\n-# Checks whether the given CXX/linker flags can compile and link a cxx file.\n-# cxxflags and linkerflags are lists of flags to use.  The result variable is a\n-# unique variable name for each set of flags: the compilation result will be\n-# cached base on the result variable.  If the flags work, sets them in\n-# cxxflags_out/linkerflags_out internal cache variables (in addition to\n-# ${result}).\n-function(_pybind11_return_if_cxx_and_linker_flags_work result cxxflags linkerflags cxxflags_out\n-         linkerflags_out)\n-  set(CMAKE_REQUIRED_LIBRARIES ${linkerflags})\n-  check_cxx_compiler_flag(\"${cxxflags}\" ${result})\n-  if(${result})\n-    set(${cxxflags_out}\n-        \"${cxxflags}\"\n-        PARENT_SCOPE)\n-    set(${linkerflags_out}\n-        \"${linkerflags}\"\n-        PARENT_SCOPE)\n-  endif()\n-endfunction()\n-\n-function(_pybind11_generate_lto target prefer_thin_lto)\n-  if(MINGW)\n-    message(STATUS \"${target} disabled (problems with undefined symbols for MinGW for now)\")\n-    return()\n-  endif()\n-\n-  if(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n-    set(cxx_append \"\")\n-    set(linker_append \"\")\n-    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND NOT APPLE)\n-      # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it\n-      set(linker_append \";$<$<CONFIG:MinSizeRel>:-O3>\")\n-    elseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\" AND NOT MINGW)\n-      set(cxx_append \";-fno-fat-lto-objects\")\n-    endif()\n-\n-    if(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc64le\" OR CMAKE_SYSTEM_PROCESSOR MATCHES \"mips64\")\n-      set(NO_FLTO_ARCH TRUE)\n-    else()\n-      set(NO_FLTO_ARCH FALSE)\n-    endif()\n-\n-    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"\n-       AND prefer_thin_lto\n-       AND NOT NO_FLTO_ARCH)\n-      _pybind11_return_if_cxx_and_linker_flags_work(\n-        HAS_FLTO_THIN \"-flto=thin${cxx_append}\" \"-flto=thin${linker_append}\"\n-        PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n-    endif()\n-\n-    if(NOT HAS_FLTO_THIN AND NOT NO_FLTO_ARCH)\n-      _pybind11_return_if_cxx_and_linker_flags_work(\n-        HAS_FLTO \"-flto${cxx_append}\" \"-flto${linker_append}\" PYBIND11_LTO_CXX_FLAGS\n-        PYBIND11_LTO_LINKER_FLAGS)\n-    endif()\n-  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n-    # Intel equivalent to LTO is called IPO\n-    _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO \"-ipo\" \"-ipo\"\n-                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n-  elseif(MSVC)\n-    # cmake only interprets libraries as linker flags when they start with a - (otherwise it\n-    # converts /LTCG to \\LTCG as if it was a Windows path).  Luckily MSVC supports passing flags\n-    # with - instead of /, even if it is a bit non-standard:\n-    _pybind11_return_if_cxx_and_linker_flags_work(HAS_MSVC_GL_LTCG \"/GL\" \"-LTCG\"\n-                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n-  endif()\n-\n-  # Enable LTO flags if found, except for Debug builds\n-  if(PYBIND11_LTO_CXX_FLAGS)\n-    # CONFIG takes multiple values in CMake 3.19+, until then we have to use OR\n-    set(is_debug \"$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>\")\n-    set(not_debug \"$<NOT:${is_debug}>\")\n-    set(cxx_lang \"$<COMPILE_LANGUAGE:CXX>\")\n-    if(MSVC AND CMAKE_VERSION VERSION_LESS 3.11)\n-      set(genex \"${not_debug}\")\n-    else()\n-      set(genex \"$<AND:${not_debug},${cxx_lang}>\")\n-    endif()\n-    set_property(\n-      TARGET ${target}\n-      APPEND\n-      PROPERTY INTERFACE_COMPILE_OPTIONS \"$<${genex}:${PYBIND11_LTO_CXX_FLAGS}>\")\n-    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n-      message(STATUS \"${target} enabled\")\n-    endif()\n-  else()\n-    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n-      message(STATUS \"${target} disabled (not supported by the compiler and/or linker)\")\n-    endif()\n-  endif()\n-\n-  if(PYBIND11_LTO_LINKER_FLAGS)\n-    if(CMAKE_VERSION VERSION_LESS 3.11)\n-      set_property(\n-        TARGET ${target}\n-        APPEND\n-        PROPERTY INTERFACE_LINK_LIBRARIES \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n-    else()\n-      set_property(\n-        TARGET ${target}\n-        APPEND\n-        PROPERTY INTERFACE_LINK_OPTIONS \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n-    endif()\n-  endif()\n-endfunction()\n-\n-add_library(pybind11::lto IMPORTED INTERFACE ${optional_global})\n-_pybind11_generate_lto(pybind11::lto FALSE)\n-\n-add_library(pybind11::thin_lto IMPORTED INTERFACE ${optional_global})\n-_pybind11_generate_lto(pybind11::thin_lto TRUE)\n-\n-# ---------------------- pybind11_strip -----------------------------\n-\n-function(pybind11_strip target_name)\n-  # Strip unnecessary sections of the binary on Linux/macOS\n-  if(CMAKE_STRIP)\n-    if(APPLE)\n-      set(x_opt -x)\n-    endif()\n-\n-    add_custom_command(\n-      TARGET ${target_name}\n-      POST_BUILD\n-      COMMAND ${CMAKE_STRIP} ${x_opt} $<TARGET_FILE:${target_name}>)\n-  endif()\n-endfunction()\n-#[======================================================[.rst\n-\n-Adds the following targets::\n-\n-    pybind11::pybind11 - link to headers and pybind11\n-    pybind11::module - Adds module links\n-    pybind11::embed - Adds embed links\n-    pybind11::lto - Link time optimizations (manual selection)\n-    pybind11::thin_lto - Link time optimizations (manual selection)\n-    pybind11::python_link_helper - Adds link to Python libraries\n-    pybind11::windows_extras - MSVC bigobj and mp for building multithreaded\n-    pybind11::opt_size - avoid optimizations that increase code size\n-\n-Adds the following functions::\n-\n-    pybind11_strip(target) - strip target after building on linux/macOS\n-    pybind11_find_import(module) - See if a module is installed.\n-\n-#]======================================================]\n-\n-# CMake 3.10 has an include_guard command, but we can't use that yet\n-# include_guard(global) (pre-CMake 3.10)\n-if(TARGET pybind11::lto)\n-  return()\n-endif()\n-\n-# If we are in subdirectory mode, all IMPORTED targets must be GLOBAL. If we\n-# are in CONFIG mode, they should be \"normal\" targets instead.\n-# In CMake 3.11+ you can promote a target to global after you create it,\n-# which might be simpler than this check.\n-get_property(\n-  is_config\n-  TARGET pybind11::headers\n-  PROPERTY IMPORTED)\n-if(NOT is_config)\n-  set(optional_global GLOBAL)\n-endif()\n-\n-# If not run in Python mode, we still would like this to at least\n-# include pybind11's include directory:\n-set(pybind11_INCLUDE_DIRS\n-    \"${pybind11_INCLUDE_DIR}\"\n-    CACHE INTERNAL \"Include directory for pybind11 (Python not requested)\")\n-\n-# --------------------- Shared targets ----------------------------\n-\n-# Build an interface library target:\n-add_library(pybind11::pybind11 IMPORTED INTERFACE ${optional_global})\n-set_property(\n-  TARGET pybind11::pybind11\n-  APPEND\n-  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::headers)\n-\n-# Build a module target:\n-add_library(pybind11::module IMPORTED INTERFACE ${optional_global})\n-set_property(\n-  TARGET pybind11::module\n-  APPEND\n-  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n-\n-# Build an embed library target:\n-add_library(pybind11::embed IMPORTED INTERFACE ${optional_global})\n-set_property(\n-  TARGET pybind11::embed\n-  APPEND\n-  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n-\n-# --------------------------- link helper ---------------------------\n-\n-add_library(pybind11::python_link_helper IMPORTED INTERFACE ${optional_global})\n-\n-if(CMAKE_VERSION VERSION_LESS 3.13)\n-  # In CMake 3.11+, you can set INTERFACE properties via the normal methods, and\n-  # this would be simpler.\n-  set_property(\n-    TARGET pybind11::python_link_helper\n-    APPEND\n-    PROPERTY INTERFACE_LINK_LIBRARIES \"$<$<PLATFORM_ID:Darwin>:-undefined dynamic_lookup>\")\n else()\n-  # link_options was added in 3.13+\n-  # This is safer, because you are ensured the deduplication pass in CMake will not consider\n-  # these separate and remove one but not the other.\n-  set_property(\n-    TARGET pybind11::python_link_helper\n-    APPEND\n-    PROPERTY INTERFACE_LINK_OPTIONS \"$<$<PLATFORM_ID:Darwin>:LINKER:-undefined,dynamic_lookup>\")\n-endif()\n \n-# ------------------------ Windows extras -------------------------\n-\n-add_library(pybind11::windows_extras IMPORTED INTERFACE ${optional_global})\n-\n-if(MSVC) # That's also clang-cl\n-  # /bigobj is needed for bigger binding projects due to the limit to 64k\n-  # addressable sections\n-  set_property(\n-    TARGET pybind11::windows_extras\n-    APPEND\n-    PROPERTY INTERFACE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:/bigobj>)\n-\n-  # /MP enables multithreaded builds (relevant when there are many files) for MSVC\n-  if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"MSVC\") # no Clang no Intel\n-    if(CMAKE_VERSION VERSION_LESS 3.11)\n-      set_property(\n-        TARGET pybind11::windows_extras\n-        APPEND\n-        PROPERTY INTERFACE_COMPILE_OPTIONS $<$<NOT:$<CONFIG:Debug>>:/MP>)\n-    else()\n-      # Only set these options for C++ files.  This is important so that, for\n-      # instance, projects that include other types of source files like CUDA\n-      # .cu files don't get these options propagated to nvcc since that would\n-      # cause the build to fail.\n-      set_property(\n-        TARGET pybind11::windows_extras\n-        APPEND\n-        PROPERTY INTERFACE_COMPILE_OPTIONS\n-                 $<$<NOT:$<CONFIG:Debug>>:$<$<COMPILE_LANGUAGE:CXX>:/MP>>)\n-    endif()\n-  endif()\n-endif()\n-\n-# ----------------------- Optimize binary size --------------------------\n-\n-add_library(pybind11::opt_size IMPORTED INTERFACE ${optional_global})\n-\n-if(MSVC)\n-  set(PYBIND11_OPT_SIZE /Os)\n-else()\n-  set(PYBIND11_OPT_SIZE -Os)\n-endif()\n-\n-set_property(\n-  TARGET pybind11::opt_size\n-  APPEND\n-  PROPERTY INTERFACE_COMPILE_OPTIONS $<$<CONFIG:Release>:${PYBIND11_OPT_SIZE}>\n-           $<$<CONFIG:MinSizeRel>:${PYBIND11_OPT_SIZE}>\n-           $<$<CONFIG:RelWithDebInfo>:${PYBIND11_OPT_SIZE}>)\n-\n-# ----------------------- Legacy option --------------------------\n-\n-# Warn or error if old variable name used\n-if(PYBIND11_CPP_STANDARD)\n-  string(REGEX MATCH [[..$]] VAL \"${PYBIND11_CPP_STANDARD}\")\n-  if(CMAKE_CXX_STANDARD)\n-    if(NOT CMAKE_CXX_STANDARD STREQUAL VAL)\n-      message(WARNING \"CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} does not match \"\n-                      \"PYBIND11_CPP_STANDARD=${PYBIND11_CPP_STANDARD}, \"\n-                      \"please remove PYBIND11_CPP_STANDARD from your cache\")\n-    endif()\n-  else()\n-    set(supported_standards 11 14 17 20)\n-    if(\"${VAL}\" IN_LIST supported_standards)\n-      message(WARNING \"USE -DCMAKE_CXX_STANDARD=${VAL} instead of PYBIND11_CPP_STANDARD\")\n-      set(CMAKE_CXX_STANDARD\n-          ${VAL}\n-          CACHE STRING \"From PYBIND11_CPP_STANDARD\")\n-    else()\n-      message(FATAL_ERROR \"PYBIND11_CPP_STANDARD should be replaced with CMAKE_CXX_STANDARD \"\n-                          \"(last two chars: ${VAL} not understood as a valid CXX std)\")\n-    endif()\n-  endif()\n-endif()\n-\n-# --------------------- Python specifics -------------------------\n-\n-# Check to see which Python mode we are in, new, old, or no python\n-if(PYBIND11_NOPYTHON)\n-  set(_pybind11_nopython ON)\n-elseif(\n-  PYBIND11_FINDPYTHON\n-  OR Python_FOUND\n-  OR Python2_FOUND\n-  OR Python3_FOUND)\n-  # New mode\n-  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n-\n-else()\n-\n   # Classic mode\n   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n \n endif()\n"
                },
                {
                    "date": 1691477825299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,12 +173,12 @@\n #   OR Python3_FOUND)\n #   # New mode\n #   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n \n-else()\n+# else()\n \n-  # Classic mode\n-  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n+#   # Classic mode\n+#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n \n endif()\n \n # --------------------- pybind11_find_import -------------------------------\n"
                },
                {
                    "date": 1691478061928,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,20 +165,20 @@\n \n # Check to see which Python mode we are in, new, old, or no python\n if(PYBIND11_NOPYTHON)\n   set(_pybind11_nopython ON)\n-# elseif(\n-#   PYBIND11_FINDPYTHON\n-#   OR Python_FOUND\n-#   OR Python2_FOUND\n-#   OR Python3_FOUND)\n-#   # New mode\n-#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n+elseif(\n+  PYBIND11_FINDPYTHON\n+  OR Python_FOUND\n+  OR Python2_FOUND\n+  OR Python3_FOUND)\n+  # New mode\n+  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n \n-# else()\n+else()\n \n-#   # Classic mode\n-#   include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n+  # Classic mode\n+  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n \n endif()\n \n # --------------------- pybind11_find_import -------------------------------\n"
                }
            ],
            "date": 1691477793683,
            "name": "Commit-0",
            "content": "#[======================================================[.rst\n\nAdds the following targets::\n\n    pybind11::pybind11 - link to headers and pybind11\n    pybind11::module - Adds module links\n    pybind11::embed - Adds embed links\n    pybind11::lto - Link time optimizations (manual selection)\n    pybind11::thin_lto - Link time optimizations (manual selection)\n    pybind11::python_link_helper - Adds link to Python libraries\n    pybind11::windows_extras - MSVC bigobj and mp for building multithreaded\n    pybind11::opt_size - avoid optimizations that increase code size\n\nAdds the following functions::\n\n    pybind11_strip(target) - strip target after building on linux/macOS\n    pybind11_find_import(module) - See if a module is installed.\n\n#]======================================================]\n\n# CMake 3.10 has an include_guard command, but we can't use that yet\n# include_guard(global) (pre-CMake 3.10)\nif(TARGET pybind11::lto)\n  return()\nendif()\n\n# If we are in subdirectory mode, all IMPORTED targets must be GLOBAL. If we\n# are in CONFIG mode, they should be \"normal\" targets instead.\n# In CMake 3.11+ you can promote a target to global after you create it,\n# which might be simpler than this check.\nget_property(\n  is_config\n  TARGET pybind11::headers\n  PROPERTY IMPORTED)\nif(NOT is_config)\n  set(optional_global GLOBAL)\nendif()\n\n# If not run in Python mode, we still would like this to at least\n# include pybind11's include directory:\nset(pybind11_INCLUDE_DIRS\n    \"${pybind11_INCLUDE_DIR}\"\n    CACHE INTERNAL \"Include directory for pybind11 (Python not requested)\")\n\n# --------------------- Shared targets ----------------------------\n\n# Build an interface library target:\nadd_library(pybind11::pybind11 IMPORTED INTERFACE ${optional_global})\nset_property(\n  TARGET pybind11::pybind11\n  APPEND\n  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::headers)\n\n# Build a module target:\nadd_library(pybind11::module IMPORTED INTERFACE ${optional_global})\nset_property(\n  TARGET pybind11::module\n  APPEND\n  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n\n# Build an embed library target:\nadd_library(pybind11::embed IMPORTED INTERFACE ${optional_global})\nset_property(\n  TARGET pybind11::embed\n  APPEND\n  PROPERTY INTERFACE_LINK_LIBRARIES pybind11::pybind11)\n\n# --------------------------- link helper ---------------------------\n\nadd_library(pybind11::python_link_helper IMPORTED INTERFACE ${optional_global})\n\nif(CMAKE_VERSION VERSION_LESS 3.13)\n  # In CMake 3.11+, you can set INTERFACE properties via the normal methods, and\n  # this would be simpler.\n  set_property(\n    TARGET pybind11::python_link_helper\n    APPEND\n    PROPERTY INTERFACE_LINK_LIBRARIES \"$<$<PLATFORM_ID:Darwin>:-undefined dynamic_lookup>\")\nelse()\n  # link_options was added in 3.13+\n  # This is safer, because you are ensured the deduplication pass in CMake will not consider\n  # these separate and remove one but not the other.\n  set_property(\n    TARGET pybind11::python_link_helper\n    APPEND\n    PROPERTY INTERFACE_LINK_OPTIONS \"$<$<PLATFORM_ID:Darwin>:LINKER:-undefined,dynamic_lookup>\")\nendif()\n\n# ------------------------ Windows extras -------------------------\n\nadd_library(pybind11::windows_extras IMPORTED INTERFACE ${optional_global})\n\nif(MSVC) # That's also clang-cl\n  # /bigobj is needed for bigger binding projects due to the limit to 64k\n  # addressable sections\n  set_property(\n    TARGET pybind11::windows_extras\n    APPEND\n    PROPERTY INTERFACE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:/bigobj>)\n\n  # /MP enables multithreaded builds (relevant when there are many files) for MSVC\n  if(\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"MSVC\") # no Clang no Intel\n    if(CMAKE_VERSION VERSION_LESS 3.11)\n      set_property(\n        TARGET pybind11::windows_extras\n        APPEND\n        PROPERTY INTERFACE_COMPILE_OPTIONS $<$<NOT:$<CONFIG:Debug>>:/MP>)\n    else()\n      # Only set these options for C++ files.  This is important so that, for\n      # instance, projects that include other types of source files like CUDA\n      # .cu files don't get these options propagated to nvcc since that would\n      # cause the build to fail.\n      set_property(\n        TARGET pybind11::windows_extras\n        APPEND\n        PROPERTY INTERFACE_COMPILE_OPTIONS\n                 $<$<NOT:$<CONFIG:Debug>>:$<$<COMPILE_LANGUAGE:CXX>:/MP>>)\n    endif()\n  endif()\nendif()\n\n# ----------------------- Optimize binary size --------------------------\n\nadd_library(pybind11::opt_size IMPORTED INTERFACE ${optional_global})\n\nif(MSVC)\n  set(PYBIND11_OPT_SIZE /Os)\nelse()\n  set(PYBIND11_OPT_SIZE -Os)\nendif()\n\nset_property(\n  TARGET pybind11::opt_size\n  APPEND\n  PROPERTY INTERFACE_COMPILE_OPTIONS $<$<CONFIG:Release>:${PYBIND11_OPT_SIZE}>\n           $<$<CONFIG:MinSizeRel>:${PYBIND11_OPT_SIZE}>\n           $<$<CONFIG:RelWithDebInfo>:${PYBIND11_OPT_SIZE}>)\n\n# ----------------------- Legacy option --------------------------\n\n# Warn or error if old variable name used\nif(PYBIND11_CPP_STANDARD)\n  string(REGEX MATCH [[..$]] VAL \"${PYBIND11_CPP_STANDARD}\")\n  if(CMAKE_CXX_STANDARD)\n    if(NOT CMAKE_CXX_STANDARD STREQUAL VAL)\n      message(WARNING \"CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} does not match \"\n                      \"PYBIND11_CPP_STANDARD=${PYBIND11_CPP_STANDARD}, \"\n                      \"please remove PYBIND11_CPP_STANDARD from your cache\")\n    endif()\n  else()\n    set(supported_standards 11 14 17 20)\n    if(\"${VAL}\" IN_LIST supported_standards)\n      message(WARNING \"USE -DCMAKE_CXX_STANDARD=${VAL} instead of PYBIND11_CPP_STANDARD\")\n      set(CMAKE_CXX_STANDARD\n          ${VAL}\n          CACHE STRING \"From PYBIND11_CPP_STANDARD\")\n    else()\n      message(FATAL_ERROR \"PYBIND11_CPP_STANDARD should be replaced with CMAKE_CXX_STANDARD \"\n                          \"(last two chars: ${VAL} not understood as a valid CXX std)\")\n    endif()\n  endif()\nendif()\n\n# --------------------- Python specifics -------------------------\n\n# Check to see which Python mode we are in, new, old, or no python\nif(PYBIND11_NOPYTHON)\n  set(_pybind11_nopython ON)\n# elseif(\n#   PYBIND11_FINDPYTHON\n#   OR Python_FOUND\n#   OR Python2_FOUND\n#   OR Python3_FOUND)\n  # New mode\n  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11NewTools.cmake\")\n\nelse()\n\n  # Classic mode\n  include(\"${CMAKE_CURRENT_LIST_DIR}/pybind11Tools.cmake\")\n\nendif()\n\n# --------------------- pybind11_find_import -------------------------------\n\nif(NOT _pybind11_nopython)\n  # Check to see if modules are importable. Use REQUIRED to force an error if\n  # one of the modules is not found. <package_name>_FOUND will be set if the\n  # package was found (underscores replace dashes if present). QUIET will hide\n  # the found message, and VERSION will require a minimum version. A successful\n  # find will cache the result.\n  function(pybind11_find_import PYPI_NAME)\n    # CMake variables need underscores (PyPI doesn't care)\n    string(REPLACE \"-\" \"_\" NORM_PYPI_NAME \"${PYPI_NAME}\")\n\n    # Return if found previously\n    if(${NORM_PYPI_NAME}_FOUND)\n      return()\n    endif()\n\n    set(options \"REQUIRED;QUIET\")\n    set(oneValueArgs \"VERSION\")\n    cmake_parse_arguments(ARG \"${options}\" \"${oneValueArgs}\" \"\" ${ARGN})\n\n    if(ARG_REQUIRED)\n      set(status_level FATAL_ERROR)\n    else()\n      set(status_level WARNING)\n    endif()\n\n    execute_process(\n      COMMAND\n        ${${_Python}_EXECUTABLE} -c\n        \"from pkg_resources import get_distribution; print(get_distribution('${PYPI_NAME}').version)\"\n      RESULT_VARIABLE RESULT_PRESENT\n      OUTPUT_VARIABLE PKG_VERSION\n      ERROR_QUIET)\n\n    string(STRIP \"${PKG_VERSION}\" PKG_VERSION)\n\n    # If a result is present, this failed\n    if(RESULT_PRESENT)\n      set(${NORM_PYPI_NAME}_FOUND\n          ${NORM_PYPI_NAME}-NOTFOUND\n          CACHE INTERNAL \"\")\n      # Always warn or error\n      message(\n        ${status_level}\n        \"Missing: ${PYPI_NAME} ${ARG_VERSION}\\nTry: ${${_Python}_EXECUTABLE} -m pip install ${PYPI_NAME}\"\n      )\n    else()\n      if(ARG_VERSION AND PKG_VERSION VERSION_LESS ARG_VERSION)\n        message(\n          ${status_level}\n          \"Version incorrect: ${PYPI_NAME} ${PKG_VERSION} found, ${ARG_VERSION} required - try upgrading\"\n        )\n      else()\n        set(${NORM_PYPI_NAME}_FOUND\n            YES\n            CACHE INTERNAL \"\")\n        set(${NORM_PYPI_NAME}_VERSION\n            ${PKG_VERSION}\n            CACHE INTERNAL \"\")\n      endif()\n      if(NOT ARG_QUIET)\n        message(STATUS \"Found ${PYPI_NAME} ${PKG_VERSION}\")\n      endif()\n    endif()\n    if(NOT ARG_VERSION OR (NOT PKG_VERSION VERSION_LESS ARG_VERSION))\n      # We have successfully found a good version, cache to avoid calling again.\n    endif()\n  endfunction()\nendif()\n\n# --------------------- LTO -------------------------------\n\ninclude(CheckCXXCompilerFlag)\n\n# Checks whether the given CXX/linker flags can compile and link a cxx file.\n# cxxflags and linkerflags are lists of flags to use.  The result variable is a\n# unique variable name for each set of flags: the compilation result will be\n# cached base on the result variable.  If the flags work, sets them in\n# cxxflags_out/linkerflags_out internal cache variables (in addition to\n# ${result}).\nfunction(_pybind11_return_if_cxx_and_linker_flags_work result cxxflags linkerflags cxxflags_out\n         linkerflags_out)\n  set(CMAKE_REQUIRED_LIBRARIES ${linkerflags})\n  check_cxx_compiler_flag(\"${cxxflags}\" ${result})\n  if(${result})\n    set(${cxxflags_out}\n        \"${cxxflags}\"\n        PARENT_SCOPE)\n    set(${linkerflags_out}\n        \"${linkerflags}\"\n        PARENT_SCOPE)\n  endif()\nendfunction()\n\nfunction(_pybind11_generate_lto target prefer_thin_lto)\n  if(MINGW)\n    message(STATUS \"${target} disabled (problems with undefined symbols for MinGW for now)\")\n    return()\n  endif()\n\n  if(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\n    set(cxx_append \"\")\n    set(linker_append \"\")\n    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" AND NOT APPLE)\n      # Clang Gold plugin does not support -Os; append -O3 to MinSizeRel builds to override it\n      set(linker_append \";$<$<CONFIG:MinSizeRel>:-O3>\")\n    elseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\" AND NOT MINGW)\n      set(cxx_append \";-fno-fat-lto-objects\")\n    endif()\n\n    if(CMAKE_SYSTEM_PROCESSOR MATCHES \"ppc64le\" OR CMAKE_SYSTEM_PROCESSOR MATCHES \"mips64\")\n      set(NO_FLTO_ARCH TRUE)\n    else()\n      set(NO_FLTO_ARCH FALSE)\n    endif()\n\n    if(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\"\n       AND prefer_thin_lto\n       AND NOT NO_FLTO_ARCH)\n      _pybind11_return_if_cxx_and_linker_flags_work(\n        HAS_FLTO_THIN \"-flto=thin${cxx_append}\" \"-flto=thin${linker_append}\"\n        PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n    endif()\n\n    if(NOT HAS_FLTO_THIN AND NOT NO_FLTO_ARCH)\n      _pybind11_return_if_cxx_and_linker_flags_work(\n        HAS_FLTO \"-flto${cxx_append}\" \"-flto${linker_append}\" PYBIND11_LTO_CXX_FLAGS\n        PYBIND11_LTO_LINKER_FLAGS)\n    endif()\n  elseif(CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n    # Intel equivalent to LTO is called IPO\n    _pybind11_return_if_cxx_and_linker_flags_work(HAS_INTEL_IPO \"-ipo\" \"-ipo\"\n                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n  elseif(MSVC)\n    # cmake only interprets libraries as linker flags when they start with a - (otherwise it\n    # converts /LTCG to \\LTCG as if it was a Windows path).  Luckily MSVC supports passing flags\n    # with - instead of /, even if it is a bit non-standard:\n    _pybind11_return_if_cxx_and_linker_flags_work(HAS_MSVC_GL_LTCG \"/GL\" \"-LTCG\"\n                                                  PYBIND11_LTO_CXX_FLAGS PYBIND11_LTO_LINKER_FLAGS)\n  endif()\n\n  # Enable LTO flags if found, except for Debug builds\n  if(PYBIND11_LTO_CXX_FLAGS)\n    # CONFIG takes multiple values in CMake 3.19+, until then we have to use OR\n    set(is_debug \"$<OR:$<CONFIG:Debug>,$<CONFIG:RelWithDebInfo>>\")\n    set(not_debug \"$<NOT:${is_debug}>\")\n    set(cxx_lang \"$<COMPILE_LANGUAGE:CXX>\")\n    if(MSVC AND CMAKE_VERSION VERSION_LESS 3.11)\n      set(genex \"${not_debug}\")\n    else()\n      set(genex \"$<AND:${not_debug},${cxx_lang}>\")\n    endif()\n    set_property(\n      TARGET ${target}\n      APPEND\n      PROPERTY INTERFACE_COMPILE_OPTIONS \"$<${genex}:${PYBIND11_LTO_CXX_FLAGS}>\")\n    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n      message(STATUS \"${target} enabled\")\n    endif()\n  else()\n    if(CMAKE_PROJECT_NAME STREQUAL \"pybind11\")\n      message(STATUS \"${target} disabled (not supported by the compiler and/or linker)\")\n    endif()\n  endif()\n\n  if(PYBIND11_LTO_LINKER_FLAGS)\n    if(CMAKE_VERSION VERSION_LESS 3.11)\n      set_property(\n        TARGET ${target}\n        APPEND\n        PROPERTY INTERFACE_LINK_LIBRARIES \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n    else()\n      set_property(\n        TARGET ${target}\n        APPEND\n        PROPERTY INTERFACE_LINK_OPTIONS \"$<${not_debug}:${PYBIND11_LTO_LINKER_FLAGS}>\")\n    endif()\n  endif()\nendfunction()\n\nadd_library(pybind11::lto IMPORTED INTERFACE ${optional_global})\n_pybind11_generate_lto(pybind11::lto FALSE)\n\nadd_library(pybind11::thin_lto IMPORTED INTERFACE ${optional_global})\n_pybind11_generate_lto(pybind11::thin_lto TRUE)\n\n# ---------------------- pybind11_strip -----------------------------\n\nfunction(pybind11_strip target_name)\n  # Strip unnecessary sections of the binary on Linux/macOS\n  if(CMAKE_STRIP)\n    if(APPLE)\n      set(x_opt -x)\n    endif()\n\n    add_custom_command(\n      TARGET ${target_name}\n      POST_BUILD\n      COMMAND ${CMAKE_STRIP} ${x_opt} $<TARGET_FILE:${target_name}>)\n  endif()\nendfunction()\n"
        }
    ]
}